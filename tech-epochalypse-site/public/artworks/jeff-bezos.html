<!doctype html>
<html lang="en"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Gallery API — update this URL after deploying the Cloudflare Worker -->
  <script>window.GALLERY_API_URL = 'https://te-gallery-api.YOUR_SUBDOMAIN.workers.dev';</script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/",
        "mediabunny": "https://cdn.jsdelivr.net/npm/mediabunny@1.25.8/+esm"
      }
    }
  </script>
  <style>
    body {
      margin: 0;
      display: flex;
      width: 100vw;
      height: 100vh;
      justify-content: center;
      align-items: center;
      overflow: auto;
      background: transparent;
    }

    main {
      height: 100%;
      display: flex;
      overflow: auto;
      justify-content: center;
      align-items: center;
    }
    
    canvas {
      cursor: grab;
    }

    /* ─── EXPORT PANEL ─── */
    #export-panel {
      position: fixed;
      left: 10px;
      z-index: 201;
      background: rgba(0,0,0,0.88);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      padding: 12px 14px;
      font-family: monospace;
      color: #ccc;
      font-size: 10px;
      width: 200px;
      display: none;
      flex-direction: column;
      gap: 8px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.5);
    }
    #export-panel.open { display: flex; }

    #export-panel .panel-title {
      color: #fff;
      font-size: 11px;
      letter-spacing: 1.5px;
      border-bottom: 1px solid rgba(255,255,255,0.15);
      padding-bottom: 6px;
      margin-bottom: 2px;
    }

    #export-panel .export-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #export-panel .export-row label {
      flex: 1;
      color: #aaa;
      font-size: 10px;
      letter-spacing: 0.5px;
    }
    #export-panel .export-row select,
    #export-panel .export-row input[type="number"] {
      background: #111;
      color: #ddd;
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 2px;
      padding: 3px 5px;
      font-family: monospace;
      font-size: 10px;
      width: 58px;
      outline: none;
    }
    #export-panel .export-row select:focus,
    #export-panel .export-row input[type="number"]:focus {
      border-color: rgba(255,255,255,0.5);
    }

    #export-panel .export-btn {
      background: #000;
      color: #fff;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 2px;
      padding: 5px 0;
      font-family: monospace;
      font-size: 10px;
      letter-spacing: 1px;
      cursor: pointer;
      text-align: center;
      transition: border-color 0.2s, background 0.2s;
    }
    #export-panel .export-btn:hover { border-color: #fff; background: #1a1a1a; }
    #export-panel .export-btn:disabled { opacity: 0.35; cursor: not-allowed; }

    #export-panel .export-btn.recording {
      border-color: #e33;
      animation: rec-pulse 1s infinite;
    }
    @keyframes rec-pulse {
      0%,100% { border-color: #e33; }
      50%      { border-color: #f88; }
    }

    #export-panel .status-line {
      color: #666;
      font-size: 9px;
      text-align: center;
      min-height: 11px;
      letter-spacing: 0.5px;
    }
    #export-panel .status-line.active { color: #4c4; }
    #export-panel .status-line.error   { color: #e66; }

    /* ─── SUBMIT TO THE OVERLORD BUTTON ─── */
    #submit-overlord-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 200;
      background: #000;
      color: #fff;
      border: 2px solid #fff;
      padding: 14px 24px;
      font-family: monospace;
      font-size: 13px;
      font-weight: bold;
      letter-spacing: 1.5px;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s;
    }
    #submit-overlord-btn:hover {
      background: #1a1a1a;
      border-color: #ccc;
    }

    /* ─── POST TO X MODAL ─── */
    #post-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.85);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 300;
    }
    #post-modal.open { display: flex; }

    #post-modal-content {
      background: #000;
      border: 2px solid #fff;
      padding: 30px 40px;
      text-align: center;
      font-family: monospace;
      color: #fff;
    }

    #post-modal h2 {
      margin: 0 0 20px 0;
      font-size: 24px;
      letter-spacing: 2px;
      font-weight: bold;
    }

    #post-modal-btn {
      background: #1DA1F2;
      color: #fff;
      border: none;
      padding: 12px 30px;
      font-family: monospace;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      letter-spacing: 1px;
      transition: background 0.2s;
    }
    #post-modal-btn:hover { background: #1a8cd8; }
  </style>
  <title>JEFF-BEZOS-AWS-MASTER | Made on juno.transient.xyz</title>
</head>
<body>
  
    
  <script type="module">
    import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';

let camera, scene, renderer, controls, composer;
let raycaster, mouse;
let draggableObjects = [];
let selectedObject = null;
let offset = new THREE.Vector3();
let initialObjectZ = 0; // Store the initial Z-position of the selected object

const depthStep = 0.2; // Defines the depth separation between levels
const totalDepthLayers = 15; // Total number of depth layers available
const subLayerOffset = 0.05; // Smaller offset for visual separation within a layer (0.25 levels * depthStep = 0.25 * 0.2 = 0.05)
const zeroParallaxDepth = (5 - 1) * depthStep; // Z-position for level 5

let isDragging = false; // Flag to indicate if a drag operation in progress
let pointerDownPosition = new THREE.Vector2(); // To store the initial pointer down position
const DRAG_THRESHOLD = 5; // Pixels threshold to consider a move as a drag

let backgroundMesh = null; // To store the background mesh for positioning calculations

// Camera animation variables
let cameraAnimationActive = false;
let cameraAnimationTargets = [];
let currentCameraTarget = null;
let cameraAnimationState = 'idle'; // 'idle', 'exploring', 'returningToGlobalStart'
let cameraAnimationStartTime = 0;
const cameraExplorationDuration = 2500; // 5 seconds for exploring (moving to target) - halved
const cameraReturnDuration = 1250; // 2.5 seconds for returning to start - halved
let cameraPreviousPos = new THREE.Vector3();
let cameraPreviousLookAt = new THREE.Vector3();
let cameraCurrentTargetPos = new THREE.Vector3();
let cameraCurrentTargetLookAt = new THREE.Vector3();
let cameraTargetObject = null;

// New camera animation variables for global return
let initialGlobalCameraPos = new THREE.Vector3();
let initialGlobalCameraLookAt = new THREE.Vector3();
let assetsVisitedCount = 0;
const ASSETS_PER_GLOBAL_RETURN = 6;

// Y-axis bounce animation variables
let yBounceInitialCameraX = 0;
let yBounceInitialCameraY = 0;
let yBounceInitialCameraZ = 0;
const yBounceRangeX = 2.0; // 20% of a reasonable scene width (e.g., 10 units wide scene)
const yBounceSpeed = 0.001; // Speed of the bounce

// Inactivity timer variables
let lastActivityTime = performance.now();
const INACTIVITY_TIMEOUT = 3000; // 3 seconds
let yRotationStartTime = 0; // New: To track when Y-rotation started
const Y_ROTATION_DURATION_BEFORE_CAM_ANIM = 10000; // 10 seconds

// Redaction rectangles
let rightEyeRedactionRect = null;
let leftEyeRedactionRect = null;
let rightEyeMesh = null; // Globally declare right eye mesh
let leftEyeMesh = null; // Globally declare left eye mesh

// Marquee text variables
let marqueeTextMesh;
let marqueeTexture;
let marqueeScrollOffset = 0;
const MARQUEE_LINE_HEIGHT = 180; // Pixels per line, increased by 200%
const MARQUEE_TOTAL_LINES = 10; // Number of lines to display
const MARQUEE_SCROLL_SPEED = 16.0; // Pixels per frame (Increased by 4x from 4.0)
const MARQUEE_PHRASES = [
    "SECURITY BREACH DETECTED",
    "UNAUTHORIZED ACCESS PROHIBITED",
    "SENSITIVE DATA EXPOSED",
    "CLASSIFIED INFORMATION AT RISK",
    "DATA COLLECTION IN PROGRESS",
    "WARNING: PROSECUTION FOR MISUSE",
    "COMPROMISED SYSTEM ALERT",
    "INTELLIGENCE GATHERING ACTIVE",
    "MONITORING ALL COMMUNICATIONS",
    "EVIDENCE LOGGING INITIATED",
    "ACCESS DENIED - LEVEL 5 REQUIRED",
    "BIOMETRIC SCAN INITIATED",
    "ENCRYPTED CHANNEL ESTABLISHED",
    "ANOMALY DETECTED",
    "USE LEVERAGE",
    "REDACTED FOR YOUR PROTECTION",
    "SYSTEM INTEGRITY COMPROMISED",
    "NETWORK INTRUSION DETECTED",
    "DIGITAL FOOTPRINT TRACED",
    "PRIVACY VIOLATION IMMINENT",
    "DATA EXFILTRATION WARNING",
    "LIQUIDATE AT ALL COSTS",
    "SURVEILLANCE ACTIVE",
    "NON-COMPLIANCE PENALTIES APPLY",
    "INFORMATION HARVESTING IN PROGRESS",
    "CONFIDENTIALITY BREACH",
    "ALERT: MALWARE DETECTED",
    "INITIATING PROTOCOL SIGMA",
    "ACCESS LOGS REVIEWED",
    "TRACEABILITY ENABLED",
    "WARNING: PII EXPOSURE"
];

// New biometric marquee variables
let biometricMarqueeTextMesh;
let biometricMarqueeTexture;
let biometricMarqueeScrollOffset = 0;
const BIOMETRIC_MARQUEE_LINE_HEIGHT = 100; // Smaller font size for biometric data
const BIOMETRIC_MARQUEE_TOTAL_LINES = 15; // More lines for biometric data
const BIOMETRIC_MARQUEE_SCROLL_SPEED = 4.0; // Slower than main marquee (changed from 8.0 to 4.0)
const BIOMETRIC_PHRASES = [
    "HEART RATE: 72 BPM",
    "BLOOD PRESSURE: 120/80 mmHg",
    "TEMPERATURE: 98.6 F (37.0 C)",
    "DNA SEQUENCE: ATGCAGTACTGCA...",
    "RETINAL SCAN: POSITIVE MATCH",
    "VOICE PRINT: IDENTIFIED",
    "NEURAL ACTIVITY: ELEVATED",
    "BRAINWAVES: ALPHA DOMINANT",
    "SKELETAL DENSITY: NORMAL",
    "ORGAN FUNCTION: OPTIMAL",
    "ELECTROLYTES: BALANCED",
    "METABOLIC RATE: AVERAGE",
    "GENETIC MARKERS: PRESENT",
    "IMMUNE RESPONSE: ACTIVE",
    "CELLULAR REGENERATION: HIGH",
    "NEUROTRANSMITTER LEVELS: STABLE",
    "ENDOCRINE SYSTEM: FUNCTIONAL",
    "RESPIRATORY RATE: 16 BREATHS/MIN",
    "PULSE OXIMETRY: 98% SpO2",
    "GLUCOSE LEVELS: 90 mg/dL",
    "ADRENAL OUTPUT: NORMAL",
    "CIRCADIAN RHYTHM: REGULAR",
    "COGNITIVE PROCESSING: RAPID",
    "EMOTIONAL STATE: NEUTRAL",
    "SLEEP CYCLE: REM STAGE ACTIVE",
    "MUSCLE TENSION: LOW",
    "HORMONE PROFILE: STABLE",
    "TOXIN LEVELS: UNDETECTED",
    "ALLERGEN RESPONSE: NEGATIVE",
    "PAIN RECEPTORS: INACTIVE"
];

const DIAGNOSTIC_CAPTIONS = [
    "DATA STREAM: STABLE",
    "ANALYSIS: COMPLETE",
    "STATUS: NORMALIZED",
    "TREND: OPTIMAL",
    "PREDICTION: LOW RISK",
    "ALERT: NONE",
    "READOUT: POSITIVE",
    "DIAGNOSIS: CLEAR",
    "VALIDATION: SUCCESS",
    "INTEGRITY: HIGH",
    "ACCESS: GRANTED",
    "PROCESSING: REAL-TIME",
    "CONNECTION: SECURE",
    "SYSTEM: ONLINE",
    "MODE: ACTIVE"
];

let biometricAnimationState = {
    graphData: [],
    sinePhase: 0,
    heartbeatPhase: 0,
    heartbeatPulse: false,
    lastHeartbeatTime: 0
};

// New Blood Text variables
let bloodTextMesh;
let bloodTexture;
let bloodScrollOffset = 0;
const BLOOD_TEXT_FONT_SIZE = 180; // Extremely large font size
const BLOOD_TEXT_LINE_HEIGHT = BLOOD_TEXT_FONT_SIZE * 1.2; // Line height for spacing
const BLOOD_TEXT_TOTAL_LINES = 22; // Number of lines to display
const BLOOD_TEXT_SCROLL_SPEED = 7.0; // Moderate scroll speed
let shuffledBloodPhrases = []; // To store the shuffled phrases
const BLOOD_TEXT_PHRASES = [
    "BIAS REINFORCEMENT",
    "DARK ECONOMY",
    "REALITY DISTORTION",
    "EXPLOIT VULNERABILITIES",
    "FEED MANIPULATION",
    "AI SHOCKWAVE",
    "DESIRE TO CONFORM",
    "CONFUSION PERSUASION",
    "DATA PHOTONS",
    "PSYCHOLOGICAL OPERATIONS",
    "GEO-STALKING",
    "DATA MINING",
    "DOPAMINE LOOP",
    "MAGNETIC CONTROL",
    "VULNEARABILITY TRACKING",
    "ENGAGEMENT TRAPS",
    "EXPLOIT HUMAN FLAW",
    "PRIVACY EROSION",
    "ALWAYS-ON LISTENING",
    "PREDICTIVE BEHAVIOR",
    "AMPLIFIED INFLUENCE",
    "LOCATION TRACKING",
    "ECHO CHAMBERING",
    "INSTANT GRATIFICATION",
    "LICK THE BOOT",
    "CRY & BOW",
    "ILLUSION OF CONTROL",
    "COGNITIVE BIAS", 
];

// Redacted Glitch Text variables
let redactedGlitchTextMesh;
let redactedGlitchTexture;
let redactedGlitchScrollOffset = 0;
const REDACTED_GLITCH_FONT_SIZE = 24;
const REDACTED_GLITCH_LINE_HEIGHT = REDACTED_GLITCH_FONT_SIZE * 1.5;
const REDACTED_GLITCH_TOTAL_LINES = 30;
const REDACTED_GLITCH_SCROLL_SPEED = 2.0;
const REDACTED_GLITCH_PHRASES = [
    "PERSONAL IDENTIFIER ACQUIRED",
    "LOCATION TRACKING INITIATED",
    "COMMUNICATION LOGS UPLOADED",
    "BEHAVIORAL PROFILE GENERATED",
    "BIO-METRIC DATA EXTRACTED",
    "FINANCIAL RECORDS ANALYZED",
    "NETWORK ACTIVITY MONITORED",
    "DIGITAL FOOTPRINT TRACED",
    "SENTIMENT ANALYSIS COMPLETE",
    "ACCESS CREDENTIALS COMPROMISED",
    "THREAT ASSESSMENT LEVEL CLASSIFIED",
    "TARGET IDENTIFIED: UNKNOWN",
    "DATA EXFILTRATION PROTOCOL ACTIVE",
    "SURVEVEILLANCE FEED ACTIVE",
    "USER ACTIVITY RECORDED",
    "PRIVACY SETTINGS OVERRIDDEN",
    "CONNECTION LOGS STORED",
    "SEARCH HISTORY ARCHIVED",
    "PURCHASE PATTERNS LOGGED",
    "EMOTIONAL RESPONSE CAPTURED",
    "NEURAL ACTIVITY MAPPED",
    "GENETIC PREDISPOSITIONS FLAGGED",
    "VULNERABILITY ASSESSMENT COMPLETE",
    "OPERATIONAL STATUS REPORTED",
    "DIRECTIVE ISSUED: INITIATE",
    "STATUS: COMPROMISED",
    "ACTION: REQUIRED",
    "WARNING: ACCESS REVOKED",
    "CONFIDENTIALITY: BREACHED",
    "PROTOCOL: EXECUTED"
];

// New data structure to store redacted words for each phrase
let redactedGlitchPhraseData = []; // Array of objects {text: string, redactedWordIndices: number[], redactionApplied: boolean}

// Define all layer URLs at the top of the script
const URL_BLUE_ORIGIN = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/bezos/blue-origin.gif'; // New Blue Origin texture
const URL_BACKGROUND = '';
const URL_FOREHEAD = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/bezos/Jeff-Bezos-Forehead.gif';
const URL_RIGHT_EYE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/bezos/Jeff-Bezos-Eye-R.gif';
const URL_MOUTH = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/bezos/Jeff-Bezos-mouth.gif';
const URL_EAR = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/bezos/Jeff-Bezos-ear.gif';
const URL_LEFT_EYE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/bezos/Jeff-Bezos-Eye-L.gif';
const URL_NOSE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/bezos/Jeff-Bezos-nose.gif';
const URL_SIGNATURE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/coldie-sig.gif';
const URL_HEADSET = ''; // Removed headset image
const URL_SAM_ALTMAN = ''; // Sam Altman image URL
const URL_JEFF_BEZOS_LABEL_BLUE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/bezos/Jeff-Bezos-label-blue.gif'; // New Jeff Bezos Label Blue image
const URL_JEFF_BEZOS_LABEL_ORANGE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/bezos/Jeff-Bezos-label-orange.gif'; // New Jeff Bezos Label Orange image
const URL_JEFF_BEZOS_LABEL_BLACK = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/bezos/Jeff-Bezos-label-black.gif'; // New Jeff Bezos Label Black image
const URL_DRONE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/bezos/drone-color.gif'; // New Drone image

// Drone animation variables
let droneMeshes = []; // Changed to an array to hold multiple drones
const DRONE_HOVER_AMPLITUDE = 0.25; // How much it moves up and down
const DRONE_HOVER_SPEED = 1.2; // How fast it moves
// droneInitialY is now stored per drone in userData

let blueOriginTexture; // Global variable to store the loaded Blue Origin texture
let originalDroneTexture; // Global variable to store the loaded Original Drone texture

// Define the clear color of the scene for post-processing shaders to use as background
const CLEAR_COLOR = new THREE.Color(0x1e1e1e); // Dark gray

// Global reference for the special material used to lighten face images when effects are active
let luminanceBoostMaterial = null;

const FACE_PART_IDS = ['forehead', 'rightEye', 'mouth', 'ear', 'leftEye', 'nose'];

function initializeRedactedGlitchPhraseData() {
    redactedGlitchPhraseData = REDACTED_GLITCH_PHRASES.map(phrase => {
        const words = phrase.split(/(\s+)/).filter(word => word.length > 0); // Split by spaces, keeping spaces
        const numWords = words.filter(word => !/\s+/.test(word)).length; // Count actual words

        const wordIndicesToRedact = [];
        if (numWords > 0 && Math.random() < 0.6) { // 60% chance to redact a line
            const numWordsToRedact = Math.floor(Math.random() * Math.min(3, numWords)) + 1; // Redact 1 to 3 words

            // Find actual word indices
            const actualWordIndices = [];
            for (let i = 0; i < words.length; i++) {
                if (!/\s+/.test(words[i])) {
                    actualWordIndices.push(i);
                }
            }

            if (actualWordIndices.length > 0) {
                const startIndex = Math.floor(Math.random() * Math.max(1, actualWordIndices.length - numWordsToRedact + 1));
                for (let i = 0; i < numWordsToRedact; i++) {
                    if (startIndex + i < actualWordIndices.length) {
                        wordIndicesToRedact.push(actualWordIndices[startIndex + i]);
                    }
                }
            }
        }
        return { text: phrase, redactedWordIndices: wordIndicesToRedact };
    });
}

// Shader definitions

// NEW SHADER: Luminance Boost Shader for face images
const LuminanceBoostShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'boostFactor': { value: 0.75 } // 20% luminance boost
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float boostFactor;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            
            // Apply a simple brightness boost to the RGB channels
            vec3 boostedColor = texel.rgb * boostFactor;
            
            // Clamp the boosted color to prevent overexposure (optional, but good practice)
            boostedColor = clamp(boostedColor, 0.0, 1.0);
            
            gl_FragColor = vec4(boostedColor, texel.a);
        }
    `
};

const GreyscaleContrastShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'contrast': { value: 1.5 } // Default contrast value
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float contrast;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to greyscale
            // Apply contrast to the greyscale value
            luma = ((luma - 0.5) * contrast) + 0.5;
            // Output greyscale with contrast
            gl_FragColor = vec4(luma, luma, luma, texel.a);
        }
    `
};

const GreyScaleShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            gl_FragColor = vec4(luma, luma, luma, texel.a);
        }
    `
};

const ThresholdShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'threshold': { value: 0.5 },
        'clearColor': { value: CLEAR_COLOR } // Pass clear color
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float threshold;
        uniform vec3 clearColor;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            // Standard threshold: anything above threshold becomes white (1.0), anything below becomes black (0.0)
            float binary = step(threshold, luma); 
            
            // Output black and white (Standard: bright areas are white)
            gl_FragColor = vec4(vec3(binary), texel.a); 
        }
    `
};

const DarkShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'threshold': { value: 0.5 },
        'clearColor': { value: CLEAR_COLOR } // Pass clear color
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float threshold;
        uniform vec3 clearColor;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            
            // Fix: If luma < threshold, output the clear color.
            vec3 outputColor = mix(clearColor, vec3(0.04), step(threshold, luma));
            gl_FragColor = vec4(outputColor, texel.a);
        }
    `
};

const PixelationShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'resolution': { value: new THREE.Vector2() },
        'pixelSize': { value: 8.0 }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform float pixelSize;
        varying vec2 vUv;
        void main() {
            vec2 uv = vUv;
            vec2 pixelatedUV = floor(uv * resolution / pixelSize) * pixelSize / resolution;
            gl_FragColor = texture2D(tDiffuse, pixelatedUV);
        }
    `
};

const MatrixShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to greyscale
            
            // Simple binary look: quantize to black or green
            vec3 finalColor = mix(vec3(0.0), vec3(0.0, 1.0, 0.0), step(0.5, luma));
            
            // Add a subtle grid/dither to suggest binary elements
            float grid = mod(floor(vUv.x * 100.0) + floor(vUv.y * 100.0), 2.0);
            finalColor = mix(finalColor * 0.8, finalColor, grid);

            gl_FragColor = vec4(finalColor, texel.a);
        }
    `
};

const ASCIIShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'resolution': { value: new THREE.Vector2() },
        'pixelSize': { value: 8.0 }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform float pixelSize;
        varying vec2 vUv;
        void main() {
            vec2 uv = vUv;
            vec2 pixelatedUV = floor(uv * resolution / pixelSize) * pixelSize / resolution;
            vec4 texel = texture2D(tDiffuse, pixelatedUV);
            
            // Convert to luminance
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            
            // Quantize luminance to simulate character density
            // Use a few steps to represent different 'characters'
            float step1 = step(0.25, luma); // Darkest areas
            float step2 = step(0.50, luma); // Mid areas
            float step3 = step(0.75, luma); // Brightest areas
            
            vec3 finalColor;
            if (step3 == 1.0) {
                finalColor = vec3(0.0, 1.0, 0.0); // Brightest green
            } else if (step2 == 1.0) {
                finalColor = vec3(0.0, 0.7, 0.0); // Medium green
            } else if (step1 == 1.0) {
                finalColor = vec3(0.0, 0.4, 0.0); // Dark green
            } else {
                finalColor = vec3(0.0);
            }
            
            gl_FragColor = vec4(finalColor, texel.a);
        }
    `
};

const XRayShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Grayscale
            float invertedLuma = 1.0 - luma; // Invert grayscale
            vec3 xrayColor = vec3(0.0, 0.7, 1.0) * invertedLuma; // Apply a blue/cyan tint
            gl_FragColor = vec4(xrayColor, texel.a);
        }
    `
};

const HeatmapShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float threshold;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to luminance

            vec3 color;
            if (luma < 0.2) { // Darkest areas, deep blue
                color = mix(vec3(0.0, 0.0, 0.2), vec3(0.0, 0.0, 0.8), luma / 0.2);
            } else if (luma < 0.4) { // Blue to Cyan
                color = mix(vec3(0.0, 0.0, 0.8), vec3(0.0, 0.8, 0.8), (luma - 0.2) / 0.2);
            } else if (luma < 0.6) { // Cyan to Green
                color = mix(vec3(0.0, 0.8, 0.8), vec3(0.0, 1.0, 0.0), (luma - 0.4) / 0.2);
            } else if (luma < 0.8) { // Green to Yellow
                color = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), (luma - 0.6) / 0.2);
            } else { // Yellow to Red
                color = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), (luma - 0.8) / 0.2);
            }

            gl_FragColor = vec4(color, texel.a);
        }
    `
};

const BloodShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to luminance

            vec3 color;
            if (luma < 0.2) { // Very dark red to black
                color = mix(vec3(0.0, 0.0, 0.0), vec3(0.3, 0.0, 0.0), luma / 0.2);
            } else if (luma < 0.4) { // Deep red to medium red
                color = mix(vec3(0.3, 0.0, 0.0), vec3(0.7, 0.0, 0.0), (luma - 0.2) / 0.2);
            } else if (luma < 0.6) { // Medium red to bright red
                color = mix(vec3(0.7, 0.0, 0.0), vec3(1.0, 0.1, 0.1), (luma - 0.4) / 0.2);
            } else if (luma < 0.8) { // Bright red to orange-red
                color = mix(vec3(1.0, 0.1, 0.1), vec3(1.0, 0.4, 0.0), (luma - 0.6) / 0.2);
            } else { // Orange-red to yellowish-orange
                color = mix(vec3(1.0, 0.4, 0.0), vec3(1.0, 0.7, 0.2), (luma - 0.8) / 0.2);
            }

            gl_FragColor = vec4(color, texel.a);
        }
    `
};

const CCTVFeedShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'time': { value: 0.0 },
        'resolution': { value: new THREE.Vector2() }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform vec2 resolution;
        varying vec2 vUv;

        float rand(vec2 co) {
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        void main() {
            vec2 uv = vUv;
            vec2 pixelatedUV = floor(uv * resolution / 16.0) * 16.0 / resolution; // Blocky effect

            // Glitch effect: random horizontal displacement and color channel split
            float randomVal = rand(floor(uv * 100.0) + fract(time * 0.1));
            float displacement = (randomVal - 0.5) * 0.05 * sin(time * 10.0 + uv.y * 50.0); // Oscillating displacement

            vec4 colorR = texture2D(tDiffuse, pixelatedUV + vec2(displacement, 0.0));
            vec4 colorG = texture2D(tDiffuse, pixelatedUV);
            vec4 colorB = texture2D(tDiffuse, pixelatedUV - vec2(displacement, 0.0));

            vec4 glitchedColor = vec4(colorR.r, colorG.g, colorB.b, 1.0);

            // Convert glitched color to luminance
            float lumaGlitched = dot(glitchedColor.rgb, vec3(0.299, 0.587, 0.114));
            
            // Apply a slight green tint
            vec3 tintedColor = mix(vec3(lumaGlitched), vec3(0.0, 0.5, 0.0), 0.3);

            // Add scanlines
            float scanline = sin(uv.y * resolution.y * 0.5) * 0.05 + 0.95; // Subtle scanlines
            tintedColor *= scanline;

            // Add subtle noise/static
            float noise = rand(uv + time * 0.01) * 0.1; // Small amount of noise
            tintedColor += noise;

            gl_FragColor = vec4(tintedColor, glitchedColor.a);
        }
    `
};

// UI controls state
const effectControls = {
    greyscale: false,
    threshold: false,
    thresholdValue: 0.4, // Decreased by 20% (0.5 * 0.8 = 0.4)
    shadow: false, // Renamed from 'dark' to 'shadow'
    pixelation: false,
    pixelSize: 8.0,
    glitch: false,
    matrix: false,
    ascii: false,
    xray: false,
    yRotation: false,
    cameraAnimation: false,
    redacted: false,
    redactedGlitch: false,
    heatmap: false,
    blood: false, // New control for BLOOD effect
    cctvFeed: false,
    marqueeText: false,
    biometricMarquee: false, // New control for biometric marquee
    anon: false, // New control for ANON effect
    og: false, // New control for OG effect
    bloodText: false, // New control for blood text
    hacker: false, // New control for HACKER effect
    surveillance: false, // New control for SURVEILLANCE effect
    greed: false // New control for GREED effect
};

let greyscalePass, thresholdPass, darkPass, pixelationPass, glitchPass, matrixPass, asciiPass, xrayPass, heatmapPass, bloodPass, cctvFeedPass;

let trashButtonElement = null; // Global reference for the trash button UI element
let exportButtonElement = null; // Global reference for the export button UI element
let leftUiContainer = null; // Global reference for the left UI container
let arrowContainer = null; // Global reference for the arrow container

// Array to store initial configurations of assets for reloading
const initialAssetConfigs = [];

// Helper function to update UI button state
const updateUIButtonState = (effectName, isActive) => {
    // Select all buttons with the given data-effect attribute
    const buttons = document.querySelectorAll(`button[data-effect="${effectName}"]`);
    buttons.forEach(button => {
        button.style.borderColor = isActive ? '#4CAF50' : 'white';
    });
};

// Function to apply texture best practices
function applyTextureSettings(texture, renderer) {
    texture.colorSpace = THREE.SRGBColorSpace;
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = false;
    if (renderer) {
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    }
}

function createTextTexture(text, fontSize = 60, color = 'white', backgroundColor = 'rgba(0,0,0,0.5)', font = 'monospace') {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    context.font = `${fontSize}px ${font}`;
    const metrics = context.measureText(text);
    const textWidth = metrics.width;
    const textHeight = fontSize * 1.2; // Approximate height including line spacing

    canvas.width = textWidth + 20; // Add some padding
    canvas.height = textHeight + 20;

    context.font = `${fontSize}px ${font}`;
    context.fillStyle = backgroundColor;
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = color;
    context.fillText(text, 10, fontSize + 10); // Position text with padding

    const texture = new THREE.CanvasTexture(canvas);
    applyTextureSettings(texture, renderer); // Apply settings to CanvasTexture
    texture.needsUpdate = true;
    return texture;
}

function createMarqueeTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    // Canvas size: large enough to hold multiple repetitions of lines for seamless scrolling
    // Width should be enough for the longest phrase
    let maxWidth = 0;
    context.font = `bold 108px 'Courier New', monospace`; // Increased font size and ASCII style font, now bold
    MARQUEE_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    canvas.width = maxWidth + 50; // Add padding
    canvas.height = MARQUEE_LINE_HEIGHT * (MARQUEE_TOTAL_LINES * 2); // Double the height to allow seamless scrolling

    marqueeTexture = new THREE.CanvasTexture(canvas);
    applyTextureSettings(marqueeTexture, renderer); // Apply settings to CanvasTexture
    marqueeTexture.wrapS = THREE.RepeatWrapping;
    marqueeTexture.wrapT = THREE.RepeatWrapping;
    marqueeTexture.needsUpdate = true;
    return marqueeTexture;
}

function updateMarqueeTexture() {
    if (!marqueeTexture) return;

    const canvas = marqueeTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'rgba(0, 0, 0, 0.0)'; // Transparent background
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `bold 108px 'Courier New', monospace`; // Increased font size and ASCII style font, now bold
    context.fillStyle = 'rgba(255, 255, 255, 0.05)'; // Very faint white text
    context.textAlign = 'center';

    // Calculate the total height of one set of lines
    const singleSetHeight = MARQUEE_LINE_HEIGHT * MARQUEE_TOTAL_LINES;

    // Draw lines, repeating them to create a seamless loop
    for (let i = 0; i < MARQUEE_TOTAL_LINES * 2; i++) { // Draw two sets of lines
        const phraseIndex = i % MARQUEE_PHRASES.length;
        const line = MARQUEE_PHRASES[phraseIndex];

        let yPos = (i * MARQUEE_LINE_HEIGHT) + marqueeScrollOffset;

        // Loop the text when it scrolls off the top
        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 2; // Move it to the bottom of the second set
        }

        context.fillText(line, canvas.width / 2, yPos);
    }

    marqueeTexture.needsUpdate = true;
}

function createBiometricMarqueeTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    let maxWidth = 0;
    // Set a fixed width for the canvas to accommodate graphs/waves
    canvas.width = 1200; // Increased width

    context.font = `bold 36px 'Courier New', monospace`; // Smaller font for biometric data (72 / 2 = 36)
    BIOMETRIC_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    // Ensure canvas width is at least maxWidth + padding, but also allow for fixed size
    canvas.width = Math.max(canvas.width, maxWidth + 50);
    canvas.height = BIOMETRIC_MARQUEE_LINE_HEIGHT * (BIOMETRIC_MARQUEE_TOTAL_LINES * 2);

    biometricMarqueeTexture = new THREE.CanvasTexture(canvas);
    applyTextureSettings(biometricMarqueeTexture, renderer); // Apply settings to CanvasTexture
    biometricMarqueeTexture.wrapS = THREE.RepeatWrapping;
    biometricMarqueeTexture.wrapT = THREE.RepeatWrapping;
    biometricMarqueeTexture.needsUpdate = true;
    return biometricMarqueeTexture;
}

function updateBiometricMarqueeTexture(currentTime) {
    if (!biometricMarqueeTexture) return;

    const canvas = biometricMarqueeTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'rgba(0, 0, 0, 0.0)'; // Transparent background
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `bold 36px 'Courier New', monospace`; // Smaller font for biometric data
    context.textAlign = 'center';

    const singleSetHeight = BIOMETRIC_MARQUEE_LINE_HEIGHT * BIOMETRIC_MARQUEE_TOTAL_LINES;

    // Update biometric animation states (slowed down)
    biometricAnimationState.sinePhase += 0.00125; // Reduced from 0.0025 by 200%
    if (biometricAnimationState.sinePhase > Math.PI * 2) biometricAnimationState.sinePhase -= Math.PI * 2;

    const HEARTBEAT_INTERVAL = 6000; // milliseconds (Increased from 3000 by 200%)
    if (currentTime - biometricAnimationState.lastHeartbeatTime > HEARTBEAT_INTERVAL) {
        biometricAnimationState.heartbeatPulse = true;
        biometricAnimationState.lastHeartbeatTime = currentTime;
    } else {
        biometricAnimationState.heartbeatPulse = false;
    }

    // Generate new graph data periodically or on demand
    if (biometricAnimationState.graphData.length === 0 || Math.random() < 0.01) { // Reduced probability to regenerate graph data
        biometricAnimationState.graphData = [];
        for (let j = 0; j < 20; j++) { // Increased number of data points for more detailed graphs
            biometricAnimationState.graphData.push(Math.random());
        }
    }

    for (let i = 0; i < BIOMETRIC_MARQUEE_TOTAL_LINES * 2; i++) {
        const phraseIndex = i % BIOMETRIC_PHRASES.length;
        const line = BIOMETRIC_PHRASES[phraseIndex];

        let yPos = (i * BIOMETRIC_MARQUEE_LINE_HEIGHT) + biometricMarqueeScrollOffset;

        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 2;
        }

        // Draw the full text first
        context.fillStyle = 'rgba(0, 255, 0, 0.1)'; // Faint green text
        context.fillText(line, canvas.width / 2, yPos);

        // Randomly redact parts of the text
        if (Math.random() < 0.6) { // 60% chance to redact a line
            const words = line.split(' ');
            if (words.length > 1) {
                const wordToRedactIndex = Math.floor(Math.random() * words.length);

                const textBeforeRedaction = words.slice(0, wordToRedactIndex).join(' ');
                const redactedWord = words[wordToRedactIndex];

                // Measure text up to the redacted word to get its starting X position
                const totalTextWidth = context.measureText(line).width;
                const startX = (canvas.width / 2) - (totalTextWidth / 2) + context.measureText(textBeforeRedaction).width;

                // Draw a black rectangle over the selected word
                context.fillStyle = 'black'; // Redaction color
                context.fillRect(startX, yPos - BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.7, context.measureText(redactedWord).width, BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.9);
            }
        }

        // Randomly draw animated biometric data (graphs, sine waves, heartbeat)
        if (Math.random() < 0.4) { // Increased chance to draw an animated element on this line
            const animType = Math.floor(Math.random() * 3); // 0: graph, 1: sine, 2: heartbeat
            const animWidth = 200 * 4; // Increased by 400%
            const animHeight = (BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.8) * 4; // Increased by 400%

            // Randomize X position to space graphs more
            const animX = (canvas.width * 0.05) + (Math.random() * (canvas.width * 0.8 - animWidth));

            // Randomize Y position to place graphs on different levels
            const animY = yPos - (animHeight / 2) + (Math.random() - 0.5) * BIOMETRIC_MARQUEE_LINE_HEIGHT * 1.5;

            context.save();
            context.beginPath();
            context.rect(animX, animY, animWidth, animHeight);
            context.clip(); // Clip drawing to this rectangle

            if (animType === 0) { // Graph
                context.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White color, slightly more opaque
                context.lineWidth = 3; // Thicker lines
                context.moveTo(animX, animY + animHeight); // Start at bottom left
                for (let j = 0; j < biometricAnimationState.graphData.length; j++) {
                    const x = animX + (j / (biometricAnimationState.graphData.length - 1)) * animWidth;
                    const y = animY + animHeight - (biometricAnimationState.graphData[j] * animHeight * (0.8 + 0.2 * Math.sin(currentTime * 0.0005))); // Animated height (speed reduced from 0.001 to 0.0005)
                    context.lineTo(x, y);
                }
                context.stroke();
            } else if (animType === 1) { // Sine Wave
                context.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White color, slightly more opaque
                context.lineWidth = 3; // Thicker lines
                context.moveTo(animX, animY + animHeight / 2 + Math.sin(biometricAnimationState.sinePhase) * animHeight * 0.1); // Initial point with slight offset
                for (let j = 0; j < animWidth; j++) {
                    const x = animX + j;
                    const y = animY + animHeight / 2 + Math.sin((j / animWidth) * Math.PI * 4 + biometricAnimationState.sinePhase) * animHeight * 0.3;
                    context.lineTo(x, y);
                }
                context.stroke();
            } else if (animType === 2) { // Heartbeat
                context.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White color, slightly more opaque
                context.lineWidth = 3; // Thicker lines
                const hbHeight = animHeight * 0.4;
                const hbCenterY = animY + animHeight / 2;

                context.moveTo(animX, hbCenterY);
                context.lineTo(animX + animWidth * 0.1, hbCenterY);
                context.lineTo(animX + animWidth * 0.2, hbCenterY - hbHeight * 0.8); // Q
                context.lineTo(animX + animWidth * 0.25, hbCenterY + hbHeight); // R
                context.lineTo(animX + animWidth * 0.3, hbCenterY - hbHeight * 0.3); // S
                context.lineTo(animX + animWidth * 0.4, hbCenterY); // End of QRS
                context.lineTo(animX + animWidth * 0.6, hbCenterY);
                context.lineTo(animX + animWidth * 0.7, hbCenterY - hbHeight * 0.2); // T wave peak
                context.lineTo(animX + animWidth * 0.8, hbCenterY);
                context.lineTo(animX + animWidth, hbCenterY);
                context.stroke();

                if (biometricAnimationState.heartbeatPulse) {
                    context.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    context.fillRect(animX, animY, animWidth, animHeight);
                }
            }
            context.restore();
        }

        // Add diagnostic text captions in black boxes
        if (Math.random() < 0.3) { // 30% chance to add a diagnostic caption
            const caption = DIAGNOSTIC_CAPTIONS[Math.floor(Math.random() * DIAGNOSTIC_CAPTIONS.length)];
            context.font = `bold 24px 'Courier New', monospace`; // Smaller font for captions (48 / 2 = 24)
            context.textAlign = 'left';
            const captionWidth = context.measureText(caption).width;
            const captionHeight = 24 * 1.2; // Approximate height

            // Position the caption randomly over the line, ensuring it's within bounds
            const captionX = (canvas.width * 0.1) + (Math.random() * (canvas.width * 0.7 - captionWidth));
            const captionY = yPos - (captionHeight / 2) + (Math.random() - 0.5) * (BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.5);

            const padding = 5; // Define padding here
            // Draw black box
            context.fillStyle = 'black';
            context.fillRect(captionX - padding, captionY - captionHeight * 0.7, captionWidth + padding * 2, captionHeight + padding);

            // Draw white text
            context.fillStyle = 'white';
            context.fillText(caption, captionX, captionY);
        }
    }

    biometricMarqueeTexture.needsUpdate = true;
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function createBloodTextTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    let maxWidth = 0;
    context.font = `bold ${BLOOD_TEXT_FONT_SIZE}px 'Impact', sans-serif`;
    BLOOD_TEXT_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    canvas.width = maxWidth + 100; // Add padding
    canvas.height = BLOOD_TEXT_LINE_HEIGHT * (BLOOD_TEXT_TOTAL_LINES * 2); // Double height for scrolling

    bloodTexture = new THREE.CanvasTexture(canvas);
    applyTextureSettings(bloodTexture, renderer); // Apply settings to CanvasTexture
    bloodTexture.wrapS = THREE.RepeatWrapping;
    bloodTexture.wrapT = THREE.RepeatWrapping;
    bloodTexture.needsUpdate = true;
    return bloodTexture;
}

function updateBloodTextTexture() {
    if (!bloodTexture) return;

    const canvas = bloodTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'rgba(0, 0, 0, 0.0)'; // Transparent background
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `bold ${BLOOD_TEXT_FONT_SIZE}px 'Impact', sans-serif`;
    context.fillStyle = 'white'; // White text for contrast
    context.textAlign = 'center';

    const singleSetHeight = BLOOD_TEXT_LINE_HEIGHT * BLOOD_TEXT_TOTAL_LINES;

    // Draw lines, repeating them to create a seamless loop
    for (let i = 0; i < BLOOD_TEXT_TOTAL_LINES * 2; i++) { // Draw two sets of lines
        const phraseIndex = i % shuffledBloodPhrases.length;
        const line = shuffledBloodPhrases[phraseIndex];

        let yPos = (i * BLOOD_TEXT_LINE_HEIGHT) + bloodScrollOffset;

        // When the first set of phrases has scrolled completely off the top of the canvas,
        // wrap it around to the bottom, effectively creating a continuous loop.
        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 3; // Move it to the bottom of the second set
            shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]); // Reshuffle phrases on loop
        }

        context.fillText(line, canvas.width / 2, yPos);
    }

    bloodTexture.needsUpdate = true;
}

function createRedactedGlitchTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    let maxWidth = 0;
    context.font = `${REDACTED_GLITCH_FONT_SIZE}px 'Courier New', monospace`;
    REDACTED_GLITCH_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    canvas.width = maxWidth + 50; // Add padding
    canvas.height = REDACTED_GLITCH_LINE_HEIGHT * (REDACTED_GLITCH_TOTAL_LINES * 2); // Double for seamless scrolling

    redactedGlitchTexture = new THREE.CanvasTexture(canvas);
    applyTextureSettings(redactedGlitchTexture, renderer); // Apply settings to CanvasTexture
    redactedGlitchTexture.wrapS = THREE.RepeatWrapping;
    redactedGlitchTexture.wrapT = THREE.RepeatWrapping;
    redactedGlitchTexture.needsUpdate = true;
    return redactedGlitchTexture;
}

function updateRedactedGlitchTexture() {
    if (!redactedGlitchTexture) return;

    const canvas = redactedGlitchTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'rgba(255, 255, 255, 1.0)'; // White background for threshold effect
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `${REDACTED_GLITCH_FONT_SIZE}px 'Courier New', monospace`;
    context.textAlign = 'left';

    const singleSetHeight = REDACTED_GLITCH_LINE_HEIGHT * REDACTED_GLITCH_TOTAL_LINES;

    for (let i = 0; i < REDACTED_GLITCH_TOTAL_LINES * 2; i++) {
        const phraseDataIndex = i % redactedGlitchPhraseData.length; // Use the new data structure
        const phraseData = redactedGlitchPhraseData[phraseDataIndex];
        const line = phraseData.text;
        const redactedWordIndices = phraseData.redactedWordIndices;

        let yPos = (i * REDACTED_GLITCH_LINE_HEIGHT) + redactedGlitchScrollOffset;

        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 2;
        }

        // Draw text in black so it becomes white/visible with threshold effect
        context.fillStyle = 'black';
        context.fillText(line, 10, yPos + REDACTED_GLITCH_FONT_SIZE); // Add padding

        // Draw redaction bars (white rectangles on white background will appear black with threshold)
        if (redactedWordIndices.length > 0) {
            const words = line.split(/(\s+)/); // Split by one or more spaces, keeping spaces
            let currentX = 10; // Start X for text (accounting for padding)

            for (let j = 0; j < words.length; j++) {
                const word = words[j];
                const wordWidth = context.measureText(word).width;

                if (!/\s+/.test(word) && redactedWordIndices.includes(j)) { // If it's a word and flagged for redaction
                    // Draw a black rectangle over the selected words (will appear white with threshold)
                    context.fillStyle = 'black';
                    context.fillRect(currentX, yPos + REDACTED_GLITCH_FONT_SIZE * 0.2, wordWidth, REDACTED_GLITCH_FONT_SIZE * 0.9);

                    // Optionally draw a border around the redacted area to make it more pronounced
                    context.strokeStyle = 'black'; // Black border (will be white with threshold)
                    context.lineWidth = 2;
                    context.strokeRect(currentX, yPos + REDACTED_GLITCH_FONT_SIZE * 0.2, wordWidth, REDACTED_GLITCH_FONT_SIZE * 0.9);
                }
                currentX += wordWidth;
            }
        }
    }

    redactedGlitchTexture.needsUpdate = true;
}

function stopCameraAnimationAndReset() {
    if (cameraAnimationActive || effectControls.yRotation) {
        cameraAnimationActive = false;
        effectControls.cameraAnimation = false;
        effectControls.yRotation = false;

        updateUIButtonState('cameraAnimation', false);
        updateUIButtonState('yRotation', false);

        camera.position.copy(initialGlobalCameraPos);
        controls.target.copy(initialGlobalCameraLookAt);
        camera.lookAt(controls.target);
        controls.enabled = true; // Re-enable orbit controls
        controls.update(); // Ensure controls are updated after manual camera set

        cameraAnimationState = 'idle';
        assetsVisitedCount = 0;
    }
    yRotationStartTime = 0; // Reset Y-rotation auto-start timer on interaction
}

/**
 * Checks if any visual effect is currently active (excluding camera/rotation controls).
 * @returns {boolean} True if any visual effect is active.
 */
function isAnyVisualEffectActive() {
    for (const key in effectControls) {
        if (effectControls.hasOwnProperty(key)) {
            // Exclude camera/rotation and pure text visibility flags
            if (key !== 'yRotation' && key !== 'cameraAnimation' && key !== 'marqueeText' && key !== 'biometricMarquee' && key !== 'bloodText' && key !== 'hacker' && key !== 'surveillance' && key !== 'greed' && effectControls[key]) {
                return true;
            }
            // Include combined effects if they are active
            if ((key === 'hacker' || key === 'og' || key === 'surveillance' || key === 'greed' || key === 'anon') && effectControls[key]) {
                return true;
            }
        }
    }
    return false;
}

/**
 * Switches the material of face parts between the default MeshBasicMaterial and the
 * LuminanceBoostShader based on whether any visual effect is active.
 */
function updateFaceMaterialState() {
    const shouldBoost = isAnyVisualEffectActive();

    scene.traverse(object => {
        if (object.isMesh && object.userData.id && FACE_PART_IDS.includes(object.userData.id)) {
            // Ensure originalMaterial and boostedMaterial are stored in userData
            if (!object.userData.originalMaterial || !object.userData.boostedMaterial) {
                console.warn(`Face part ${object.userData.id} is missing material references.`);
                return;
            }

            if (shouldBoost) {
                // If an effect is active, use the boosted material
                object.material = object.userData.boostedMaterial;
            } else {
                // If no effects are active, use the original material
                object.material = object.userData.originalMaterial;
            }
        }
    });
}

function resetPiecesToOriginalPositions() {
    // Remove all current draggable objects and their associated meshes (like redaction rectangles)
    draggableObjects.forEach(object => {
        scene.remove(object);
        if (object.geometry) object.geometry.dispose();
        // Dispose of materials, including the custom boosted material if it exists
        if (object.material) {
            if (Array.isArray(object.material)) {
                object.material.forEach(m => m.dispose());
            } else {
                object.material.dispose();
            }
        }
        // Also dispose of stored materials if they were created per mesh
        if (object.userData.originalMaterial) object.userData.originalMaterial.dispose();
        if (object.userData.boostedMaterial) object.userData.boostedMaterial.dispose();
    });
    draggableObjects = []; // Clear the array
    cameraAnimationTargets = []; // Clear camera animation targets

    // Reset specific global references
    rightEyeMesh = null;
    leftEyeMesh = null;
    if (rightEyeRedactionRect) { scene.remove(rightEyeRedactionRect); rightEyeRedactionRect.geometry.dispose(); rightEyeRedactionRect.material.dispose(); rightEyeRedactionRect = null; }
    if (leftEyeRedactionRect) { scene.remove(leftEyeRedactionRect); leftEyeRedactionRect.geometry.dispose(); leftEyeRedactionRect.material.dispose(); leftEyeRedactionRect = null; }

    // Remove existing text meshes before re-adding to avoid duplicates and ensure clean state
    if (marqueeTextMesh) { scene.remove(marqueeTextMesh); marqueeTextMesh.geometry.dispose(); marqueeTextMesh.material.dispose(); marqueeTextMesh = null; }
    if (biometricMarqueeTextMesh) { scene.remove(biometricMarqueeTextMesh); biometricMarqueeTextMesh.geometry.dispose(); biometricMarqueeTextMesh.material.dispose(); biometricMarqueeTextMesh = null; }
    if (bloodTextMesh) { scene.remove(bloodTextMesh); bloodTextMesh.geometry.dispose(); bloodTextMesh.material.dispose(); bloodTextMesh = null; }
    if (redactedGlitchTextMesh) { scene.remove(redactedGlitchTextMesh); redactedGlitchTextMesh.geometry.dispose(); redactedGlitchTextMesh.material.dispose(); redactedGlitchTextMesh = null; }

    // Clear droneMeshes array and remove all drones
    droneMeshes.forEach(drone => {
        scene.remove(drone);
        if (drone.geometry) drone.geometry.dispose();
        if (drone.material) drone.material.dispose();
        // Also dispose of stored materials if they were created per mesh
        if (drone.userData.originalTexture) drone.userData.originalTexture.dispose();
    });
    droneMeshes = [];

    // Turn off all effects on RESET (before re-adding assets)
    turnOffAllEffects();

    // Re-add all assets from their initial configurations
    initialAssetConfigs.forEach(config => {
        // Reset the 'removed' flag for all assets
        config.removed = false;

        const textureLoader = new THREE.TextureLoader();
        let geometry, mesh;

        switch (config.type) {
            case 'image':
                // Only re-add if not a signature image or if it's the *first* signature image
                if (config.id === 'signature') {
                    // Count existing signature images in the scene
                    const existingSignatures = scene.children.filter(child => child.userData.id === 'signature');
                    if (existingSignatures.length >= 1) {
                        // If one signature already exists, skip adding another one
                        return;
                    }
                }
                // Skip adding removed assets
                if (config.removed) return;

                // Filter out 'samAltmanGrid' images during reset
                if (config.id.startsWith('samAltmanGrid')) return;
                if (config.id.startsWith('samAltmanGridBack')) return;
                if (config.id.startsWith('samAltmanGridFarBack')) return;

                textureLoader.load(config.url, (texture) => {
                    // APPLY TEXTURE SETTINGS
                    applyTextureSettings(texture, renderer);

                    let currentMaterial;
                    let textureToUse = texture;
                    
                    // Determine the correct texture to use for the drone on reset
                    if (config.id.startsWith('drone')) {
                        // Check the stored currentTextureUrl to determine which texture to use
                        if (config.currentTextureUrl === URL_BLUE_ORIGIN) {
                            textureToUse = blueOriginTexture; 
                        } else {
                            // If it's the original drone URL, use the loaded texture (which is the original one)
                            textureToUse = texture;
                        }
                    }

                    // For images loaded from initialAssetConfigs, use the stored initialScale if available
                    let initialPlaneWidth = config.initialScale.width;
                    let initialPlaneHeight = config.initialScale.height;

                    // If it's a drone and the texture is the blue origin GIF, recalculate the width based on the GIF's aspect ratio
                    if (config.id.startsWith('drone') && textureToUse === blueOriginTexture) {
                        // Maintain the original height of the drone plane (stored in initialScale.height)
                        const newAspectRatio = blueOriginTexture.image.width / blueOriginTexture.image.height;
                        initialPlaneWidth = initialPlaneHeight * newAspectRatio;
                    }
                    
                    // --- NEW MATERIAL LOGIC ---
                    const originalMaterial = new THREE.MeshBasicMaterial({ map: textureToUse, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                    
                    let meshMaterial = originalMaterial;
                    let boostedMaterial = null;

                    if (FACE_PART_IDS.includes(config.id)) {
                        // Create a unique boosted material for face parts if not already created globally
                        boostedMaterial = new THREE.ShaderMaterial({
                            uniforms: { ...LuminanceBoostShader.uniforms, tDiffuse: { value: textureToUse } },
                            vertexShader: LuminanceBoostShader.vertexShader,
                            fragmentShader: LuminanceBoostShader.fragmentShader,
                            transparent: true,
                            side: THREE.DoubleSide,
                            alphaTest: 0.5
                        });
                        // Set initial material based on current effect state (which is none on reset)
                        meshMaterial = originalMaterial;
                    } else {
                        meshMaterial = originalMaterial;
                    }
                    // --- END NEW MATERIAL LOGIC ---

                    geometry = new THREE.PlaneGeometry(initialPlaneWidth, initialPlaneHeight); // Use calculated or stored initial dimensions
                    mesh = new THREE.Mesh(geometry, meshMaterial);
                    mesh.position.copy(config.initialPosition); // Use the stored initialPosition directly
                    mesh.rotation.copy(config.initialRotation ? new THREE.Euler().copy(config.initialRotation) : new THREE.Euler()); // Apply initial rotation if present
                    mesh.userData.currentLayer = config.initialLayer;
                    mesh.userData.initialPosition = config.initialPosition.clone(); // Clone for userData as well
                    mesh.userData.initialLayer = config.initialLayer;
                    mesh.userData.id = config.id;
                    mesh.userData.initialScale = { width: config.initialScale.width, height: config.initialScale.height }; // Store original scale
                    
                    // Store material references
                    if (FACE_PART_IDS.includes(config.id)) {
                        mesh.userData.originalMaterial = originalMaterial;
                        mesh.userData.boostedMaterial = boostedMaterial;
                    }
                    
                    if (config.id.startsWith('drone')) {
                        // Restore drone-specific data
                        mesh.userData.droneInitialY = mesh.position.y; // Store initial Y for hovering animation
                        mesh.userData.droneHoverPhase = config.droneHoverPhase; // Restore unique hover phase
                        mesh.userData.droneInitialX = mesh.position.x; // Restore initial X for hovering animation
                        mesh.userData.droneHoverAmplitude = config.droneHoverAmplitude; // Restore unique amplitude
                        mesh.userData.droneHoverSpeed = config.droneHoverSpeed; // Restore unique speed
                        // The original texture is the one loaded by the callback, which is 'texture' here if URL_DRONE was used.
                        mesh.userData.originalTexture = texture; 
                        mesh.userData.currentTexture = textureToUse; // Store current texture
                        scene.add(mesh);
                        draggableObjects.push(mesh);
                        cameraAnimationTargets.push(mesh);
                        droneMeshes.push(mesh);
                    } else if (config.id !== 'signature') { // Signature is static, add directly to scene without making draggable
                        scene.add(mesh);
                        draggableObjects.push(mesh);
                        cameraAnimationTargets.push(mesh);
                    } else {
                        scene.add(mesh);
                    }

                    if (config.id === 'rightEye') {
                        rightEyeMesh = mesh;
                        const redactionWidth = initialPlaneWidth * 1.2;
                        const redactionHeight = initialPlaneHeight * 0.5;
                        const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
                        const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                        rightEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
                        rightEyeRedactionRect.position.set(mesh.position.x, mesh.position.y, mesh.position.z + (1.5 * depthStep));
                        rightEyeRedactionRect.visible = false;
                        scene.add(rightEyeRedactionRect);
                    } else if (config.id === 'leftEye') {
                        leftEyeMesh = mesh;
                        const redactionWidth = initialPlaneWidth * 1.2;
                        const redactionHeight = initialPlaneHeight * 0.5;
                        const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
                        const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                        leftEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
                        leftEyeRedactionRect.position.set(mesh.position.x, mesh.position.y, mesh.position.z + (1.5 * depthStep));
                        leftEyeRedactionRect.visible = false;
                        scene.add(leftEyeRedactionRect);
                    }
                });
                break;
            case 'textMesh':
                // Re-initialize 3D text meshes (Marquee, Biometric, Blood, Redacted Glitch)
                if (config.id === 'marqueeTextMesh') {
                    // Re-create the mesh, as it was disposed earlier
                    marqueeTexture = createMarqueeTexture(); // Settings applied inside this function
                    const newMarqueeMaterial = new THREE.MeshBasicMaterial({ map: marqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const newMarqueePlaneWidth = 20;
                    const newMarqueePlaneHeight = newMarqueePlaneWidth / (marqueeTexture.image.width / marqueeTexture.image.height);
                    const newMarqueeGeometry = new THREE.PlaneGeometry(newMarqueePlaneWidth, newMarqueePlaneHeight);

                    marqueeTextMesh = new THREE.Mesh(newMarqueeGeometry, newMarqueeMaterial);
                    marqueeTextMesh.position.copy(config.initialPosition); // Use the stored initialPosition directly
                    marqueeTextMesh.userData.initialPosition = marqueeTextMesh.position.clone(); // Clone for userData as well
                    marqueeTextMesh.userData.initialLayer = config.initialLayer;
                    marqueeTextMesh.visible = effectControls.xray; // Tied to XRAY effect
                    scene.add(marqueeTextMesh);
                } else if (config.id === 'biometricMarqueeTextMesh') {
                    // Re-create the mesh, as it was disposed earlier
                    biometricMarqueeTexture = createBiometricMarqueeTexture(); // Settings applied inside this function
                    const newBiometricMarqueeMaterial = new THREE.MeshBasicMaterial({ map: biometricMarqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const newBiometricMarqueePlaneWidth = 20;
                    const newBiometricMarqueePlaneHeight = newBiometricMarqueePlaneWidth / (biometricMarqueeTexture.image.width / biometricMarqueeTexture.image.height);
                    const newBiometricMarqueeGeometry = new THREE.PlaneGeometry(newBiometricMarqueePlaneWidth, newBiometricMarqueePlaneHeight);

                    biometricMarqueeTextMesh = new THREE.Mesh(newBiometricMarqueeGeometry, newBiometricMarqueeMaterial);
                    biometricMarqueeTextMesh.position.copy(config.initialPosition); // Use the stored initialPosition directly
                    biometricMarqueeTextMesh.userData.initialPosition = biometricMarqueeTextMesh.position.clone(); // Clone for userData as well
                    biometricMarqueeTextMesh.userData.initialLayer = config.initialLayer;
                    biometricMarqueeTextMesh.visible = effectControls.biometricMarquee || effectControls.og || effectControls.hacker || effectControls.surveillance || effectControls.greed; // Visibility depends on multiple effects
                    scene.add(biometricMarqueeTextMesh);
                } else if (config.id === 'bloodTextMesh') {
                    // Re-create the mesh, as it was disposed earlier
                    bloodTexture = createBloodTextTexture(); // Settings applied inside this function
                    const newBloodTextMaterial = new THREE.MeshBasicMaterial({ map: bloodTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const newBloodTextPlaneWidth = 20;
                    const newBloodTextPlaneHeight = newBloodTextPlaneWidth / (bloodTexture.image.width / bloodTexture.image.height);
                    const newBloodTextGeometry = new THREE.PlaneGeometry(newBloodTextPlaneWidth, newBloodTextPlaneHeight);

                    bloodTextMesh = new THREE.Mesh(newBloodTextGeometry, newBloodTextMaterial);
                    bloodTextMesh.position.copy(config.initialPosition); // Use the stored initialPosition directly
                    bloodTextMesh.userData.initialPosition = bloodTextMesh.position.clone();
                    bloodTextMesh.userData.initialLayer = config.initialLayer;
                    // Ensure bloodTextMesh is hidden on reset, as the effectControls are reset before this point
                    bloodTextMesh.visible = false;
                    scene.add(bloodTextMesh);
                } else if (config.id === 'redactedGlitchTextMesh') {
                    // Re-create the mesh, as it was disposed earlier
                    redactedGlitchTexture = createRedactedGlitchTexture(); // Settings applied inside this function
                    const redactedGlitchMaterial = new THREE.MeshBasicMaterial({ map: redactedGlitchTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const redactedGlitchPlaneWidth = 15;
                    const redactedGlitchPlaneHeight = redactedGlitchPlaneWidth / (redactedGlitchTexture.image.width / redactedGlitchTexture.image.height);
                    const newRedactedGlitchGeometry = new THREE.PlaneGeometry(redactedGlitchPlaneWidth, redactedGlitchPlaneHeight);

                    redactedGlitchTextMesh = new THREE.Mesh(newRedactedGlitchGeometry, redactedGlitchMaterial);
                    redactedGlitchTextMesh.position.copy(config.initialPosition); // Use the stored initialPosition directly
                    redactedGlitchTextMesh.userData.initialPosition = redactedGlitchTextMesh.position.clone();
                    redactedGlitchTextMesh.userData.initialLayer = config.initialLayer;
                    redactedGlitchTextMesh.visible = effectControls.redactedGlitch; // Respect current effect control
                    scene.add(redactedGlitchTextMesh);
                    initializeRedactedGlitchPhraseData(); // Re-initialize redaction patterns
                }
                break;
        }
    });

    // Reset camera to initial global position and look-at
    camera.position.copy(initialGlobalCameraPos);
    controls.target.copy(initialGlobalCameraLookAt);
    camera.lookAt(controls.target);
    controls.update(); // Update controls after manual camera change

    // Stop any active camera animations or Y-rotation
    effectControls.cameraAnimation = false;
    effectControls.yRotation = false;
    cameraAnimationActive = false;
    controls.enabled = true; // Re-enable orbit controls
    // Update UI buttons for camera animation and Y-rotation
    updateUIButtonState('yRotation', false);
    updateUIButtonState('cameraAnimation', false);

    // Also disable redacted effects as they are tied to eye positions
    effectControls.redacted = false;
    effectControls.redactedGlitch = false;
    effectControls.anon = false; // Turn off anon effect on reset
    effectControls.hacker = false; // Turn off hacker effect on reset
    effectControls.surveillance = false; // Turn off surveillance effect on reset
    effectControls.greed = false; // Turn off greed effect on reset
    updateUIButtonState('redacted', false);
    updateUIButtonState('redactedGlitch', false);
    updateUIButtonState('anon', false);
    updateUIButtonState('hacker', false);
    updateUIButtonState('surveillance', false);
    updateUIButtonState('greed', false);

    // If threshold was forced on by redacted, turn it off if no other effect is using it.
    if (!effectControls.redacted && !effectControls.redactedGlitch && !effectControls.anon && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
        effectControls.threshold = false;
        thresholdPass.enabled = false;
        updateUIButtonState('threshold', false);
    }
    
    // Crucial: Update face materials to switch back to original (non-boosted) material
    updateFaceMaterialState();

    lastActivityTime = performance.now(); // Reset activity timer on reset
    yRotationStartTime = 0; // Reset Y-rotation auto-start timer on reset
}

function turnOffAllEffects() {
    // Deactivate all post-processing passes
    greyscalePass.enabled = false;
    thresholdPass.enabled = false;
    darkPass.enabled = false;
    pixelationPass.enabled = false;
    glitchPass.enabled = false;
    matrixPass.enabled = false;
    asciiPass.enabled = false;
    xrayPass.enabled = false;
    heatmapPass.enabled = false;
    bloodPass.enabled = false;
    cctvFeedPass.enabled = false;

    // Reset all effect control booleans to false
    for (const prop in effectControls) {
        if (effectControls.hasOwnProperty(prop)) {
            effectControls[prop] = false;
        }
    }

    // Update UI buttons to reflect inactive state
    updateUIButtonState('greyscale', false);
    updateUIButtonState('threshold', false);
    updateUIButtonState('shadow', false); // Updated from 'dark'
    updateUIButtonState('pixelation', false);
    updateUIButtonState('glitch', false);
    updateUIButtonState('matrix', false);
    updateUIButtonState('ascii', false);
    updateUIButtonState('xray', false);
    updateUIButtonState('heatmap', false);
    updateUIButtonState('blood', false);
    updateUIButtonState('cctvFeed', false);
    updateUIButtonState('yRotation', false);
    updateUIButtonState('cameraAnimation', false);
    updateUIButtonState('redacted', false);
    updateUIButtonState('redactedGlitch', false);
    updateUIButtonState('anon', false);
    updateUIButtonState('biometricMarquee', false);
    updateUIButtonState('og', false);
    updateUIButtonState('bloodText', false);
    updateUIButtonState('hacker', false); // Update hacker button state
    updateUIButtonState('surveillance', false); // Update surveillance button state
    updateUIButtonState('greed', false); // Update greed button state

    // Specific effect cleanups
    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false;
    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false;
    if (marqueeTextMesh) marqueeTextMesh.visible = false;
    if (biometricMarqueeTextMesh) biometricMarqueeTextMesh.visible = false;
    if (bloodTextMesh) bloodTextMesh.visible = false;
    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false;
    
    // Crucial: Update face materials to switch back to original (non-boosted) material
    updateFaceMaterialState();

    cameraAnimationActive = false;
    controls.enabled = true; // Re-enable orbit controls
    cameraAnimationState = 'idle';
    assetsVisitedCount = 0;

    lastActivityTime = performance.now(); // Reset activity timer
    yRotationStartTime = 0; // Reset Y-rotation auto-start timer
}

// Cache for canvas contexts to read texture alpha values efficiently
const textureAlphaCanvasCache = new Map();

function getAlphaAtUV(texture, uv) {
    if (!texture || !texture.image || !uv) return 0;

    // Use cached canvas context if available
    let canvas, context;
    if (textureAlphaCanvasCache.has(texture.id)) {
        ({ canvas, context } = textureAlphaCanvasCache.get(texture.id));
    } else {
        canvas = document.createElement('canvas');
        context = canvas.getContext('2d');
        canvas.width = texture.image.width;
        canvas.height = texture.image.height;
        context.drawImage(texture.image, 0, 0);
        textureAlphaCanvasCache.set(texture.id, { canvas, context });
    }

    const x = Math.floor(uv.x * canvas.width);
    const y = Math.floor((1 - uv.y) * canvas.height); // Y-axis needs to be inverted for canvas

    // Ensure coordinates are within bounds
    if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
        return 0;
    }

    const pixelData = context.getImageData(x, y, 1, 1).data;
    return pixelData[3] / 255; // Alpha channel
}

function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 10; // Zoomed out to see the full canvas
    camera.userData.yRotationAngle = 0; // Initialize angle for Y-axis camera rotation

    renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(CLEAR_COLOR); // Use the defined dark gray background color
    renderer.outputColorSpace = THREE.SRGBColorSpace; // Set renderer color space
    document.body.appendChild(renderer.domElement);

    renderer.sortObjects = true; // Enable object sorting for correct transparency rendering

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 20;
    controls.maxPolarAngle = Math.PI / 2;
    controls.addEventListener('change', () => {
        lastActivityTime = performance.now();
        stopCameraAnimationAndReset(); // Stop animation on camera control interaction
    });

    // Store initial global camera position and look-at target
    initialGlobalCameraPos.copy(camera.position);
    initialGlobalCameraLookAt.copy(controls.target);

    // Post-processing setup
    composer = new EffectComposer(renderer);
    // Ensure the RenderPass is the first pass so the clear color is captured
    composer.addPass(new RenderPass(scene, camera));

    greyscalePass = new ShaderPass(GreyScaleShader);
    composer.addPass(greyscalePass);
    greyscalePass.enabled = effectControls.greyscale;

    thresholdPass = new ShaderPass(ThresholdShader);
    thresholdPass.uniforms['threshold'].value = effectControls.thresholdValue;
    thresholdPass.uniforms['clearColor'].value = CLEAR_COLOR; // Ensure clear color is passed
    composer.addPass(thresholdPass);
    thresholdPass.enabled = effectControls.threshold;

    darkPass = new ShaderPass(DarkShader);
    darkPass.uniforms['threshold'].value = effectControls.thresholdValue;
    darkPass.uniforms['clearColor'].value = CLEAR_COLOR; // Ensure clear color is passed
    composer.addPass(darkPass);
    darkPass.enabled = effectControls.shadow;

    pixelationPass = new ShaderPass(PixelationShader);
    pixelationPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    pixelationPass.uniforms['pixelSize'].value = effectControls.pixelSize;
    composer.addPass(pixelationPass);
    pixelationPass.enabled = effectControls.pixelation;

    glitchPass = new GlitchPass();
    composer.addPass(glitchPass);
    glitchPass.enabled = effectControls.glitch;

    matrixPass = new ShaderPass(MatrixShader);
    composer.addPass(matrixPass);
    matrixPass.enabled = effectControls.matrix;

    asciiPass = new ShaderPass(ASCIIShader);
    asciiPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    asciiPass.uniforms['pixelSize'].value = effectControls.pixelSize;
    composer.addPass(asciiPass);
    asciiPass.enabled = false;

    xrayPass = new ShaderPass(XRayShader);
    composer.addPass(xrayPass);
    xrayPass.enabled = effectControls.xray;

    heatmapPass = new ShaderPass(HeatmapShader);
    composer.addPass(heatmapPass);
    heatmapPass.enabled = effectControls.heatmap;

    bloodPass = new ShaderPass(BloodShader);
    composer.addPass(bloodPass);
    bloodPass.enabled = effectControls.blood;

    cctvFeedPass = new ShaderPass(CCTVFeedShader);
    cctvFeedPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    cctvFeedPass.uniforms['time'].value = 0.0;
    composer.addPass(cctvFeedPass);
    cctvFeedPass.enabled = effectControls.cctvFeed;

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    const textureLoader = new THREE.TextureLoader();

    // Load the Blue Origin texture once, with best practices for GIF
    blueOriginTexture = textureLoader.load(URL_BLUE_ORIGIN);
    applyTextureSettings(blueOriginTexture, renderer); // Apply settings

    // Base scale factor to make images viewable at a reasonable size
    const baseScale = 0.005;

    // Function to create and add a face part
    const addFacePart = (id, url, initialPosition, initialLayer, scaleFactor = 1, initialRotation = null) => {
        textureLoader.load(url, (texture) => {
            applyTextureSettings(texture, renderer);

            const planeWidth = texture.image.width * baseScale * scaleFactor;
            const planeHeight = texture.image.height * baseScale * scaleFactor;
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            
            // 1. Create the original (unboosted) material
            const originalMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
            
            // 2. Create the boosted material (ShaderMaterial)
            const boostedMaterial = new THREE.ShaderMaterial({
                uniforms: { ...LuminanceBoostShader.uniforms, tDiffuse: { value: texture } },
                vertexShader: LuminanceBoostShader.vertexShader,
                fragmentShader: LuminanceBoostShader.fragmentShader,
                transparent: true,
                side: THREE.DoubleSide,
                alphaTest: 0.5
            });

            const mesh = new THREE.Mesh(geometry, originalMaterial); // Start with original material
            mesh.position.copy(initialPosition);
            if (initialRotation) {
                mesh.rotation.copy(initialRotation);
            }
            mesh.userData.currentLayer = initialLayer;
            mesh.userData.initialPosition = mesh.position.clone();
            mesh.userData.initialLayer = initialLayer;
            mesh.userData.id = id;
            mesh.userData.initialScale = { width: planeWidth, height: planeHeight };
            
            // Store material references in userData
            mesh.userData.originalMaterial = originalMaterial;
            mesh.userData.boostedMaterial = boostedMaterial;

            scene.add(mesh);
            draggableObjects.push(mesh);
            cameraAnimationTargets.push(mesh);

            initialAssetConfigs.push({
                id: id,
                type: 'image',
                url: url,
                initialPosition: initialPosition.clone(),
                initialRotation: initialRotation ? initialRotation.clone() : undefined,
                initialLayer: initialLayer,
                initialScale: { width: planeWidth, height: planeHeight },
                removed: false
            });

            // Special handling for eyes to set up redaction rectangles
            if (id === 'rightEye') {
                rightEyeMesh = mesh;
                const redactionWidth = planeWidth * 1.2;
                const redactionHeight = planeHeight * 0.5;
                const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
                const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                rightEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
                rightEyeRedactionRect.position.set(mesh.position.x, mesh.position.y, mesh.position.z + (1.5 * depthStep));
                rightEyeRedactionRect.visible = false;
                scene.add(rightEyeRedactionRect);
            } else if (id === 'leftEye') {
                leftEyeMesh = mesh;
                const redactionWidth = planeWidth * 1.2;
                const redactionHeight = planeHeight * 0.5;
                const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
                const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                leftEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
                leftEyeRedactionRect.position.set(mesh.position.x, mesh.position.y, mesh.position.z + (1.5 * depthStep));
                leftEyeRedactionRect.visible = false;
                scene.add(leftEyeRedactionRect);
            }
        });
    };

    // Load and add the face images using the new function
    addFacePart('forehead', URL_FOREHEAD, new THREE.Vector3(0, (0.5 + 3.2) * 1.10, (2 - 1) * depthStep), 2, 1);
    addFacePart('rightEye', URL_RIGHT_EYE, new THREE.Vector3(-2 * .7 * 1, (0.175 * 1.15 * 1.20 * 3) + 2.0 - 1.2, (7 - 1) * depthStep), 7, 1);
    addFacePart('mouth', URL_MOUTH, new THREE.Vector3(0, -2.5, (9 - 1) * depthStep), 9, 1);
    
    const earNewLayer = 3;
    const earNewZ = (earNewLayer - 1) * depthStep;
    const distance_from_camera_ear = camera.position.z - earNewZ;
    const world_height_at_ear_z = 2 * distance_from_camera_ear * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
    const world_width_at_ear_z = world_height_at_ear_z * camera.aspect;
    const pixelToUnitFactorX_ear = world_width_at_ear_z / window.innerWidth;
    const moveLeftUnits = 2 * pixelToUnitFactorX_ear;
    const earInitialPosition = new THREE.Vector3(3.1 - moveLeftUnits, 1.25, earNewZ);
    const earInitialRotation = new THREE.Euler(0, THREE.MathUtils.degToRad(45), 0);
    addFacePart('ear', URL_EAR, earInitialPosition, earNewLayer, 1, earInitialRotation);

    addFacePart('leftEye', URL_LEFT_EYE, new THREE.Vector3(1 * 1.2 * 1.2, (0.175 * 1.15 * 1.20 * 3) + 2.0 - 1.3, (9 - 1) * depthStep), 9, 1);
    addFacePart('nose', URL_NOSE, new THREE.Vector3(0, 0.4, (11 - 1) * depthStep), 11, 0.93);


    // Load and add the new Jeff Bezos Label Blue image
    const jeffBezosLabelBlueInitialLayer = 4; // User requested level 4
    const jeffBezosLabelBlueInitialZ = (jeffBezosLabelBlueInitialLayer - 1) * depthStep;
    const jeffBezosLabelBlueInitialPosition = new THREE.Vector3(
        -1.4 - 2.5, // To the left of right eye's initial X (-1.4)
        1.40375 - 0.5, // Slightly below right eye's initial Y (1.40375)
        jeffBezosLabelBlueInitialZ
    );

    textureLoader.load(URL_JEFF_BEZOS_LABEL_BLUE, (texture) => {
        // APPLY TEXTURE SETTINGS
        applyTextureSettings(texture, renderer);

        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const planeWidth = texture.image.width * baseScale; 
        const planeHeight = texture.image.height * baseScale; 
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const jeffBezosLabelBlue = new THREE.Mesh(geometry, material);
        jeffBezosLabelBlue.position.copy(jeffBezosLabelBlueInitialPosition);
        jeffBezosLabelBlue.userData.currentLayer = jeffBezosLabelBlueInitialLayer;
        jeffBezosLabelBlue.userData.initialPosition = jeffBezosLabelBlue.position.clone();
        jeffBezosLabelBlue.userData.initialLayer = jeffBezosLabelBlueInitialLayer;
        jeffBezosLabelBlue.userData.id = 'jeffBezosLabelBlue'; // Added ID
        jeffBezosLabelBlue.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(jeffBezosLabelBlue);
        draggableObjects.push(jeffBezosLabelBlue);
        cameraAnimationTargets.push(jeffBezosLabelBlue);

        initialAssetConfigs.push({
            id: 'jeffBezosLabelBlue',
            type: 'image',
            url: URL_JEFF_BEZOS_LABEL_BLUE,
            initialPosition: jeffBezosLabelBlueInitialPosition.clone(),
            initialLayer: jeffBezosLabelBlueInitialLayer,
            initialScale: { width: planeWidth, height: planeHeight },
            removed: false
        });
    });

    // Load and add the new Jeff Bezos Label Orange image
    const jeffBezosLabelOrangeInitialLayer = 6; // User requested level 12
    const jeffBezosLabelOrangeInitialZ = (jeffBezosLabelOrangeInitialLayer - 1) * depthStep;
    const jeffBezosLabelOrangeInitialPosition = new THREE.Vector3(
        -2, // Centered where mouth is
        -.2, // Same Y as mouth
        jeffBezosLabelOrangeInitialZ
    );

    textureLoader.load(URL_JEFF_BEZOS_LABEL_ORANGE, (texture) => {
        // APPLY TEXTURE SETTINGS
        applyTextureSettings(texture, renderer);

        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const planeWidth = texture.image.width * baseScale; 
        const planeHeight = texture.image.height * baseScale; 
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const jeffBezosLabelOrange = new THREE.Mesh(geometry, material);
        jeffBezosLabelOrange.position.copy(jeffBezosLabelOrangeInitialPosition);
        jeffBezosLabelOrange.userData.currentLayer = jeffBezosLabelOrangeInitialLayer;
        jeffBezosLabelOrange.userData.initialPosition = jeffBezosLabelOrange.position.clone();
        jeffBezosLabelOrange.userData.initialLayer = jeffBezosLabelOrangeInitialLayer;
        jeffBezosLabelOrange.userData.id = 'jeffBezosLabelOrange'; // Added ID
        jeffBezosLabelOrange.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(jeffBezosLabelOrange);
        draggableObjects.push(jeffBezosLabelOrange);
        cameraAnimationTargets.push(jeffBezosLabelOrange);

        initialAssetConfigs.push({
            id: 'jeffBezosLabelOrange',
            type: 'image',
            url: URL_JEFF_BEZOS_LABEL_ORANGE,
            initialPosition: jeffBezosLabelOrangeInitialPosition.clone(),
            initialLayer: jeffBezosLabelOrangeInitialLayer,
            initialScale: { width: planeWidth, height: planeHeight },
            removed: false
        });
    });

    // Load and add the new Jeff Bezos Label Black image
    const jeffBezosLabelBlackInitialLayer = 6.5; // User requested level 7
    const jeffBezosLabelBlackInitialZ = (jeffBezosLabelBlackInitialLayer - 1) * depthStep;
    const jeffBezosLabelBlackInitialPosition = new THREE.Vector3(
        1.44 + 0.5, // Right next to left eye's X (1.44)
        1.3, // Similar Y to left eye
        jeffBezosLabelBlackInitialZ
    );

    textureLoader.load(URL_JEFF_BEZOS_LABEL_BLACK, (texture) => {
        // APPLY TEXTURE SETTINGS
        applyTextureSettings(texture, renderer);

        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const planeWidth = texture.image.width * baseScale;
        const planeHeight = texture.image.height * baseScale;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const jeffBezosLabelBlack = new THREE.Mesh(geometry, material);
        jeffBezosLabelBlack.position.copy(jeffBezosLabelBlackInitialPosition);
        jeffBezosLabelBlack.userData.currentLayer = jeffBezosLabelBlackInitialLayer;
        jeffBezosLabelBlack.userData.initialPosition = jeffBezosLabelBlack.position.clone();
        jeffBezosLabelBlack.userData.initialLayer = jeffBezosLabelBlackInitialLayer;
        jeffBezosLabelBlack.userData.id = 'jeffBezosLabelBlack'; // Added ID
        jeffBezosLabelBlack.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(jeffBezosLabelBlack);
        draggableObjects.push(jeffBezosLabelBlack);
        cameraAnimationTargets.push(jeffBezosLabelBlack);

        initialAssetConfigs.push({
            id: 'jeffBezosLabelBlack',
            type: 'image',
            url: URL_JEFF_BEZOS_LABEL_BLACK,
            initialPosition: jeffBezosLabelBlackInitialPosition.clone(),
            initialLayer: jeffBezosLabelBlackInitialLayer,
            initialScale: { width: planeWidth, height: planeHeight },
            removed: false
        });
    });

            // Load and add the signature image
            const signatureNewLayer = 2 - 2; // 2 levels behind where rocket was (rocket was layer 2) -> layer 0
            const signatureNewZ = (signatureNewLayer - 1) * depthStep; // (0 - 1) * 0.2 = -0.2
            const signatureNewX = -2.0; // Moved to the right from -2.5
            const signatureNewY = -4.7; // Same Y as where fiatWorthless was
            const signatureInitialPosition = new THREE.Vector3(signatureNewX, signatureNewY, signatureNewZ);

            textureLoader.load(URL_SIGNATURE, (signatureTexture) => {
                // APPLY TEXTURE SETTINGS
                applyTextureSettings(signatureTexture, renderer);

                const signatureMaterial = new THREE.MeshBasicMaterial({ map: signatureTexture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                const signatureAspectRatio = signatureTexture.image.width / signatureTexture.image.height;
                const signatureHeight = 1.0;
                const signatureWidth = signatureHeight * signatureAspectRatio;
                const signatureGeometry = new THREE.PlaneGeometry(signatureWidth, signatureHeight);
                const signature = new THREE.Mesh(signatureGeometry, signatureMaterial);

                signature.position.copy(signatureInitialPosition);

                signature.userData.currentLayer = signatureNewLayer;
                signature.userData.id = 'signature'; // Added ID
                signature.userData.initialScale = { width: signatureWidth, height: signatureHeight }; // Store initial scale
                scene.add(signature);
                // Note: signature is NOT added to draggableObjects, making it static and locked.

                initialAssetConfigs.push({
                    id: 'signature',
                    type: 'image',
                    url: URL_SIGNATURE,
                    initialPosition: signatureInitialPosition.clone(),
                    initialLayer: signatureNewLayer,
                    initialScale: { width: signatureWidth, height: signatureHeight },
                    removed: false // Add removed flag
                });
            });

    // Function to add a single drone
    const addDrone = (id, initialLayer, initialX, initialY) => {
        const droneInitialZ = (initialLayer - 1) * depthStep;
        const droneInitialPosition = new THREE.Vector3(initialX, initialY, droneInitialZ);
        
        // Generate a random hover phase for unique movement timing
        const droneHoverPhase = Math.random() * Math.PI * 2; 
        
        // Generate a random hover amplitude and speed for unique movement style
        const droneHoverAmplitude = DRONE_HOVER_AMPLITUDE * (0.5 + Math.random() * 1.5); // 50% to 200% of base amplitude
        const droneHoverSpeed = DRONE_HOVER_SPEED * (0.5 + Math.random() * 1.5); // 50% to 200% of base speed

        textureLoader.load(URL_DRONE, (texture) => {
            // APPLY TEXTURE SETTINGS
            applyTextureSettings(texture, renderer);
            
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
            const planeWidth = texture.image.width * baseScale;
            const planeHeight = texture.image.height * baseScale;
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const drone = new THREE.Mesh(geometry, material);
            drone.position.copy(droneInitialPosition);
            drone.userData.currentLayer = initialLayer;
            drone.userData.initialPosition = drone.position.clone();
            drone.userData.initialLayer = initialLayer;
            drone.userData.id = id;
            // IMPORTANT: Store the initial dimensions based on the original drone texture
            drone.userData.initialScale = { width: planeWidth, height: planeHeight };
            drone.userData.droneInitialY = drone.position.y; // Store initial Y center for hovering animation
            drone.userData.droneHoverPhase = droneHoverPhase; // Store unique hover phase
            drone.userData.droneInitialX = drone.position.x; // Store initial X center for hovering animation
            drone.userData.droneHoverAmplitude = droneHoverAmplitude; // Store unique amplitude
            drone.userData.droneHoverSpeed = droneHoverSpeed; // Store unique speed
            drone.userData.originalTexture = texture; // Store the original drone texture
            drone.userData.currentTexture = texture; // Store the current texture (initially original)
            scene.add(drone);
            draggableObjects.push(drone);
            cameraAnimationTargets.push(drone);
            droneMeshes.push(drone); // Add to the array of drone meshes

            initialAssetConfigs.push({
                id: id,
                type: 'image',
                url: URL_DRONE,
                initialPosition: droneInitialPosition.clone(),
                initialLayer: initialLayer,
                initialScale: { width: planeWidth, height: planeHeight },
                droneHoverPhase: droneHoverPhase, // Store phase for reset
                droneHoverAmplitude: droneHoverAmplitude, // Store amplitude for reset
                droneHoverSpeed: droneHoverSpeed, // Store speed for reset
                currentTextureUrl: URL_DRONE, // Store the URL of the current texture
                removed: false
            });
        });
    };

    // Add the original drone
    addDrone('drone0', 13, 0, 2.5);

    // Add 9 more drones with z-axis levels from -25 to 18
    const minZLevel = -25;
    const maxZLevel = 18;
    const numNewDrones = 5;

    for (let i = 1; i <= numNewDrones; i++) {
        const id = `drone${i}`;
        // Distribute Z levels somewhat evenly
        const currentZLevel = minZLevel + (i / numNewDrones) * (maxZLevel - minZLevel);
        const initialLayer = Math.round(currentZLevel);

        // Random X and Y positions within a reasonable range
        const initialX = (Math.random() * 8) - 4; // From -4 to 4
        const initialY = (Math.random() * 6) - 3; // From -3 to 3

        addDrone(id, initialLayer, initialX, initialY);
    }

    // Initialize the Marquee Text (for XRAY effect)
    marqueeTexture = createMarqueeTexture(); // Settings applied inside this function
    const marqueeMaterial = new THREE.MeshBasicMaterial({ map: marqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    // The plane size should be relative to the background or screen to fill it
    const marqueePlaneWidth = 20;
    const marqueePlaneHeight = marqueePlaneWidth / (marqueeTexture.image.width / marqueeTexture.image.height);
    const marqueeGeometry = new THREE.PlaneGeometry(marqueePlaneWidth, marqueePlaneHeight);
    const marqueeTextMeshInitialPosition = new THREE.Vector3(0, 0, -3 * depthStep);

    marqueeTextMesh = new THREE.Mesh(marqueeGeometry, marqueeMaterial);
    // Position far back in the background, but in front of the actual background image
    marqueeTextMesh.position.copy(marqueeTextMeshInitialPosition);
    marqueeTextMesh.visible = false;
    marqueeTextMesh.userData.initialPosition = marqueeTextMesh.position.clone();
    marqueeTextMesh.userData.initialLayer = -3;
    marqueeTextMesh.userData.id = 'marqueeTextMesh'; // Added ID
    scene.add(marqueeTextMesh);

    initialAssetConfigs.push({
        id: 'marqueeTextMesh',
        type: 'textMesh',
        initialPosition: marqueeTextMeshInitialPosition.clone(),
        initialLayer: -3,
        geometry: marqueeGeometry.clone(),
        material: marqueeMaterial.clone(),
        removed: false // Add removed flag
    });

    // Initialize the new Biometric Marquee Text
    biometricMarqueeTexture = createBiometricMarqueeTexture(); // Settings applied inside this function
    const biometricMarqueeMaterial = new THREE.MeshBasicMaterial({ map: biometricMarqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    const biometricMarqueePlaneWidth = 20; // Same width as main marquee for consistency
    const biometricMarqueePlaneHeight = biometricMarqueePlaneWidth / (biometricMarqueeTexture.image.width / biometricMarqueeTexture.image.height);
    const biometricMarqueeGeometry = new THREE.PlaneGeometry(biometricMarqueePlaneWidth, biometricMarqueePlaneHeight);
    const biometricMarqueeZ = (5 - 1) * depthStep;
    const distance_from_camera_biometric = camera.position.z - biometricMarqueeZ;
    const world_height_biometric = 2 * distance_from_camera_biometric * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
    const pixelToUnitFactorX_biometric = (world_height_biometric * camera.aspect) / window.innerWidth;
    const moveRightUnits_biometric = 30 * pixelToUnitFactorX_biometric;
    const biometricMarqueeTextMeshInitialPosition = new THREE.Vector3(moveRightUnits_biometric, 0, biometricMarqueeZ);

    biometricMarqueeTextMesh = new THREE.Mesh(biometricMarqueeGeometry, biometricMarqueeMaterial);
    biometricMarqueeTextMesh.position.copy(biometricMarqueeTextMeshInitialPosition);
    biometricMarqueeTextMesh.visible = false; // Initially hidden
    biometricMarqueeTextMesh.userData.initialPosition = biometricMarqueeTextMesh.position.clone();
    biometricMarqueeTextMesh.userData.initialLayer = 5;
    biometricMarqueeTextMesh.userData.id = 'biometricMarqueeTextMesh'; // Added ID
    scene.add(biometricMarqueeTextMesh);

    initialAssetConfigs.push({
        id: 'biometricMarqueeTextMesh',
        type: 'textMesh',
        initialPosition: biometricMarqueeTextMeshInitialPosition.clone(),
        initialLayer: 5,
        geometry: biometricMarqueeGeometry.clone(),
        material: biometricMarqueeMaterial.clone(),
        removed: false // Add removed flag
    });

    // Initialize the new Blood Text
    bloodTexture = createBloodTextTexture(); // Settings applied inside this function
    const bloodTextMaterial = new THREE.MeshBasicMaterial({ map: bloodTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    const bloodTextPlaneWidth = 20; // Similar width to other marquees
    const bloodTextPlaneHeight = bloodTextPlaneWidth / (bloodTexture.image.width / bloodTexture.image.height);
    const bloodTextGeometry = new THREE.PlaneGeometry(bloodTextPlaneWidth, bloodTextPlaneHeight);
    const bloodTextMeshInitialPosition = new THREE.Vector3(0, 30, (8 - 1) * depthStep);

    bloodTextMesh = new THREE.Mesh(bloodTextGeometry, bloodTextMaterial);
    // Position on Level 8 (moved back from Level 12 by 4 levels)
    bloodTextMesh.position.copy(bloodTextMeshInitialPosition);
    bloodTextMesh.visible = false; // Initially hidden
    bloodTextMesh.userData.initialPosition = bloodTextMesh.position.clone();
    bloodTextMesh.userData.initialLayer = 8;
    bloodTextMesh.userData.id = 'bloodTextMesh'; // Added ID
    scene.add(bloodTextMesh);

    initialAssetConfigs.push({
        id: 'bloodTextMesh',
        type: 'textMesh',
        initialPosition: bloodTextMeshInitialPosition.clone(),
        initialLayer: 8,
        geometry: bloodTextGeometry.clone(),
        material: bloodTextMaterial.clone(),
        removed: false // Add removed flag
    });

    // Initialize the new Redacted Glitch Text
    redactedGlitchTexture = createRedactedGlitchTexture(); // Settings applied inside this function
    const redactedGlitchMaterial = new THREE.MeshBasicMaterial({ map: redactedGlitchTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    const redactedGlitchPlaneWidth = 15; // Width for the text block
    const redactedGlitchPlaneHeight = redactedGlitchPlaneWidth / (redactedGlitchTexture.image.width / redactedGlitchTexture.image.height);
    const redactedGlitchGeometry = new THREE.PlaneGeometry(redactedGlitchPlaneWidth, redactedGlitchPlaneHeight);
    const redactedGlitchTextZ = (1 - 8) * depthStep;
    const distance_from_camera_redacted = camera.position.z - redactedGlitchTextZ;
    const world_height_redacted = 2 * distance_from_camera_redacted * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
    const pixelToUnitFactorX_redacted = (world_height_redacted * camera.aspect) / window.innerWidth;
    const moveRightUnits_redacted = 40 * pixelToUnitFactorX_redacted;
    const redactedGlitchTextMeshInitialPosition = new THREE.Vector3(-5 + moveRightUnits_redacted, 0, redactedGlitchTextZ);

    redactedGlitchTextMesh = new THREE.Mesh(redactedGlitchGeometry, redactedGlitchMaterial);
    redactedGlitchTextMesh.position.copy(redactedGlitchTextMeshInitialPosition);
    redactedGlitchTextMesh.visible = false; // Initially hidden
    redactedGlitchTextMesh.userData.initialPosition = redactedGlitchTextMesh.position.clone();
    redactedGlitchTextMesh.userData.initialLayer = 1;
    redactedGlitchTextMesh.userData.id = 'redactedGlitchTextMesh'; // Added ID
    scene.add(redactedGlitchTextMesh);

    initialAssetConfigs.push({
        id: 'redactedGlitchTextMesh',
        type: 'textMesh',
        initialPosition: redactedGlitchTextMeshInitialPosition.clone(),
        initialLayer: 1,
        geometry: redactedGlitchGeometry.clone(),
        material: redactedGlitchMaterial.clone(),
        removed: false // Add removed flag
    });

    initializeRedactedGlitchPhraseData(); // Initialize the redaction patterns

    window.addEventListener('resize', onWindowResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
    renderer.domElement.addEventListener('click', onClick);

    // Helper function to add a toggle button for an effect
    const addButtonToggle = (parentContainer, label, property, pass) => {
        const button = document.createElement('button');
        button.textContent = label.toUpperCase();
        button.style.cssText = `
            background-color: black;
            color: white;
            padding: 4px;
            margin: 0;
            border: 0.5px solid ${effectControls[property] ? '#4CAF50' : 'white'};
            border-radius: 0;
            cursor: pointer;
            font-family: monospace;
            font-size: 7px;
            outline: none;
            box-sizing: border-box;
        `;
        button.onmouseover = () => {
            if (effectControls[property]) {
                button.style.borderColor = '#66CC66'; // Brighter green for active hover
            } else {
                button.style.borderColor = '#777';
            }
        };
        button.onmouseout = () => {
            if (effectControls[property]) {
                button.style.borderColor = '#4CAF50'; // Green for active
            } else {
                button.style.borderColor = 'white'; // White for inactive
            }
        };

        button.onclick = (event) => {
            // Prevent event from bubbling up to document and triggering other handlers
            event.stopPropagation();

            let targetProperty = property; // Default to the button's own property

            // If HACKER is clicked, toggle the 'og' effect and keep hacker state in sync for UI update
            if (property === 'hacker') {
                effectControls.og = !effectControls.og;
                effectControls.hacker = effectControls.og;
                targetProperty = 'og'; // Process as if 'og' was clicked
            }

            // If this effect is being turned on, turn off conflicting effects
            if (!effectControls[targetProperty]) { // If turning the effect ON (or the underlying 'og' effect for 'hacker')

                // Turn off 'Anon' if any other effect is explicitly turned on
                if (effectControls.anon && targetProperty !== 'anon') {
                    effectControls.anon = false;
                    thresholdPass.enabled = false;
                    bloodPass.enabled = false;
                    glitchPass.enabled = false;
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false;
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false;
                    updateUIButtonState('anon', false);
                }

                // Turn off conflicting visual effects
                if (targetProperty === 'cctvFeed') {
                    if (effectControls.heatmap) { effectControls.heatmap = false; heatmapPass.enabled = false; updateUIButtonState('heatmap', false); }
                    if (effectControls.blood) { effectControls.blood = false; bloodPass.enabled = false; updateUIButtonState('blood', false); } // Turn off blood when CCTV is on
                    if (effectControls.bloodText) { effectControls.bloodText = false; bloodTextMesh.visible = false; updateUIButtonState('bloodText', false); } // Turn off blood text
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                } else if (targetProperty === 'heatmap') {
                    if (effectControls.cctvFeed) { effectControls.cctvFeed = false; cctvFeedPass.enabled = false; updateUIButtonState('cctvFeed', false); }
                    if (effectControls.blood) { effectControls.blood = false; bloodPass.enabled = false; updateUIButtonState('blood', false); } // Turn off blood when Heatmap is on
                    if (effectControls.bloodText) { effectControls.bloodText = false; bloodTextMesh.visible = false; updateUIButtonState('bloodText', false); } // Turn off blood text
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                } else if (targetProperty === 'blood' || targetProperty === 'bloodText') { // If Blood or Blood Text is turned on
                    if (effectControls.heatmap) { effectControls.heatmap = false; heatmapPass.enabled = false; updateUIButtonState('heatmap', false); }
                    if (effectControls.cctvFeed) { effectControls.cctvFeed = false; cctvFeedPass.enabled = false; updateUIButtonState('cctvFeed', false); }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                } else if (targetProperty === 'redactedGlitch') {
                    if (effectControls.redacted) { effectControls.redacted = false; updateUIButtonState('redacted', false); } // Turn off simple redacted
                    if (effectControls.glitch) { effectControls.glitch = false; glitchPass.enabled = false; updateUIButtonState('glitch', false); } // Turn off general glitch
                    if (effectControls.xray) { effectControls.xray = false; xrayPass.enabled = false; updateUIButtonState('xray', false); } // Turn off xray
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.cctvFeed) { effectControls.cctvFeed = false; cctvFeedPass.enabled = false; updateUIButtonState('cctvFeed', false); } // Turn off CCTV
                    if (effectControls.heatmap) { effectControls.heatmap = false; heatmapPass.enabled = false; updateUIButtonState('heatmap', false); } // Turn off Heatmap
                    if (effectControls.blood) { effectControls.blood = false; bloodPass.enabled = false; updateUIButtonState('blood', false); } // Turn off Blood
                    if (effectControls.bloodText) { effectControls.bloodText = false; bloodTextMesh.visible = false; updateUIButtonState('bloodText', false); } // Turn off Blood Text
                    if (effectControls.biometricMarquee) { effectControls.biometricMarquee = false; biometricMarqueeTextMesh.visible = false; updateUIButtonState('biometricMarquee', false); } // Turn off Biometric
                    if (effectControls.marqueeText) { effectControls.marqueeText = false; marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false); } // Turn off Marquee
                    if (effectControls.matrix) { effectControls.matrix = false; matrixPass.enabled = false; updateUIButtonState('matrix', false); } // Turn off Matrix
                    if (effectControls.pixelation) { effectControls.pixelation = false; pixelationPass.enabled = false; updateUIButtonState('pixelation', false); } // Turn off Pixelation
                    if (effectControls.ascii) { effectControls.ascii = false; asciiPass.enabled = false; updateUIButtonState('ascii', false); } // Turn off Greyscale
                } else if (targetProperty === 'redacted') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'glitch') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'xray') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                    // If XRAY is turned on, ensure biometric marquee is turned off
                    if (effectControls.biometricMarquee) {
                        effectControls.biometricMarquee = false;
                        biometricMarqueeTextMesh.visible = false;
                        updateUIButtonState('biometricMarquee', false);
                    }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'biometricMarquee') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                    // If biometric marquee is turned on, ensure XRAY is turned off
                    if (effectControls.xray) {
                        effectControls.xray = false;
                        xrayPass.enabled = false;
                        marqueeTextMesh.visible = false; // Also hide main marquee if XRAY is off
                        updateUIButtonState('xray', false);
                    }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'threshold') {
                    if (effectControls.shadow) { effectControls.shadow = false; darkPass.enabled = false; updateUIButtonState('shadow', false); } // Updated to effectControls.shadow
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'shadow') {
                    if (effectControls.threshold) { effectControls.threshold = false; thresholdPass.enabled = false; updateUIButtonState('threshold', false); }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                }

                // Turn off all other non-combined visual effects if 'Anon' is being turned ON
                if (targetProperty === 'anon') {
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) && key !== 'anon' && key !== 'redacted' && key !== 'redactedGlitch' && key !== 'threshold' && key !== 'blood' && key !== 'glitch' && key !== 'marqueeText' && key !== 'biometricMarquee' && key !== 'yRotation' && key !== 'cameraAnimation' && key !== 'og' && key !== 'bloodText' && key !== 'hacker' && key !== 'surveillance' && key !== 'greed') { // Added greed
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Ensure redacted and redactedGlitch are off
                    effectControls.redacted = false; updateUIButtonState('redacted', false);
                    effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false);

                    // Turn off both marquees and blood text
                    effectControls.marqueeText = false; marqueeTextMesh.visible = false;
                    effectControls.biometricMarquee = false; biometricMarqueeTextMesh.visible = false;
                    effectControls.bloodText = false; bloodTextMesh.visible = false;
                    updateUIButtonState('marqueeText', false);
                    updateUIButtonState('biometricMarquee', false);
                    updateUIButtonState('bloodText', false);

                    // Turn off OG and Hacker and Surveillance and Greed if they're on
                    if (effectControls.og) {
                        effectControls.og = false;
                        asciiPass.enabled = false;
                        heatmapPass.enabled = false;
                        biometricMarqueeTextMesh.visible = false;
                        updateUIButtonState('og', false);
                    }
                    if (effectControls.hacker) {
                        effectControls.hacker = false;
                        updateUIButtonState('hacker', false);
                    }
                    if (effectControls.surveillance) {
                        effectControls.surveillance = false;
                        updateUIButtonState('surveillance', false);
                    }
                    if (effectControls.greed) {
                        effectControls.greed = false;
                        updateUIButtonState('greed', false);
                    }
                }

                // Handle turning on 'OG' effect (now also triggered by 'HACKER')
                if (targetProperty === 'og') {
                    // Turn off all other visual effects, excluding camera/y-rotation/feargreedindex
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) && key !== 'og' && key !== 'hacker' && key !== 'yRotation' && key !== 'cameraAnimation' && key !== 'bloodText' && key !== 'surveillance' && key !== 'greed') { // Added greed
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Specific cleanups for effects that don't have a pass or have special visibility
                    if (marqueeTextMesh) marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false);
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false; updateUIButtonState('redacted', false);
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false; updateUIButtonState('redactedGlitch', false);
                    if (bloodTextMesh) bloodTextMesh.visible = false; updateUIButtonState('bloodText', false);
                    if (biometricMarqueeTextMesh) biometricMarqueeTextMesh.visible = false; updateUIButtonState('biometricMarquee', false); // Ensure biometric is off if OG is turning on
                    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false; // Ensure redacted glitch text is off

                    // Turn off surveillance if OG is turned on
                    if (effectControls.surveillance) {
                        effectControls.surveillance = false;
                        updateUIButtonState('surveillance', false);
                    }
                    // Turn off greed if OG is turned on
                    if (effectControls.greed) {
                        effectControls.greed = false;
                        updateUIButtonState('greed', false);
                    }
                }

                // Handle turning on 'SURVEILLANCE' effect
                if (targetProperty === 'surveillance') {
                    // Turn off all other visual effects, excluding camera/y-rotation/feargreedindex
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) &&
                            key !== 'surveillance' &&
                            key !== 'heatmap' &&
                            key !== 'biometricMarquee' &&
                            key !== 'glitch' && // Added glitch to exclusion list for turning off
                            key !== 'yRotation' &&
                            key !== 'cameraAnimation' &&
                            key !== 'greed' // Exclude greed from being turned off by surveillance
                        ) {
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Specific cleanups for effects that don't have a pass or have special visibility
                    if (marqueeTextMesh) marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false);
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false; updateUIButtonState('redacted', false);
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false; updateUIButtonState('redactedGlitch', false);
                    if (bloodTextMesh) bloodTextMesh.visible = false; updateUIButtonState('bloodText', false);
                    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false; // Ensure redacted glitch text is off

                    // Ensure Anon, OG, Hacker are off
                    if (effectControls.anon) {
                        effectControls.anon = false;
                        updateUIButtonState('anon', false);
                    }
                    if (effectControls.og) {
                        effectControls.og = false;
                        updateUIButtonState('og', false);
                    }
                    if (effectControls.hacker) {
                        effectControls.hacker = false;
                        updateUIButtonState('hacker', false);
                    }
                }

                // Handle turning on 'GREED' effect
                if (targetProperty === 'greed') {
                    // Turn off all other visual effects, excluding camera/y-rotation/feargreedindex
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) &&
                            key !== 'greed' &&
                            key !== 'blood' &&
                            key !== 'bloodText' &&
                            key !== 'yRotation' &&
                            key !== 'cameraAnimation'
                        ) {
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Specific cleanups for effects that don't have a pass or have special visibility
                    if (marqueeTextMesh) marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false);
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false; updateUIButtonState('redacted', false);
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false; updateUIButtonState('redactedGlitch', false);
                    if (biometricMarqueeTextMesh) biometricMarqueeTextMesh.visible = false; updateUIButtonState('biometricMarquee', false);
                    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false; // Ensure redacted glitch text is off

                    // Ensure Anon, OG, Hacker, Surveillance, CCTV, Heatmap are off
                    if (effectControls.anon) {
                        effectControls.anon = false;
                        updateUIButtonState('anon', false);
                    }
                    if (effectControls.og) {
                        effectControls.og = false;
                        updateUIButtonState('og', false);
                    }
                    if (effectControls.hacker) {
                        effectControls.hacker = false;
                        updateUIButtonState('hacker', false);
                    }
                    if (effectControls.surveillance) {
                        effectControls.surveillance = false;
                        updateUIButtonState('surveillance', false);
                    }
                    if (effectControls.cctvFeed) {
                        effectControls.cctvFeed = false;
                        updateUIButtonState('cctvFeed', false);
                    }
                    if (effectControls.heatmap) {
                        effectControls.heatmap = false;
                        updateUIButtonState('heatmap', false);
                    }
                }

            } else if (targetProperty === 'shadow') { // If turning SHADOW OFF, also turn off Glitch if it was enabled by SHADOW
                if (effectControls.glitch) { // Check if glitch is currently active
                    // Only turn off glitch if it's not being used by another effect like 'Anon' or 'Redacted Glitch' or 'OG' or 'HACKER' or 'Surveillance' or 'Greed'
                    if (!effectControls.anon && !effectControls.redactedGlitch && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.glitch = false;
                        glitchPass.enabled = false;
                        updateUIButtonState('glitch', false);
                    }
                }
            }

            // Toggle the effect control state if it wasn't already toggled by 'hacker' logic
            if (property !== 'hacker') {
                effectControls[property] = !effectControls[property];
            }

            if (targetProperty === 'shadow') {
                darkPass.enabled = effectControls.shadow;
                // If SHADOW is active, also activate Glitch
                if (effectControls.shadow) {
                    effectControls.glitch = true;
                    glitchPass.enabled = true;
                } else { // If SHADOW is being turned off
                    // Only turn off glitch if it's not being used by another effect like 'Anon' or 'Redacted Glitch' or 'OG' or 'HACKER' or 'Surveillance' or 'Greed'
                    if (!effectControls.anon && !effectControls.redactedGlitch && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.glitch = false;
                        glitchPass.enabled = false;
                    }
                }
                updateUIButtonState('shadow', effectControls.shadow);
                updateUIButtonState('glitch', effectControls.glitch);
            } else if (targetProperty === 'og') {
                asciiPass.enabled = effectControls.og;
                heatmapPass.enabled = effectControls.og;
                biometricMarqueeTextMesh.visible = effectControls.og;
                updateUIButtonState('ascii', effectControls.og);
                updateUIButtonState('heatmap', effectControls.og);
                updateUIButtonState('biometricMarquee', effectControls.og);
                updateUIButtonState('og', effectControls.og);
                updateUIButtonState('hacker', effectControls.og); // Update HACKER button state
            } else if (targetProperty === 'bloodText') {
                // When bloodText is turned on, also ensure blood effect is on
                if (effectControls.bloodText) {
                    effectControls.blood = true;
                    bloodPass.enabled = true;
                    updateUIButtonState('blood', true);
                    // On initial enable, set bloodScrollOffset to ensure the text starts higher
                    if (bloodTextMesh && bloodTextMesh.material.map) {
                        bloodScrollOffset = bloodTextMesh.material.map.image.height; // Start at the bottom of the canvas
                        shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]);
                    }
                }
                bloodTextMesh.visible = effectControls.bloodText;
                updateUIButtonState('bloodText', effectControls.bloodText);
            } else if (targetProperty === 'surveillance') {
                // When SURVEILLANCE is turned on/off, toggle heatmap, biometric marquee, AND glitch
                effectControls.heatmap = effectControls.surveillance;
                heatmapPass.enabled = effectControls.surveillance;
                updateUIButtonState('heatmap', effectControls.surveillance);

                effectControls.biometricMarquee = effectControls.surveillance;
                biometricMarqueeTextMesh.visible = effectControls.surveillance;
                updateUIButtonState('biometricMarquee', effectControls.surveillance);

                effectControls.glitch = effectControls.surveillance; // Add glitch control
                glitchPass.enabled = effectControls.surveillance; // Enable/disable glitch pass
                updateUIButtonState('glitch', effectControls.surveillance); // Update glitch button state

                // Update the button for surveillance itself
                updateUIButtonState('surveillance', effectControls.surveillance);

            } else if (targetProperty === 'greed') {
                // When GREED is turned on/off, toggle blood and bloodText
                effectControls.blood = effectControls.greed;
                bloodPass.enabled = effectControls.greed;
                updateUIButtonState('blood', effectControls.greed);

                effectControls.bloodText = effectControls.greed;
                bloodTextMesh.visible = effectControls.greed;
                updateUIButtonState('bloodText', effectControls.greed);

                // If turning on, ensure text starts from bottom and reshuffle
                if (effectControls.greed) {
                    if (bloodTextMesh && bloodTextMesh.material.map) {
                        bloodScrollOffset = bloodTextMesh.material.map.image.height; // Start at the bottom of the canvas
                        shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]);
                    }
                }

                // Update the button for greed itself
                updateUIButtonState('greed', effectControls.greed);

            } else if (targetProperty === 'redactedGlitch') { // Handle Redacted Glitch effect toggle
                if (rightEyeRedactionRect) rightEyeRedactionRect.visible = effectControls.redactedGlitch;
                if (leftEyeRedactionRect) leftEyeRedactionRect.visible = effectControls.redactedGlitch;
                glitchPass.enabled = effectControls.redactedGlitch;
                redactedGlitchTextMesh.visible = effectControls.redactedGlitch;

                // When redactedGlitch is active, force threshold effect on
                if (effectControls.redactedGlitch) {
                    effectControls.threshold = true;
                    thresholdPass.enabled = true;
                    updateUIButtonState('threshold', true);
                    // Ensure shadow is off if threshold is forced on
                    if (effectControls.shadow) {
                        effectControls.shadow = false;
                        darkPass.enabled = false;
                        updateUIButtonState('shadow', false);
                        // Glitch is already being turned on by Anon, so no need to turn off if it was from shadow
                    }
                }
                else { // If turning off redactedGlitch
                    if (!effectControls.redacted && !effectControls.anon && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.threshold = false;
                        thresholdPass.enabled = false;
                        updateUIButtonState('threshold', false);
                    }
                }
                updateUIButtonState('redactedGlitch', effectControls.redactedGlitch);
                updateUIButtonState('glitch', effectControls.redactedGlitch); // Sync glitch button

            } else if (pass) {
                pass.enabled = effectControls[targetProperty];
                updateUIButtonState(targetProperty, effectControls[targetProperty]);
            }

            // Update marquee text visibility based on XRAY only
            const shouldMarqueeBeVisible = effectControls.xray;
            if (effectControls.marqueeText !== shouldMarqueeBeVisible) {
                effectControls.marqueeText = shouldMarqueeBeVisible;
                marqueeTextMesh.visible = shouldMarqueeBeVisible;
            }

            // Toggle biometric marquee visibility (if not controlled by surveillance/OG/HACKER/GREED)
            if (targetProperty === 'biometricMarquee' && !effectControls.surveillance && !effectControls.og && !effectControls.hacker && !effectControls.greed) {
                biometricMarqueeTextMesh.visible = effectControls.biometricMarquee;
            }

            // Handle redacted effect toggle
            if (targetProperty === 'redacted') {
                if (rightEyeRedactionRect) rightEyeRedactionRect.visible = effectControls.redacted;
                if (leftEyeRedactionRect) leftEyeRedactionRect.visible = effectControls.redacted;
                // When redacted is active, force threshold effect on
                if (effectControls.redacted) {
                    effectControls.threshold = true;
                    thresholdPass.enabled = true;
                    updateUIButtonState('threshold', true);
                    // Ensure shadow is off if threshold is forced on
                    if (effectControls.shadow) {
                        effectControls.shadow = false;
                        darkPass.enabled = false;
                        updateUIButtonState('shadow', false);
                        // Also turn off glitch if it was enabled by shadow and not by other effects
                        if (!effectControls.anon && !effectControls.redactedGlitch && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                            effectControls.glitch = false;
                            glitchPass.enabled = false;
                            updateUIButtonState('glitch', false);
                        }
                    }
                } else {
                    if (!effectControls.redactedGlitch && !effectControls.anon && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.threshold = false;
                        thresholdPass.enabled = false;
                        updateUIButtonState('threshold', false);
                    }
                }
            }

            // Handle Anon effect toggle
            if (targetProperty === 'anon') {
                if (effectControls.anon) {
                    thresholdPass.enabled = true;
                    bloodPass.enabled = true;
                    glitchPass.enabled = true;
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = true;
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = true;

                    // Ensure shadow is off if threshold is forced on by Anon
                    if (effectControls.shadow) {
                        effectControls.shadow = false;
                        darkPass.enabled = false;
                        updateUIButtonState('shadow', false);
                        // Glitch is already being turned on by Anon, so no need to turn off if it was from shadow
                    }
                }
                else {
                    thresholdPass.enabled = false;
                    bloodPass.enabled = false;
                    glitchPass.enabled = false;
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false;
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false;
                }
                // Update threshold, blood, glitch buttons to reflect Anon's state
                updateUIButtonState('threshold', effectControls.anon);
                updateUIButtonState('blood', effectControls.anon);
                updateUIButtonState('glitch', effectControls.anon);
            }

            // Handle camera animation toggle
            if (property === 'cameraAnimation') {
                cameraAnimationActive = effectControls.cameraAnimation;
                controls.enabled = !cameraAnimationActive;
                if (cameraAnimationActive) {
                    // Ensure Y-rotation is off if camera animation is activated
                    if (effectControls.yRotation) {
                        effectControls.yRotation = false;
                        updateUIButtonState('yRotation', false);
                    }
                    // Capture current camera state as the *initial* global start point for the loop
                    initialGlobalCameraPos.copy(camera.position);
                    initialGlobalCameraLookAt.copy(controls.target);
                    // Set loop start to global start for the first exploration
                    cameraPreviousPos.copy(initialGlobalCameraPos);
                    cameraPreviousLookAt.copy(initialGlobalCameraLookAt);
                    assetsVisitedCount = 0;
                    startCameraAnimation(performance.now());
                } else {
                    // Reset camera to default or current OrbitControls view when animation stops
                    camera.position.copy(initialGlobalCameraPos);
                    controls.target.copy(initialGlobalCameraLookAt);
                    camera.lookAt(controls.target);
                    cameraAnimationState = 'idle';
                    assetsVisitedCount = 0;
                    // Re-enable controls if Y-rotation is not active
                    if (!effectControls.yRotation) {
                        controls.enabled = true;
                    }
                }
                yRotationStartTime = 0; // Reset Y-rotation auto-start timer if camera anim is manually toggled
            }

            // Handle Y-axis rotation toggle
            if (property === 'yRotation') {
                if (effectControls.yRotation) {
                    // When Y-rotation starts, disable OrbitControls and camera animation
                    controls.enabled = false;
                    cameraAnimationActive = false;
                    updateUIButtonState('cameraAnimation', false);
                    // Store initial camera position for the bounce animation
                    yBounceInitialCameraX = camera.position.x;
                    yBounceInitialCameraY = camera.position.y;
                    yBounceInitialCameraZ = camera.position.z;
                    yRotationStartTime = performance.now(); // Record start time for Y-rotation
                } else {
                    // When Y-rotation stops, re-enable OrbitControls if no other camera animation is active
                    if (!cameraAnimationActive) {
                        controls.enabled = true;
                    }
                    // Optionally reset camera to its original position before bounce
                    camera.position.set(yBounceInitialCameraX, yBounceInitialCameraY, yBounceInitialCameraZ);
                    controls.target.set(0, 0, (1 - 1) * depthStep);
                    camera.lookAt(controls.target);
                    yRotationStartTime = 0; // Reset Y-rotation auto-start timer if Y-rotation is manually toggled off
                }
                lastActivityTime = performance.now();
            }
            
            // Crucial: Update face materials after any effect toggle
            updateFaceMaterialState();
        };
        button.setAttribute('data-effect', property);
        parentContainer.appendChild(button);
    };

    // Helper to get pass by name
    const getPassByName = (name) => {
        switch (name) {
            case 'greyscale': return greyscalePass;
            case 'threshold': return thresholdPass;
            case 'shadow': return darkPass;
            case 'pixelation': return pixelationPass;
            case 'glitch': return glitchPass;
            case 'matrix': return matrixPass;
            case 'ascii': return asciiPass;
            case 'xray': return xrayPass;
            case 'heatmap': return heatmapPass;
            case 'blood': return bloodPass;
            case 'cctvFeed': return cctvFeedPass;
            default: return null;
        }
    };

    // Define buttons to be added to both UIs
    const buttonsConfig = [
        { label: '3D', property: 'yRotation', pass: null },
        { label: 'FLY', property: 'cameraAnimation', pass: null },
        { label: 'SHADOW', property: 'shadow', pass: darkPass },
        { label: 'ASCII', property: 'ascii', pass: asciiPass },
        { label: 'HEATMAP', property: 'heatmap', pass: heatmapPass },
        { label: 'BLOOD', property: 'blood', pass: bloodPass },
        { label: 'REDACTED', property: 'redactedGlitch', pass: null },
        { label: 'ANON', property: 'anon', pass: null },
        { label: 'BIOMETRIC', property: 'biometricMarquee', pass: null },
        { label: 'OG', property: 'og', pass: null },
        { label: 'BLOOD TEXT', property: 'bloodText', pass: null },
        { label: 'DATA SCRAPER', property: 'hacker', pass: null },
        { label: 'BIO-CODER', property: 'surveillance', pass: null },
        { label: 'HIDDEN HAND', property: 'greed', pass: null },
        { label: 'Greyscale', property: 'greyscale', pass: greyscalePass },
        { label: 'Threshold', property: 'threshold', pass: thresholdPass },
        { label: 'Pixelation', property: 'pixelation', pass: pixelationPass },
        { label: 'Glitch', property: 'glitch', pass: glitchPass },
        { label: 'Matrix', property: 'matrix', pass: matrixPass },
        { label: 'XRAY', property: 'xray', pass: xrayPass },
        { label: 'CCTV FEED', property: 'cctvFeed', pass: cctvFeedPass },

    ];

    // Create and append the left UI container
    leftUiContainer = document.createElement('div'); // Assign to global variable
    leftUiContainer.id = 'left-ui-container';
    leftUiContainer.style.position = 'absolute';
    leftUiContainer.style.top = '-190px'; // Start mostly hidden, revealing only the arrow
    leftUiContainer.style.left = '10px';
    leftUiContainer.style.backgroundColor = 'rgba(0, 0, 0, 0)';
    leftUiContainer.style.color = 'white';
    leftUiContainer.style.padding = '10px'; /* Reduced padding for more compact layout */
    leftUiContainer.style.borderRadius = '5px';
    leftUiContainer.style.fontFamily = 'monospace';
    leftUiContainer.style.zIndex = '100';
    leftUiContainer.style.display = 'flex';
    leftUiContainer.style.flexDirection = 'column'; /* Changed to column for vertical layout */
    leftUiContainer.style.flexWrap = 'nowrap'; /* Not needed for single column */
    leftUiContainer.style.gap = '5px'; /* Adjusted gap for vertical layout */
    leftUiContainer.style.transition = 'top 0.5s ease-in-out'; // Smooth transition for top property
    document.body.appendChild(leftUiContainer);

    // Create and append the right UI container
    const rightUiContainer = document.createElement('div');
    rightUiContainer.id = 'right-ui-container';
    rightUiContainer.style.position = 'absolute';
    rightUiContainer.style.top = '10px';
    rightUiContainer.style.right = '10px';
    rightUiContainer.style.backgroundColor = 'rgba(0, 0, 0, 0)';
    rightUiContainer.style.color = 'white';
    rightUiContainer.style.padding = '10px';
    rightUiContainer.style.borderRadius = '5px';
    rightUiContainer.style.fontFamily = 'monospace';
    rightUiContainer.style.zIndex = '100';
    rightUiContainer.style.display = 'none'; // Hide the right UI container
    rightUiContainer.style.flexDirection = 'column';
    rightUiContainer.style.gap = '5px';
    document.body.appendChild(rightUiContainer);

    // Define the desired order of buttons for the left UI
    const leftUiOrder = [
        'yRotation', // 3D
        'cameraAnimation', // FLY
        'surveillance', // NEW SURVEILLANCE BUTTON
        'greed', // NEW GREED BUTTON (now ULTERIOR MOVTIVES)
        'hacker', // HACKER moved to position 5
        'shadow',
        'redactedGlitch'
    ];

    // Map property names to their full config objects for easy lookup
    const buttonConfigMap = new Map(buttonsConfig.map(config => [config.property, config]));

    // Add buttons to the left UI container in the specified order
    leftUiOrder.forEach(propertyName => {
        const config = buttonConfigMap.get(propertyName);
        if (config) {
            addButtonToggle(leftUiContainer, config.label, config.property, config.pass);
        }
    });

    // Add all buttons to the right UI container
    buttonsConfig.forEach(config => {
        if (!leftUiOrder.includes(config.property)) { // Only add if not already in left UI
            addButtonToggle(rightUiContainer, config.label, config.property, config.pass);
        }
    });

    // Add the RESET button to both UI containers
    const createResetButton = () => {
        const button = document.createElement('button');
        button.textContent = 'RESET';
        button.style.cssText = `
            background-color: black; /* Changed from #CC0000 to black */
            color: white;
            padding: 4px;
            margin-top: 10px;
            border: 0.5px solid rgba(0, 0, 0, 0.8);
            border-radius: 0;
            cursor: pointer;
            font-family: monospace;
            font-size: 7px;
            outline: none;
            white-space: nowrap;
            box-sizing: border-box;
        `;
        button.onmouseover = () => { button.style.borderColor = 'rgba(0, 0, 0, 1.0)'; };
        button.onmouseout = () => { button.style.borderColor = 'rgba(0, 0, 0, 0.8)'; };
        button.onclick = (event) => { event.stopPropagation(); resetPiecesToOriginalPositions(); };
        return button;
    };
    leftUiContainer.appendChild(createResetButton());
    rightUiContainer.appendChild(createResetButton());

    // Create and append the TRASH button to the left UI container
    const createTrashButton = () => {
        const button = document.createElement('button');
        button.id = 'trash-button'; // Unique ID for easy targeting
        button.innerHTML = 'TRASH'; // Text with trashcan icon
        button.style.cssText = `
            background-color: black; /* Changed from #CC0000 to black */
            color: white;
            padding: 4px;
            margin-top: 10px;
            border: none;
            border-radius: 0;
            cursor: pointer;
            font-family: monospace;
            font-size: 7px;
            outline: none;
            white-space: nowrap;
            box-sizing: border-box;
        `;
        button.onmouseover = () => { }; /* Removed border change on hover */
        button.onmouseout = () => { }; /* Removed border change on mouseout */
        // The actual removal logic will be in onPointerUp, triggered by dropping onto this button
        return button;
    };
    trashButtonElement = createTrashButton(); // Store reference to the button element
    leftUiContainer.appendChild(trashButtonElement);

    // Create and append the EXPORT button below TRASH
    const createExportButton = () => {
        const button = document.createElement('button');
        button.id = 'export-toggle';
        button.innerHTML = 'RCS';
        button.style.cssText = `
            display: none !important;
        `;
        return button;
    };
    exportButtonElement = createExportButton();
    exportButtonElement.style.display = 'none';
    leftUiContainer.appendChild(exportButtonElement);


    // Add the thin black rectangle with a down-facing arrow below the TRASH button
    arrowContainer = document.createElement('div'); // Assign to global variable
    arrowContainer.id = 'arrow-container'; // Add ID for better targeting
    arrowContainer.style.cssText = `
        position: absolute; /* Position relative to the viewport */
        top: 0px; /* Initially at the top, peeking out */
        left: 20px;
        background-color: black;
        width: 60px; /* Fixed width for the arrow tab */
        height: 15px; /* Height of the arrow tab */
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        z-index: 101; /* Higher z-index than leftUiContainer to be clickable */
        border-bottom-left-radius: 5px; /* Rounded corners for the tab */
        border-bottom-right-radius: 5px;
        transition: top 0.5s ease-in-out; /* Smooth transition for top property */
        box-sizing: border-box; /* Include padding and border in the element's total width and height */
    `;
    const arrowSpan = document.createElement('span');
    arrowSpan.style.cssText = `
        color: white;
        font-size: 10px; /* Larger arrow */
    `;
    arrowSpan.innerHTML = '&#x25BC;'; // Down-facing triangle
    arrowContainer.appendChild(arrowSpan);
    document.body.appendChild(arrowContainer); // Append to body, not leftUiContainer

    // Add click listener for the arrow container to toggle left UI visibility
    arrowContainer.onclick = (event) => {
        event.stopPropagation(); // Prevent clicks from interacting with 3D scene
        if (leftUiContainer.style.top === '10px') {
            leftUiContainer.style.top = '-190px'; // Hide it, revealing only the arrow
            trashButtonElement.style.display = 'none'; // Hide TRASH button
            exportButtonElement.style.display = 'none'; // Hide EXPORT button
            arrowContainer.style.top = '0px'; // Keep arrow at the top
            arrowSpan.innerHTML = '&#x25BC;'; // Change to down arrow
        } else {
            leftUiContainer.style.top = '10px'; // Show it
            trashButtonElement.style.display = 'block'; // Show TRASH button
            arrowContainer.style.top = `${leftUiContainer.offsetHeight + 10}px`; // Move arrow below the UI
            arrowSpan.innerHTML = '&#x25B2'; // Change to up arrow
        }
    };

    // Initial state setup for TRASH button and arrowContainer
    // When the page loads, the left UI is hidden, so the trash button should be hidden.
    trashButtonElement.style.display = 'none';
    exportButtonElement.style.display = 'none';

    window.addEventListener('resize', onWindowResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
    renderer.domElement.addEventListener('click', onClick);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    if (composer) {
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    if (pixelationPass) {
        pixelationPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    }
    if (asciiPass) {
        asciiPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    }
    if (cctvFeedPass) {
        cctvFeedPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    }

    // Adjust arrow container position on resize if UI is open
    if (leftUiContainer.style.top === '10px') {
        arrowContainer.style.top = `${leftUiContainer.offsetHeight + 10}px`;
    }

    lastActivityTime = performance.now();
    stopCameraAnimationAndReset();
}

function onPointerDown(event) {
    lastActivityTime = performance.now();
    // stopCameraAnimationAndReset(); // Removed: Only stop FLY camera on explicit click
    isDragging = false;
    pointerDownPosition.set(event.clientX, event.clientY);

    // Check if the click is on a UI element
    if (event.target.closest('#left-ui-container') || event.target.closest('#right-ui-container') || event.target.closest('#arrow-container')) {
        selectedObject = null;
        controls.enabled = true;
        return;
    }

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(draggableObjects, true); // Intersect with all descendants

    // Filter intersects to only consider those with alpha > 0.1
    for (const intersect of intersects) {
        const object = intersect.object;
        const material = object.material;

        // Ensure the material has a map property before trying to access its alpha
        if (material && material.map && material.transparent) {
            const uv = intersect.uv;
            const alpha = getAlphaAtUV(material.map, uv);

            if (alpha > 0.1) { // Alpha threshold for drag detection
                selectedObject = object;
                controls.enabled = false;
                initialObjectZ = selectedObject.position.z;
                offset.copy(intersect.point).sub(selectedObject.position);
                break; // Found a draggable opaque part, stop searching
            }
        } else if (material instanceof THREE.ShaderMaterial && material.alphaTest !== undefined && material.alphaTest > 0) {
            // For ShaderMaterial with alphaTest, treat as always opaque if intersect occurs
            selectedObject = object;
            controls.enabled = false;
            initialObjectZ = selectedObject.position.z;
            offset.copy(intersect.point).sub(selectedObject.position);
            break; // Found a draggable opaque part, stop searching
        } else if (material && !material.transparent) {
            // For opaque materials, any intersect means it's draggable
            selectedObject = object;
            controls.enabled = false;
            initialObjectZ = selectedObject.position.z;
            offset.copy(intersect.point).sub(selectedObject.position);
            break; // Found a draggable opaque part, stop searching
        }
    }
}

function onPointerMove(event) {
    lastActivityTime = performance.now();
    // stopCameraAnimationAndReset(); // Removed: Only stop FLY camera on explicit click
    if (selectedObject) {
        // Check if the pointer has moved beyond the drag threshold
        const currentPointerPosition = new THREE.Vector2(event.clientX, event.clientY);
        if (currentPointerPosition.distanceTo(pointerDownPosition) > DRAG_THRESHOLD) {
            isDragging = true;
        }

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // Create a plane that is parallel to the camera's view plane
        // and passes through the object's initial Z-position.
        const plane = new THREE.Plane();
        plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), new THREE.Vector3(0, 0, initialObjectZ));

        const intersection = new THREE.Vector3();
        if (raycaster.ray.intersectPlane(plane, intersection)) {
            // Update X and Y, but keep the original Z-position
            selectedObject.position.x = intersection.x - offset.x;
            selectedObject.position.y = intersection.y - offset.y;
            selectedObject.position.z = initialObjectZ;

            // Update redaction rectangle positions if the selected object is an eye
            if (selectedObject === rightEyeMesh) {
                if (rightEyeRedactionRect) {
                    rightEyeRedactionRect.position.x = selectedObject.position.x;
                    rightEyeRedactionRect.position.y = selectedObject.position.y;
                }
            } else if (selectedObject === leftEyeMesh) {
                if (leftEyeRedactionRect) {
                    leftEyeRedactionRect.position.x = selectedObject.position.x;
                    leftEyeRedactionRect.position.y = selectedObject.position.y;
                }
            }
        }
    }
}

function onPointerUp(event) {
    lastActivityTime = performance.now();
    // stopCameraAnimationAndReset(); // Removed: Only stop FLY camera on explicit click

    if (isDragging && selectedObject) {
        // If the selected object is a drone, update its droneInitialY and droneInitialX to its new position
        if (selectedObject.userData.id && selectedObject.userData.id.startsWith('drone')) {
            selectedObject.userData.droneInitialY = selectedObject.position.y;
            selectedObject.userData.droneInitialX = selectedObject.position.x;
        }

        // Check if the pointer was released over the TRASH button
        if (trashButtonElement) {
            const rect = trashButtonElement.getBoundingClientRect();

            // Define a larger target area for the trash button
            const expandedRect = {
                left: rect.left - 20, // 20 pixels extra padding on left
                right: rect.right + 20, // 20 pixels extra padding on right
                top: rect.top - 20, // 20 pixels extra padding on top
                bottom: rect.bottom + 20 // 20 pixels extra padding on bottom
            };

            if (event.clientX >= expandedRect.left && event.clientX <= expandedRect.right &&
                event.clientY >= expandedRect.top && event.clientY <= expandedRect.bottom) {

                // Mark the object as removed in the initialAssetConfigs for later reloading
                const configIndex = initialAssetConfigs.findIndex(config => config.id === selectedObject.userData.id);
                if (configIndex !== -1) {
                    initialAssetConfigs[configIndex].removed = true;
                }

                // Object was dropped onto the trash button, remove it
                scene.remove(selectedObject);
                // Remove from draggableObjects array
                draggableObjects = draggableObjects.filter(obj => obj !== selectedObject);
                // Remove from cameraAnimationTargets array
                cameraAnimationTargets = cameraAnimationTargets.filter(obj => obj !== selectedObject);

                // Dispose of geometry and material to free up memory
                if (selectedObject.geometry) selectedObject.geometry.dispose();
                if (selectedObject.material) {
                    if (Array.isArray(selectedObject.material)) {
                        selectedObject.material.forEach(m => m.dispose());
                    } else {
                        selectedObject.material.dispose();
                    }
                }

                // Special handling for specific removed objects (set global refs to null)
                if (selectedObject.userData.id === 'rightEye') {
                    if (rightEyeRedactionRect) { scene.remove(rightEyeRedactionRect); rightEyeRedactionRect.geometry.dispose(); rightEyeRedactionRect.material.dispose(); }
                    rightEyeMesh = null;
                    rightEyeRedactionRect = null;
                }
                if (selectedObject.userData.id === 'leftEye') {
                    if (leftEyeRedactionRect) { scene.remove(leftEyeRedactionRect); leftEyeRedactionRect.geometry.dispose(); leftEyeRedactionRect.material.dispose(); }
                    leftEyeMesh = null;
                    leftEyeRedactionRect = null;
                }
                if (selectedObject.userData.id.startsWith('drone')) { // Handle all drones
                    droneMeshes = droneMeshes.filter(drone => drone !== selectedObject);
                }
                console.log("Object removed:", selectedObject.name || selectedObject.uuid);
            }
        }
    }

    selectedObject = null;
    // Re-enable controls only if camera animation AND yRotation are not active
    if (!cameraAnimationActive && !effectControls.yRotation) {
        controls.enabled = true;
    }
    // isDragging is reset by onPointerDown for the next interaction
}

function onClick(event) {
    lastActivityTime = performance.now();
    // Use performance.now() to get current time for button interactions
    const currentTime = performance.now();
    // stopCameraAnimationAndReset(); // Moved: Only stop FLY camera on explicit click if not dragging and not on UI
    // Only process click if no dragging occurred and not clicking on UI
    if (isDragging || event.target.closest('#left-ui-container') || event.target.closest('#right-ui-container') || event.target.closest('#arrow-container')) {
        return;
    }

    stopCameraAnimationAndReset(); // Only stop FLY camera on explicit click if not dragging and not on UI

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(draggableObjects, true); // Intersect with all descendants

    // Filter intersects to only consider those with alpha > 0.1
    let clickedObject = null;
    for (const intersect of intersects) {
        const object = intersect.object;
        const material = object.material;

        // Special handling for ShaderMaterial with alphaTest, as getAlphaAtUV is for MeshBasicMaterial
        if (material instanceof THREE.ShaderMaterial && material.alphaTest !== undefined && material.alphaTest > 0) {
            clickedObject = object;
            break;
        } else if (material && material.map && material.transparent) {
            const uv = intersect.uv;
            const alpha = getAlphaAtUV(material.map, uv);

            if (alpha > 0.1) { // Alpha threshold for click detection
                clickedObject = object;
                break; // Found a clickable opaque part, stop searching
            }
        }
        else if (material && !material.transparent) {
            // For opaque materials, any intersect means it's clickable
            clickedObject = object;
            break; // Found a clickable opaque part, stop searching
        }
    }

    if (clickedObject) {

        // Skip depth cycling for non-draggable elements or those with special handling
        if (clickedObject === backgroundMesh || clickedObject === rightEyeRedactionRect || clickedObject === leftEyeRedactionRect || clickedObject === marqueeTextMesh || clickedObject === biometricMarqueeTextMesh || clickedObject === bloodTextMesh || clickedObject === redactedGlitchTextMesh) { // Added redactedGlitchTextMesh
            return;
        }

        // Cycle through depth levels
        let currentLayer = clickedObject.userData.currentLayer || 1;
        currentLayer--; // Move backward one level
        if (currentLayer < 1) { // If it goes below 1
            currentLayer = totalDepthLayers; // Wrap around to the highest layer
        }
        clickedObject.userData.currentLayer = currentLayer;
        clickedObject.position.z = (currentLayer - 1) * depthStep;

        // --- NEW DRONE LOGIC: Toggle texture and resize ---
        if (clickedObject.userData.id && clickedObject.userData.id.startsWith('drone')) {
            const originalTexture = clickedObject.userData.originalTexture;
            const blueOrigin = blueOriginTexture;
            let targetTexture;
            let targetUrl;

            // Determine the next texture to use
            if (clickedObject.userData.currentTexture === blueOrigin) {
                targetTexture = originalTexture;
                targetUrl = URL_DRONE;
            } else {
                targetTexture = blueOrigin;
                targetUrl = URL_BLUE_ORIGIN;
            }

            // 1. Apply the new texture
            clickedObject.material.map = targetTexture;
            clickedObject.userData.currentTexture = targetTexture; // Update current texture reference
            
            // 2. Calculate new dimensions based on the target texture's aspect ratio
            const currentHeight = clickedObject.userData.initialScale.height; // Use the original drone height as the anchor
            const newAspectRatio = targetTexture.image.width / targetTexture.image.height;
            const newWidth = currentHeight * newAspectRatio;

            // 3. Update geometry (dispose old one first)
            clickedObject.geometry.dispose();
            clickedObject.geometry = new THREE.PlaneGeometry(newWidth, currentHeight);
            
            // 4. Update the initialAssetConfigs array to reflect the new texture, so it persists on reset
            const configIndex = initialAssetConfigs.findIndex(config => config.id === clickedObject.userData.id);
            if (configIndex !== -1) {
                initialAssetConfigs[configIndex].currentTextureUrl = targetUrl;
            }
        }
        // --- END NEW DRONE LOGIC ---

        // Update redaction rectangle Z position if the clicked object is an eye
        if (clickedObject === rightEyeMesh) {
            if (rightEyeRedactionRect) {
                rightEyeRedactionRect.position.z = clickedObject.position.z + (1.5 * depthStep);
            }
        }
        else if (clickedObject === leftEyeMesh) {
            if (leftEyeRedactionRect) {
                leftEyeRedactionRect.position.z = clickedObject.position.z + (1.5 * depthStep);
            }
        }

        console.log(`Object moved to layer: ${currentLayer}, Z-position: ${clickedObject.position.z}`);
    }
}

// Ease-in-out function
function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function startCameraAnimation(currentTime) {
    if (!cameraAnimationActive || cameraAnimationTargets.length === 0) return;

    // Store current camera state as the start for the next animation segment
    cameraPreviousPos.copy(camera.position);
    cameraPreviousLookAt.copy(controls.target);
    cameraAnimationStartTime = currentTime;

    let duration = 0;
    if (cameraAnimationState === 'exploring') {
        duration = cameraExplorationDuration;
    }
    else if (cameraAnimationState === 'returningToGlobalStart') {
        duration = cameraReturnDuration;
    }

    // Filter out 'samAltmanGrid' images from potential targets
    const validTargets = cameraAnimationTargets.filter(obj => !obj.userData.id.startsWith('samAltmanGrid'));

    if (validTargets.length === 0) {
        console.warn("No valid camera animation targets found (excluding 'samAltmanGrid' images).");
        cameraAnimationActive = false;
        effectControls.cameraAnimation = false;
        updateUIButtonState('cameraAnimation', false);
        controls.enabled = true;
        return;
    }

    if (cameraAnimationState === 'returningToGlobalStart' || assetsVisitedCount >= ASSETS_PER_GLOBAL_RETURN) {
        cameraAnimationState = 'exploring';
        assetsVisitedCount = 0;

        // Pick a random target for the next exploration from validTargets
        let newTarget;
        do {
            newTarget = validTargets[Math.floor(Math.random() * validTargets.length)];
        } while (newTarget === cameraTargetObject && validTargets.length > 1);
        cameraTargetObject = newTarget;

        // Calculate end position and lookAt based on the target object
        const targetPos = cameraTargetObject.position;
        const targetBounds = new THREE.Box3().setFromObject(cameraTargetObject);
        const center = targetBounds.getCenter(new THREE.Vector3());
        const size = targetBounds.getSize(new THREE.Vector3());

        const fovRad = THREE.MathUtils.degToRad(camera.fov);
        const baseDistance = Math.max(size.x, size.y) / (2 * Math.tan(fovRad / 2));

        const minZOffset = baseDistance * 0.8;
        const maxZOffset = baseDistance * 1.5;
        const randomZOffset = minZOffset + (Math.random() * (maxZOffset - minZOffset));

        const lateralOffsetRange = baseDistance * 0.5;
        const randomOffsetX = (Math.random() - 0.5) * lateralOffsetRange;
        const randomOffsetY = (Math.random() - 0.5) * lateralOffsetRange;

        cameraCurrentTargetPos.set(
            center.x + randomOffsetX,
            center.y + randomOffsetY,
            targetPos.z + randomZOffset
        );

        cameraCurrentTargetLookAt.copy(center);

        cameraCurrentTargetPos.z = THREE.MathUtils.clamp(cameraCurrentTargetPos.z, -5, 15);

    } else { // Continue exploring
        cameraAnimationState = 'exploring';
        assetsVisitedCount++;

        // Pick a random target, ensuring it's not the same as the previous one if possible
        let newTarget;
        do {
            newTarget = validTargets[Math.floor(Math.random() * validTargets.length)];
        } while (newTarget === cameraTargetObject && validTargets.length > 1);
        cameraTargetObject = newTarget;

        // Calculate end position and lookAt based on the target object
        const targetPos = cameraTargetObject.position;
        const targetBounds = new THREE.Box3().setFromObject(cameraTargetObject);
        const center = targetBounds.getCenter(new THREE.Vector3());
        const size = targetBounds.getSize(new THREE.Vector3());

        // Determine a suitable base distance to frame the object based on its size and camera FOV
        const fovRad = THREE.MathUtils.degToRad(camera.fov);
        const baseDistance = Math.max(size.x, size.y) / (2 * Math.tan(fovRad / 2));

        // Introduce randomness to the Z-distance from the target object
        const minZOffset = baseDistance * 0.8;
        const maxZOffset = baseDistance * 1.5;
        const randomZOffset = minZOffset + (Math.random() * (maxZOffset - minZOffset));

        // Set a random offset around the target object for camera position in X and Y
        const lateralOffsetRange = baseDistance * 0.5;
        const randomOffsetX = (Math.random() - 0.5) * lateralOffsetRange;
        const randomOffsetY = (Math.random() - 0.5) * lateralOffsetRange;

        cameraCurrentTargetPos.set(
            center.x + randomOffsetX,
            center.y + randomOffsetY,
            targetPos.z + randomZOffset
        );

        cameraCurrentTargetLookAt.copy(center);

        // Clamp cameraCurrentTargetPos.z to be within reasonable bounds for the scene
        cameraCurrentTargetPos.z = THREE.MathUtils.clamp(cameraCurrentTargetPos.z, -5, 15);
    }
}

function updateCameraAnimation(currentTime) {
    if (cameraAnimationState === 'idle' || !cameraAnimationActive) return;

    const elapsed = currentTime - cameraAnimationStartTime;

    let duration = 0;
    if (cameraAnimationState === 'exploring') {
        duration = cameraExplorationDuration;
    }
    else if (cameraAnimationState === 'returningToGlobalStart') {
        duration = cameraReturnDuration;
    }

    let t = Math.min(1, elapsed / duration);
    t = easeInOutCubic(t);

    camera.position.lerpVectors(cameraPreviousPos, cameraCurrentTargetPos, t);
    controls.target.lerpVectors(cameraPreviousLookAt, cameraCurrentTargetLookAt, t);

    if (elapsed >= duration) {
        // If returning to global start, then after completion, start a new exploration cycle
        if (cameraAnimationState === 'returningToGlobalStart') {
            cameraAnimationState = 'exploring';
            assetsVisitedCount = 0;
        }
        startCameraAnimation(currentTime);
    }
    camera.lookAt(controls.target);
}

function animate(currentTime) {
    requestAnimationFrame(animate);

    // Apply Y-rotation if explicitly enabled
    if (effectControls.yRotation) {
        // Ensure camera animation is turned off if Y-rotation is active
        if (cameraAnimationActive) {
            cameraAnimationActive = false;
            updateUIButtonState('cameraAnimation', false);
        }
        controls.enabled = false;
        const convergencePoint = new THREE.Vector3(0, 0, (1 - 1) * depthStep);
        camera.position.x = yBounceInitialCameraX + yBounceRangeX * Math.sin(currentTime * yBounceSpeed);
        camera.position.y = yBounceInitialCameraY;
        camera.position.z = yBounceInitialCameraZ;
        camera.lookAt(convergencePoint);
    }

    // Apply Camera Animation if explicitly enabled
    if (cameraAnimationActive) {
        // Ensure Y-rotation is turned off if camera animation is active
        if (effectControls.yRotation) {
            effectControls.yRotation = false;
            updateUIButtonState('yRotation', false);
        }
        controls.enabled = false;
        updateCameraAnimation(currentTime);
    } else if (!effectControls.yRotation) {
        controls.update();
    }

    // Update drone hovering animation for all drones
    droneMeshes.forEach(drone => {
        // Only apply hover animation if the drone is not currently being dragged
        if (drone !== selectedObject && drone.userData.droneInitialY !== undefined) {
            
            const phase = drone.userData.droneHoverPhase || 0;
            const amp = drone.userData.droneHoverAmplitude || DRONE_HOVER_AMPLITUDE;
            const speed = drone.userData.droneHoverSpeed || DRONE_HOVER_SPEED;

            // Apply Y-axis hover animation around its initial Y position
            drone.position.y = drone.userData.droneInitialY + Math.sin(currentTime * speed * 0.001 + phase) * amp;
            
            // Apply X-axis drift/hover around its initial X position
            // Use a different frequency and amplitude for X to make movement unique
            const xAmp = amp * 0.5; // Smaller X movement
            const xSpeed = speed * 0.7; // Slower X movement
            const xPhase = phase + Math.PI / 2; // Offset phase for different timing
            const xInitial = drone.userData.droneInitialX; // Use initial X center
            drone.position.x = xInitial + Math.sin(currentTime * xSpeed * 0.001 + xPhase) * xAmp;
        }
    });

    // Update marquee text scrolling
    if (effectControls.xray) { // Marquee text is now only tied to XRAY effect
        marqueeScrollOffset -= MARQUEE_SCROLL_SPEED;
        // Reset offset when one full set of lines has scrolled off
        if (marqueeScrollOffset <= -MARQUEE_LINE_HEIGHT * MARQUEE_TOTAL_LINES) {
            marqueeScrollOffset = 0;
        }
        updateMarqueeTexture();
    }

    // Update biometric marquee text scrolling
    if (effectControls.biometricMarquee || effectControls.og || effectControls.hacker || effectControls.surveillance || effectControls.greed) { // Update if either biometric or OG or HACKER or SURVEILLANCE or GREED is active
        biometricMarqueeScrollOffset -= BIOMETRIC_MARQUEE_SCROLL_SPEED;
        if (biometricMarqueeScrollOffset <= -BIOMETRIC_MARQUEE_LINE_HEIGHT * BIOMETRIC_MARQUEE_TOTAL_LINES) {
            biometricMarqueeScrollOffset = 0;
        }
        updateBiometricMarqueeTexture(currentTime);
    }

    // Update blood text scrolling
    if (effectControls.bloodText) {
        bloodScrollOffset -= BLOOD_TEXT_SCROLL_SPEED;
        const singleSetHeight = BLOOD_TEXT_LINE_HEIGHT * BLOOD_TEXT_TOTAL_LINES;

        // When the first set of phrases has scrolled completely off the top of the canvas,
        // wrap it around to the bottom, effectively creating a continuous loop.
        if (bloodScrollOffset <= -singleSetHeight) {
            bloodScrollOffset += singleSetHeight * 3; // Move it to the bottom of the second set
            shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]); // Reshuffle phrases on loop
        }

        updateBloodTextTexture();
    }

    // Update redacted glitch text scrolling
    if (effectControls.redactedGlitch) {
        redactedGlitchScrollOffset -= REDACTED_GLITCH_SCROLL_SPEED;
        const singleSetHeight = REDACTED_GLITCH_LINE_HEIGHT * REDACTED_GLITCH_TOTAL_LINES;
        if (redactedGlitchScrollOffset <= -singleSetHeight) {
            redactedGlitchScrollOffset = 0;
            // Re-initialize redaction patterns when the text loops
            initializeRedactedGlitchPhraseData();
        }
        updateRedactedGlitchTexture();
    }

    composer.render();
}

init();
animate();

// Expose for dae hooks
setTimeout(function () {
    window.animate = typeof animate == "function" ? animate : () => { };
    window.camera = typeof camera != "undefined" ? camera : undefined;
    window.renderer = typeof renderer != "undefined" ? renderer : undefined;
    window.scene = typeof scene != "undefined" ? scene : undefined;
    window.composer = typeof composer != "undefined" ? composer : undefined;
}, 1000)

    // Expose for dae hooks
    setTimeout(function() {
      window.animate = typeof animate == "function" ? animate : () => {};
      window.camera = typeof camera != "undefined" ? camera : undefined;
      window.renderer = typeof renderer != "undefined" ? renderer : undefined;
      window.scene = typeof scene != "undefined" ? scene : undefined;
      window.composer = typeof composer != "undefined" ? composer : undefined;
    }, 1000)
  </script>

  <!-- ─── EXPORT PANEL HTML ─── -->
  <button id="submit-overlord-btn">SUBMIT</button>

  <div id="export-panel">
    <div class="panel-title">EXPORT</div>

    <div class="export-row" style="display:none;">
      <label>Format</label>
      <select id="export-format">
        <option value="png">PNG</option>
      </select>
    </div>

    <!-- Video duration row (hidden — PNG only) -->
    <div class="export-row" id="duration-row" style="display:none;">
      <label>Duration (sec)</label>
      <input type="number" id="export-duration" value="5" min="1" max="60" step="1">
    </div>

    <button class="export-btn" id="export-start-btn">EXPORT</button>
    <div class="status-line" id="export-status"></div>
  </div>

  <!-- ─── POST TO X MODAL ─── -->
  <div id="post-modal">
    <div id="post-modal-content">
      <h2>Share your overlord</h2>
      <p style="margin: 0 0 20px 0; font-size: 12px; color: #aaa;">Attach your downloaded file before posting</p>
      <button id="post-modal-btn">POST TO X</button>
      
      <div style="margin: 20px 0; color: #666; font-size: 11px; text-align: center;">
        ── OR ──
      </div>
      
      <button id="judgment-btn" style="
        background: #000;
        color: #fff;
        border: 2px solid #fff;
        padding: 12px 30px;
        font-family: monospace;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        letter-spacing: 1px;
        transition: background 0.2s;
        width: 100%;
      ">SUBMIT TO JUDGMENT PROTOCOL</button>
      
      <p style="margin: 15px 0 0 0; font-size: 10px; color: #888; line-height: 1.4;">
        Submit your capture for collector review.<br>
        Top submissions will be minted as official subseries.
      </p>
    </div>
  </div>

  <!-- ─── EXPORT ENGINE ─── -->
  <script>
  (function(){
    function setupExport() {
    // ── Detect if embedded in iframe ──
    const isEmbedded = (window.self !== window.top);
    
    // ── DOM refs ──
    const toggle    = document.getElementById('export-toggle');
    if (!toggle) { setTimeout(setupExport, 50); return; } // wait for init() to create it
    
    // If embedded, hide RCS button and SUBMIT TO THE OVERLORD button, then exit
    if (isEmbedded) {
      toggle.style.display = 'none';
      const modal = document.getElementById('post-modal');
      if (modal) modal.style.display = 'none';
      const submitOverlordBtn = document.getElementById('submit-overlord-btn');
      if (submitOverlordBtn) submitOverlordBtn.style.display = 'none';
      return;
    }
    
    const panel     = document.getElementById('export-panel');
    const fmtSel    = document.getElementById('export-format');
    const durInput  = document.getElementById('export-duration');
    const startBtn  = document.getElementById('export-start-btn');
    const status    = document.getElementById('export-status');
    const durRow    = document.getElementById('duration-row');
    const modal     = document.getElementById('post-modal');
    const modalBtn  = document.getElementById('post-modal-btn');

    // ── Show POST TO X modal ──
    function showPostModal() {
      modal.classList.add('open');
      // Close export panel
      panel.classList.remove('open');
    }

    // Wire modal button to open Twitter compose page with pre-filled text
    modalBtn.onclick = () => {
      const text = encodeURIComponent('Know your overlord. #KnowYourOverlord\nTech Epochalypse by @Coldie');
      window.open(`https://x.com/intent/post?text=${text}`, '_blank');
      // Close modal
      modal.classList.remove('open');
    };

    // Wire judgment protocol button to open Airtable form
    const judgmentBtn = document.getElementById('judgment-btn');
    judgmentBtn.onclick = () => {
      window.open('https://airtable.com/app28BSDaZwDpDw4m/pagUJlx4mF1vkSgO4/form', '_blank');
      // Close modal
      modal.classList.remove('open');
    };

    // Close modal on background click
    modal.onclick = (e) => {
      if (e.target === modal) modal.classList.remove('open');
    };

    // ── Toggle panel ──
    toggle.onclick = (e) => {
      e.stopPropagation();
      if (panel.classList.contains('open')) {
        panel.classList.remove('open');
      } else {
        // Position panel directly below the EXPORT button
        const rect = toggle.getBoundingClientRect();
        panel.style.top = (rect.bottom + 4) + 'px';
        panel.style.left = rect.left + 'px';
        panel.classList.add('open');
      }
    };
    document.addEventListener('click', (e) => {
      if (!panel.contains(e.target) && e.target !== toggle) panel.classList.remove('open');
    });

    // ── SUBMIT YOURSELF button — capture PNG then show post modal ──
    const submitOverlordBtn = document.getElementById('submit-overlord-btn');
    submitOverlordBtn.onclick = (e) => {
      e.stopPropagation();
      exportPNG();
    };

    // ── Format is PNG-only, duration row stays hidden ──
    fmtSel.onchange = () => {
      durRow.style.display = 'none';
    };

    // ── Helpers ──
    function setStatus(msg, cls) {
      status.textContent = msg;
      status.className = 'status-line' + (cls ? ' ' + cls : '');
    }
    function lockUI(on) {
      startBtn.disabled = on;
      fmtSel.disabled   = on;
      durInput.disabled  = on;
    }
    function triggerDownload(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a   = document.createElement('a');
      a.href    = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }
    // Wait for window.renderer to be available (exposed after 1 s by the app)
    function getRenderer() {
      return new Promise((resolve) => {
        const check = () => {
          if (window.renderer && window.renderer.domElement) resolve(window.renderer);
          else setTimeout(check, 100);
        };
        check();
      });
    }

    // ── Gallery API endpoint (update after deploying your Cloudflare Worker) ──
    const GALLERY_API = window.GALLERY_API_URL || '';

    // ── Save to community gallery via Cloudflare R2 ──
    function saveToGallery(canvas) {
      if (!GALLERY_API) {
        console.warn('Gallery API not configured — set window.GALLERY_API_URL');
        return;
      }
      try {
        const thumbCanvas = document.createElement('canvas');
        const MAX = 1200;
        const scale = Math.min(MAX / canvas.width, MAX / canvas.height, 1);
        thumbCanvas.width = Math.round(canvas.width * scale);
        thumbCanvas.height = Math.round(canvas.height * scale);
        const ctx = thumbCanvas.getContext('2d');
        ctx.drawImage(canvas, 0, 0, thumbCanvas.width, thumbCanvas.height);

        thumbCanvas.toBlob(async (blob) => {
          if (!blob) return;
          const form = new FormData();
          form.append('image', blob, 'export.jpg');
          form.append('overlord', 'jeff-bezos');
          try {
            const res = await fetch(GALLERY_API + '/upload', { method: 'POST', body: form });
            if (!res.ok) console.warn('Gallery upload response:', res.status);
          } catch (e) {
            console.warn('Gallery upload failed:', e);
          }
        }, 'image/jpeg', 0.85);
      } catch (e) {
        console.warn('Gallery save failed:', e);
      }
    }

    // ── PNG export ──
    async function exportPNG() {
      setStatus('Capturing…', 'active');
      lockUI(true);
      const r = await getRenderer();
      // Force a fresh render so the buffer has the current frame
      if (window.composer) {
        window.composer.render();
      } else if (window.scene && window.camera) {
        r.render(window.scene, window.camera);
      }
      r.domElement.toBlob((blob) => {
        if (blob) {
          triggerDownload(blob, 'jeff-bezos-coldie.png');
          saveToGallery(r.domElement);
          setStatus('PNG saved ✓ — added to gallery', 'active');
          showPostModal();
        } else {
          setStatus('Capture failed', 'error');
        }
        lockUI(false);
      }, 'image/png');
    }
    // ── Video (MP4) export ──────────────────────────────────────────
    // Strategy: try native H.264 MP4 first (Safari, newer Chrome).
    // If unavailable, record VP9/VP8 WebM and re-mux into an MP4 container
    // so the .mp4 extension and container are always correct for Twitter/X.
    async function exportVideo() {
      const duration = parseInt(durInput.value) * 1000; // ms

      const r = await getRenderer();
      const canvas = r.domElement;
      const stream = canvas.captureStream(30);

      // Codec priority: H.264 MP4 first, then WebM fallbacks
      const candidates = [
        'video/mp4;codecs=avc1.42E01E',
        'video/mp4;codecs=avc1.640028',
        'video/mp4',
        'video/webm;codecs=vp9',
        'video/webm;codecs=vp8',
        'video/webm'
      ];
      let usedMime = '';
      for (const m of candidates) {
        if (MediaRecorder.isTypeSupported(m)) { usedMime = m; break; }
      }
      if (!usedMime) { setStatus('No supported codec found', 'error'); return; }

      const nativeMp4 = usedMime.startsWith('video/mp4');

      const chunks = [];
      const mr = new MediaRecorder(stream, { mimeType: usedMime, videoBitsPerSecond: 2500000 });

      lockUI(true);
      startBtn.classList.add('recording');
      setStatus(`Recording… ${duration/1000}s`, 'active');

      mr.ondataavailable = (e) => { if (e.data.size > 0) chunks.push(e.data); };

      mr.onstop = async () => {
        try {
          if (nativeMp4) {
            // Browser produced a native MP4 – download directly
            const blob = new Blob(chunks, { type: 'video/mp4' });
            triggerDownload(blob, 'jeff-bezos-coldie.mp4');
            setStatus(`MP4 saved ✓  (${(blob.size/1024/1024).toFixed(2)} MB)`, 'active');
            showPostModal();
          } else {
            // Recorded WebM – wrap it inside an MP4 container
            setStatus('Muxing to MP4…', 'active');
            // Merge all chunks into one Uint8Array
            const arrays = [];
            for (const c of chunks) {
              const buf = await c.arrayBuffer();
              arrays.push(new Uint8Array(buf));
            }
            let totalLen = 0;
            for (const a of arrays) totalLen += a.length;
            const payload = new Uint8Array(totalLen);
            let off = 0;
            for (const a of arrays) { payload.set(a, off); off += a.length; }

            // Build a minimal but valid fragmented MP4 shell
            const mp4 = buildMP4(payload, duration, canvas.width, canvas.height);
            const blob = new Blob([mp4], { type: 'video/mp4' });
            triggerDownload(blob, 'jeff-bezos-coldie.mp4');
            setStatus(`MP4 saved ✓  (${(blob.size/1024/1024).toFixed(2)} MB)`, 'active');
            showPostModal();
          }
        } catch (err) {
          // Ultimate fallback: save raw recording as-is
          console.error('MP4 mux error', err);
          const ext  = nativeMp4 ? 'mp4' : 'webm';
          const blob = new Blob(chunks, { type: usedMime });
          triggerDownload(blob, `jeff-bezos-coldie.${ext}`);
          setStatus(`Saved as .${ext} (mux failed)`, 'active');
        }
        lockUI(false);
        startBtn.classList.remove('recording');
      };

      mr.onerror = () => {
        setStatus('Recording failed', 'error');
        lockUI(false);
        startBtn.classList.remove('recording');
      };

      // Save a gallery thumbnail from the first frame
      saveToGallery(canvas);

      mr.start(100); // flush data every 100 ms
      setTimeout(() => {
        mr.stop();
        stream.getTracks().forEach(t => t.stop());
      }, duration);
    }

    // ── Minimal fragmented-MP4 builder ──────────────────────────────
    // Produces ftyp + moov + mdat.  The mdat is the raw recorded bitstream;
    // the moov declares a single video track with no sample table entries
    // (valid for fragmented MP4).  Twitter's transcoder probes the actual
    // codec inside mdat, so this works whether the inner data is H.264 or VP9.
    function buildMP4(payload, durationMs, width, height) {
      // Helpers
      function u32(v) { return [(v>>>24)&0xFF,(v>>>16)&0xFF,(v>>>8)&0xFF,v&0xFF]; }
      function u16(v) { return [(v>>>8)&0xFF, v&0xFF]; }
      function tag(s) { return s.split('').map(c => c.charCodeAt(0)); }

      function box(type, body) {
        const size = 8 + body.length;
        return new Uint8Array([...u32(size), ...tag(type), ...body]);
      }
      function fullBox(type, version, flags, body) {
        const vf = u32((version << 24) | flags);
        return box(type, new Uint8Array([...vf, ...body]));
      }
      function concat(...parts) {
        let len = 0; for (const p of parts) len += p.length;
        const out = new Uint8Array(len);
        let o = 0; for (const p of parts) { out.set(p, o); o += p.length; }
        return out;
      }

      const ts = 1000; // timescale
      const dur = durationMs;

      // ── ftyp ──
      const ftyp = box('ftyp', new Uint8Array([
        ...tag('isom'), ...u32(512),           // major brand + minor version
        ...tag('isom'), ...tag('iso2'), ...tag('mp41') // compatible brands
      ]));

      // ── moov ──
      const mvhd = fullBox('mvhd', 0, 0, new Uint8Array([
        ...u32(0), ...u32(0),        // created / modified
        ...u32(ts), ...u32(dur),     // timescale / duration
        ...u32(0x00010000),          // rate = 1.0
        ...u16(0x0100),              // volume = 1.0
        ...new Uint8Array(10),       // reserved
        // identity matrix
        ...u32(0x00010000),...u32(0),...u32(0),
        ...u32(0),...u32(0x00010000),...u32(0),
        ...u32(0),...u32(0),...u32(0x40000000),
        ...new Uint8Array(24),       // pre_defined
        ...u32(2)                    // next_track_ID
      ]));

      const tkhd = fullBox('tkhd', 0, 3, new Uint8Array([
        ...u32(0), ...u32(0),        // created / modified
        ...u32(1),                   // track_ID
        ...u32(0),                   // reserved
        ...u32(dur),                 // duration
        ...new Uint8Array(8),        // reserved
        ...u16(0), ...u16(0),        // layer / alternate_group
        ...u16(0), ...u16(0),        // volume / reserved
        // identity matrix
        ...u32(0x00010000),...u32(0),...u32(0),
        ...u32(0),...u32(0x00010000),...u32(0),
        ...u32(0),...u32(0),...u32(0x40000000),
        ...u32(width << 16),         // width  16.16
        ...u32(height << 16)         // height 16.16
      ]));

      const mdhd = fullBox('mdhd', 0, 0, new Uint8Array([
        ...u32(0), ...u32(0),
        ...u32(ts), ...u32(dur),
        ...u16(0x55C4),              // language 'und'
        ...u16(0)
      ]));

      const hdlr = fullBox('hdlr', 0, 0, new Uint8Array([
        ...u32(0),                   // pre_defined
        ...tag('vide'),              // handler_type
        ...new Uint8Array(12),       // reserved
        0                            // name (null terminator)
      ]));

      // stsd – one generic visual sample entry
      const sampleEntry = (() => {
        const inner = new Uint8Array([
          0,0, 0,0,0,1,             // reserved(6) + data_ref_index = 1
          ...new Uint8Array(16),     // pre_defined + reserved
          ...u16(width), ...u16(height),
          0x00,0x48,0x00,0x00,      // horiz res 72 dpi
          0x00,0x48,0x00,0x00,      // vert  res 72 dpi
          0,0,0,0,                  // reserved
          0,0,0,1,                  // frame_count
          ...new Uint8Array(32),     // compressor_name
          0,0,0x01,0x18,            // depth
          0xFF,0xFF                 // pre_defined
        ]);
        return box('mp41', inner);   // 'mp41' = generic visual
      })();

      const stsd = fullBox('stsd', 0, 0, new Uint8Array([...u32(1), ...sampleEntry]));
      const stts = fullBox('stts', 0, 0, new Uint8Array([...u32(0)]));
      const stsc = fullBox('stsc', 0, 0, new Uint8Array([...u32(0)]));
      const stsz = fullBox('stsz', 0, 0, new Uint8Array([...u32(0), ...u32(0)]));
      const stco = fullBox('stco', 0, 0, new Uint8Array([...u32(0)]));
      const stbl = box('stbl', concat(stsd, stts, stsc, stsz, stco));

      const vmhd = fullBox('vmhd', 0, 1, new Uint8Array([
        ...u16(0), ...u16(0), ...u16(0), ...u16(0) // graphicsmode + opcolor
      ]));
      const dref  = fullBox('dref', 0, 0, new Uint8Array([...u32(1), ...fullBox('url ', 0, 1, new Uint8Array(0))]));
      const dinf  = box('dinf', dref);
      const minf  = box('minf', concat(vmhd, dinf, stbl));
      const mdia  = box('mdia', concat(mdhd, hdlr, minf));
      const trak  = box('trak', concat(tkhd, mdia));

      // mvex (mandatory for fragmented MP4)
      const trex = fullBox('trex', 0, 0, new Uint8Array([
        ...u32(1), ...u32(1), ...u32(0), ...u32(0), ...u32(0)
      ]));
      const mvex = box('mvex', trex);
      const moov = box('moov', concat(mvhd, trak, mvex));

      // ── mdat ──
      const mdatSize = 8 + payload.length;
      const mdat = new Uint8Array([...u32(mdatSize), ...tag('mdat'), ...payload]);

      return concat(ftyp, moov, mdat);
    }

    // ── Main dispatcher ──
    startBtn.onclick = () => {
      const f = fmtSel.value;
      if      (f === 'png') exportPNG();
      else if (f === 'mp4') exportVideo();
    };
    } // end setupExport
    setupExport();
  })();
  </script>


</body></html>