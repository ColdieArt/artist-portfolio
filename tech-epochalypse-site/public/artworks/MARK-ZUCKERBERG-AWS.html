<!doctype html>
<html lang="en"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/",
        "mediabunny": "https://cdn.jsdelivr.net/npm/mediabunny@1.25.8/+esm"
      }
    }
  </script>
  <style>
    body {
      margin: 0;
      display: flex;
      width: 100vw;
      height: 100vh;
      justify-content: center;
      align-items: center;
      overflow: auto;
      background: transparent;
    }

    main {
      height: 100%;
      display: flex;
      overflow: auto;
      justify-content: center;
      align-items: center;
    }
    
    canvas {
      cursor: grab;
    }
  </style>
  <title>MARK-ZUCKERBERG-AWS - MATCH CODE | Made on juno.transient.xyz</title>
</head>
<body>
  
    
  <script type="module">
    import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';

let camera, scene, renderer, controls, composer;
let raycaster, mouse;
let draggableObjects = [];
let selectedObject = null;
let offset = new THREE.Vector3();
let initialObjectZ = 0; // Store the initial Z-position of the selected object

const depthStep = 0.2; // Defines the depth separation between levels
const totalDepthLayers = 20; // Total number of POSITIVE depth layers available (1 to 20)
const totalNegativeLayers = 5; // Total number of NEGATIVE depth layers available (-1 to -5)
const minLayer = -totalNegativeLayers; // -5
const maxLayer = totalDepthLayers; // 20
const totalZLayers = maxLayer - minLayer + 1; // 26 total layers (-5 to 20)

const subLayerOffset = 0.05; // Smaller offset for visual separation within a layer (0.25 levels * depthStep = 0.25 * 0.2 = 0.05)
const zeroParallaxDepth = (5 - 1) * depthStep; // Z-position for level 5

// GLOBAL CONSTANT FIX: Move baseScale outside of init() so it's accessible everywhere
const BASE_SCALE = 0.005;

let isDragging = false; // Flag to indicate if a drag operation in progress
let pointerDownPosition = new THREE.Vector2(); // To store the initial pointer down position
const DRAG_THRESHOLD = 5; // Pixels threshold to consider a move as a drag

let backgroundMesh = null; // To store the background mesh for positioning calculations

// Camera animation variables
let cameraAnimationActive = false;
let cameraAnimationTargets = [];
let currentCameraTarget = null;
let cameraAnimationState = 'idle'; // 'idle', 'exploring', 'returningToGlobalStart'
let cameraAnimationStartTime = 0;
const cameraExplorationDuration = 2500; // 5 seconds for exploring (moving to target) - halved
const cameraReturnDuration = 1250; // 2.5 seconds for returning to start - halved
let cameraPreviousPos = new THREE.Vector3();
let cameraPreviousLookAt = new THREE.Vector3();
let cameraCurrentTargetPos = new THREE.Vector3();
let cameraCurrentTargetLookAt = new THREE.Vector3();
let cameraTargetObject = null;

// New camera animation variables for global return
let initialGlobalCameraPos = new THREE.Vector3();
let initialGlobalCameraLookAt = new THREE.Vector3();
let assetsVisitedCount = 0;
const ASSETS_PER_GLOBAL_RETURN = 6;

// Y-axis bounce animation variables
let yBounceInitialCameraX = 0;
let yBounceInitialCameraY = 0;
let yBounceInitialCameraZ = 0;
const yBounceRangeX = 2.0; // 20% of a reasonable scene width (e.g., 10 units wide scene)
const yBounceSpeed = 0.001; // Speed of the bounce

// Inactivity timer variables
let lastActivityTime = performance.now();
const INACTIVITY_TIMEOUT = 3000; // 3 seconds
let yRotationStartTime = 0; // New: To track when Y-rotation started
const Y_ROTATION_DURATION_BEFORE_CAM_ANIM = 10000; // 10 seconds

// Redaction rectangles
let rightEyeRedactionRect = null;
let leftEyeRedactionRect = null;
let rightEyeMesh = null; // Globally declare right eye mesh
let leftEyeMesh = null; // Globally globally declare left eye mesh

// Marquee text variables
let marqueeTextMesh;
let marqueeTexture;
let marqueeScrollOffset = 0;
const MARQUEE_LINE_HEIGHT = 180; // Pixels per line, increased by 200%
const MARQUEE_TOTAL_LINES = 10; // Number of lines to display
const MARQUEE_SCROLL_SPEED = 16.0; // Pixels per frame (Increased by 4x from 4.0)
const MARQUEE_PHRASES = [
    "SECURITY BREACH DETECTED",
    "UNAUTHORIZED ACCESS PROHIBITED",
    "SENSITIVE DATA EXPOSED",
    "CLASSIFIED INFORMATION AT RISK",
    "DATA COLLECTION IN PROGRESS",
    "WARNING: PROSECUTION FOR MISUSE",
    "COMPROMISED SYSTEM ALERT",
    "INTELLIGENCE GATHERING ACTIVE",
    "MONITORING ALL COMMUNICATIONS",
    "EVIDENCE LOGGING INITIATED",
    "ACCESS DENIED - LEVEL 5 REQUIRED",
    "BIOMETRIC SCAN INITIATED",
    "ENCRYPTED CHANNEL ESTABLISHED",
    "ANOMALY DETECTED",
    "USE LEVERAGE",
    "REDACTED FOR YOUR PROTECTION",
    "SYSTEM INTEGRITY COMPROMISED",
    "NETWORK INTRUSION DETECTED",
    "DIGITAL FOOTPRINT TRACED",
    "PRIVACY VIOLATION IMMINENT",
    "DATA EXFILTRATION WARNING",
    "LIQUIDATE AT ALL COSTS",
    "SURVEILLANCE ACTIVE",
    "NON-COMPLIANCE PENALTIES APPLY",
    "INFORMATION HARVESTING IN PROGRESS",
    "CONFIDENTIALITY BREACH",
    "ALERT: MALWARE DETECTED",
    "INITIATING PROTOCOL SIGMA",
    "ACCESS LOGS REVIEWED",
    "TRACEABILITY ENABLED",
    "WARNING: PII EXPOSURE"
];

// New biometric marquee variables
let biometricMarqueeTextMesh;
let biometricMarqueeTexture;
let biometricMarqueeScrollOffset = 0;
const BIOMETRIC_MARQUEE_LINE_HEIGHT = 100; // Smaller font size for biometric data
const BIOMETRIC_MARQUEE_TOTAL_LINES = 15; // More lines for biometric data
const BIOMETRIC_MARQUEE_SCROLL_SPEED = 4.0; // Slower than main marquee (changed from 8.0 to 4.0)
const BIOMETRIC_PHRASES = [
    "HEART RATE: 72 BPM",
    "BLOOD PRESSURE: 120/80 mmHg",
    "TEMPERATURE: 98.6 F (37.0 C)",
    "DNA SEQUENCE: ATGCAGTACTGCA...",
    "RETINAL SCAN: POSITIVE MATCH",
    "VOICE PRINT: IDENTIFIED",
    "NEURAL ACTIVITY: ELEVATED",
    "BRAINWAVES: ALPHA DOMINANT",
    "SKELETAL DENSITY: NORMAL",
    "ORGAN FUNCTION: OPTIMAL",
    "ELECTROLYTES: BALANCED",
    "METABOLIC RATE: AVERAGE",
    "GENETIC MARKERS: PRESENT",
    "IMMUNE RESPONSE: ACTIVE",
    "CELLULAR REGENERATION: HIGH",
    "NEUROTRANSMITTER LEVELS: STABLE",
    "ENDOCRINE SYSTEM: FUNCTIONAL",
    "RESPIRATORY RATE: 16 BREATHS/MIN",
    "PULSE OXIMETRY: 98% SpO2",
    "GLUCOSE LEVELS: 90 mg/dL",
    "ADRENAL OUTPUT: NORMAL",
    "CIRCADIAN RHYTHM: REGULAR",
    "COGNITIVE PROCESSING: RAPID",
    "EMOTIONAL STATE: NEUTRAL",
    "SLEEP CYCLE: REM STAGE ACTIVE",
    "MUSCLE TENSION: LOW",
    "HORMONE PROFILE: STABLE",
    "TOXIN LEVELS: UNDETECTED",
    "ALLERGEN RESPONSE: NEGATIVE",
    "PAIN RECEPTORS: INACTIVE"
];

const DIAGNOSTIC_CAPTIONS = [
    "DATA STREAM: STABLE",
    "ANALYSIS: COMPLETE",
    "STATUS: NORMALIZED",
    "TREND: OPTIMAL",
    "PREDICTION: LOW RISK",
    "ALERT: NONE",
    "READOUT: POSITIVE",
    "DIAGNOSIS: CLEAR",
    "VALIDATION: SUCCESS",
    "INTEGRITY: HIGH",
    "ACCESS: GRANTED",
    "PROCESSING: REAL-TIME",
    "CONNECTION: SECURE",
    "SYSTEM: ONLINE",
    "MODE: ACTIVE"
];

let biometricAnimationState = {
    graphData: [],
    sinePhase: 0,
    heartbeatPhase: 0,
    heartbeatPulse: false,
    lastHeartbeatTime: 0
};

// New Blood Text variables
let bloodTextMesh;
let bloodTexture;
let bloodScrollOffset = 0;
const BLOOD_TEXT_FONT_SIZE = 180; // Extremely large font size
const BLOOD_TEXT_LINE_HEIGHT = BLOOD_TEXT_FONT_SIZE * 1.2; // Line height for spacing
const BLOOD_TEXT_TOTAL_LINES = 22; // Number of lines to display
const BLOOD_TEXT_SCROLL_SPEED = 7.0; // Moderate scroll speed
let shuffledBloodPhrases = []; // To store the shuffled phrases
const BLOOD_TEXT_PHRASES = [
    "BIAS REINFORCEMENT",
    "DARK ECONOMY",
    "REALITY DISTORTION",
    "EXPLOIT VULNERABILITIES",
    "FEED MANIPULATION",
    "AI SHOCKWAVE",
    "DESIRE TO CONFORM",
    "CONFUSION PERSUASION",
    "DATA PHOTONS",
    "PSYCHOLOGICAL OPERATIONS",
    "GEO-STALKING",
    "DATA MINING",
    "DOPAMINE LOOP",
    "MAGNETIC CONTROL",
    "VULNEARABILITY TRACKING",
    "ENGAGEMENT TRAPS",
    "EXPLOIT HUMAN FLAW",
    "PRIVACY EROSION",
    "ALWAYS-ON LISTENING",
    "PREDICTIVE BEHAVIOR",
    "AMPLIFIED INFLUENCE",
    "LOCATION TRACKING",
    "ECHO CHAMBERING",
    "INSTANT GRATIFICATION",
    "LICK THE BOOT",
    "CRY & BOW",
    "ILLUSION OF CONTROL",
    "COGNITIVE BIAS", 
];

// Redacted Glitch Text variables
let redactedGlitchTextMesh;
let redactedGlitchTexture;
let redactedGlitchScrollOffset = 0;
const REDACTED_GLITCH_FONT_SIZE = 24;
const REDACTED_GLITCH_LINE_HEIGHT = REDACTED_GLITCH_FONT_SIZE * 1.5;
const REDACTED_GLITCH_TOTAL_LINES = 30;
const REDACTED_GLITCH_SCROLL_SPEED = 2.0;
const REDACTED_GLITCH_PHRASES = [
    "PERSONAL IDENTIFIER ACQUIRED",
    "LOCATION TRACKING INITIATED",
    "COMMUNICATION LOGS UPLOADED",
    "BEHAVIORAL PROFILE GENERATED",
    "BIO-METRIC DATA EXTRACTED",
    "FINANCIAL RECORDS ANALYZED",
    "NETWORK ACTIVITY MONITORED",
    "DIGITAL FOOTPRINT TRACED",
    "SENTIMENT ANALYSIS COMPLETE",
    "ACCESS CREDENTIALS COMPROMISED",
    "THREAT ASSESSMENT LEVEL CLASSIFIED",
    "TARGET IDENTIFIED: UNKNOWN",
    "DATA EXFILTRATION PROTOCOL ACTIVE",
    "SURVEILLANCE FEED ACTIVE",
    "USER ACTIVITY RECORDED",
    "PRIVACY SETTINGS OVERRIDDEN",
    "CONNECTION LOGS STORED",
    "SEARCH HISTORY ARCHIVED",
    "PURCHASE PATTERNS LOGGED",
    "EMOTIONAL RESPONSE CAPTURED",
    "NEURAL ACTIVITY MAPPED",
    "GENETIC PREDISPOSITIONS FLAGGED",
    "VULNERABILITY ASSESSMENT COMPLETE",
    "OPERATIONAL STATUS REPORTED",
    "DIRECTIVE ISSUED: INITIATE",
    "STATUS: COMPROMISED",
    "ACTION: REQUIRED",
    "WARNING: ACCESS REVOKED",
    "CONFIDENTIALITY: BREACHED",
    "PROTOCOL: EXECUTED"
];

// New data structure to store redacted words for each phrase
let redactedGlitchPhraseData = []; // Array of objects {text: string, redactedWordIndices: number[], redactionApplied: boolean}

// Define all layer URLs at the top of the script
const URL_THUMB_UP = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/zuckerberg/thumb-up.gif';
const URL_BACKGROUND = '';
const URL_FOREHEAD = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/zuckerberg/Mark-Zuckerberg-Forehead.gif';
const URL_RIGHT_EYE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/zuckerberg/Mark-Zuckerberg-Eye-R.gif';
const URL_MOUTH = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/zuckerberg/Mark-Zuckerberg-Mouth.gif';
const URL_LEFT_EYE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/zuckerberg/Mark-Zuckerberg-Eye-L.gif';
const URL_NOSE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/zuckerberg/Mark-Zuckerberg-nose.gif';
const URL_HAIR = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/zuckerberg/Mark-Zuckerberg-Hair.gif';
const URL_BLUE_BILL = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/zuckerberg/Mark-Zuckerberg-FB-Phone-rev.gif';
const URL_DOGECOIN_ORIGINAL = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/zuckerberg/Mark-Zuckerberg-Meta.gif';
const URL_TESLA_SWAP = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/zuckerberg/Mark-Zuckerberg-FB.gif';
const URL_SIGNATURE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/coldie-sig.gif';
const URL_HEADSET = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/zuckerberg/Mark-Zuckerberg-meta-headset-2.gif';
const URL_ZUCK_PHONE_2 = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/zuckerberg/Mark-Zuckerberg-FB-Phone-2.gif';

// Global references for face meshes to apply lighting/material swap
let faceMeshes = [];

/**
 * Applies texture best practices for color space and filtering.
 * @param {THREE.Texture} texture
 * @param {THREE.WebGLRenderer} renderer
 */
function configureTexture(texture, renderer) {
    texture.colorSpace = THREE.SRGBColorSpace;
    texture.minFilter = THREE.LinearFilter;
    texture.magFilter = THREE.LinearFilter;
    texture.generateMipmaps = false;
    // Anisotropy requires the renderer to be initialized, so we pass it in or use a global reference.
    if (renderer) {
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    }
}

function initializeRedactedGlitchPhraseData() {
    redactedGlitchPhraseData = REDACTED_GLITCH_PHRASES.map(phrase => {
        const words = phrase.split(/(\s+)/).filter(word => word.length > 0); // Split by spaces, keeping spaces
        const numWords = words.filter(word => !/\s+/.test(word)).length; // Count actual words

        const wordIndicesToRedact = [];
        if (numWords > 0 && Math.random() < 0.6) { // 60% chance to redact a line
            const numWordsToRedact = Math.floor(Math.random() * Math.min(3, numWords)) + 1; // Redact 1 to 3 words

            // Find actual word indices
            const actualWordIndices = [];
            for (let i = 0; i < words.length; i++) {
                if (!/\s+/.test(words[i])) {
                    actualWordIndices.push(i);
                }
            }

            if (actualWordIndices.length > 0) {
                const startIndex = Math.floor(Math.random() * Math.max(1, actualWordIndices.length - numWordsToRedact + 1));
                for (let i = 0; i < numWordsToRedact; i++) {
                    if (startIndex + i < actualWordIndices.length) {
                        wordIndicesToRedact.push(actualWordIndices[startIndex + i]);
                    }
                }
            }
        }
        return { text: phrase, redactedWordIndices: wordIndicesToRedact };
    });
}

// Shader definitions
const BrightenShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'brightnessFactor': { value: 1.2 } // Brightness boost for face
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float brightnessFactor;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            // Apply brightness boost to RGB channels
            vec3 brightenedColor = texel.rgb * brightnessFactor;
            gl_FragColor = vec4(brightenedColor, texel.a);
        }
    `
};

const GreyscaleContrastShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'contrast': { value: 1.5 } // Default contrast value
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float contrast;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to greyscale
            // Apply contrast to the greyscale value
            luma = ((luma - 0.5) * contrast) + 0.5;
            // Output greyscale with contrast
            gl_FragColor = vec4(luma, luma, luma, texel.a);
        }
    `
};

const GreyScaleShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            gl_FragColor = vec4(luma, luma, luma, texel.a);
        }
    `
};

const ThresholdShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'threshold': { value: 0.5 }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float threshold;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            gl_FragColor = vec4(step(threshold, luma), step(threshold, luma), step(threshold, luma), 1.0); // Ensure alpha is 1.0 for an opaque threshold effect
        }
    `
};

const DarkShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'threshold': { value: 0.5 }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float threshold;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            // Output a very dark color (0.04 * black) for areas brighter than threshold, and black otherwise.
            // Note: If the input is transparent, the output will also be transparent black.
            gl_FragColor = vec4(vec3(step(threshold, luma) * 0.04), texel.a); 
        }
    `
};

const PixelationShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'resolution': { value: new THREE.Vector2() },
        'pixelSize': { value: 8.0 }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform float pixelSize;
        varying vec2 vUv;
        void main() {
            vec2 uv = vUv;
            vec2 pixelatedUV = floor(uv * resolution / pixelSize) * pixelSize / resolution;
            gl_FragColor = texture2D(tDiffuse, pixelatedUV);
        }
    `
};

const MatrixShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to greyscale
            
            // Simple binary look: quantize to black or green
            vec3 finalColor = mix(vec3(0.0), vec3(0.0, 1.0, 0.0), step(0.5, luma));
            
            // Add a subtle grid/dither to suggest binary elements
            float grid = mod(floor(vUv.x * 100.0) + floor(vUv.y * 100.0), 2.0);
            finalColor = mix(finalColor * 0.8, finalColor, grid);

            gl_FragColor = vec4(finalColor, texel.a);
        }
    `
};

const ASCIIShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'resolution': { value: new THREE.Vector2() },
        'pixelSize': { value: 8.0 }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform float pixelSize;
        varying vec2 vUv;
        void main() {
            vec2 uv = vUv;
            vec2 pixelatedUV = floor(uv * resolution / pixelSize) * pixelSize / resolution;
            vec4 texel = texture2D(tDiffuse, pixelatedUV);
            
            // Convert to luminance
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            
            // Quantize luminance to simulate character density
            // Use a few steps to represent different 'characters'
            float step1 = step(0.25, luma); // Darkest areas
            float step2 = step(0.50, luma); // Mid areas
            float step3 = step(0.75, luma); // Brightest areas
            
            vec3 finalColor;
            if (step3 == 1.0) {
                finalColor = vec3(0.0, 1.0, 0.0); // Brightest green
            } else if (step2 == 1.0) {
                finalColor = vec3(0.0, 0.7, 0.0); // Medium green
            } else if (step1 == 1.0) {
                finalColor = vec3(0.0, 0.4, 0.0); // Dark green
            } else {
                finalColor = vec3(0.0);
            }
            
            gl_FragColor = vec4(finalColor, texel.a);
        }
    `
};

const XRayShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Grayscale
            float invertedLuma = 1.0 - luma; // Invert grayscale
            vec3 xrayColor = vec3(0.0, 0.7, 1.0) * invertedLuma; // Apply a blue/cyan tint
            gl_FragColor = vec4(xrayColor, texel.a);
        }
    `
};

const HeatmapShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float threshold;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to luminance

            vec3 color;
            if (luma < 0.2) { // Darkest areas, deep blue
                color = mix(vec3(0.0, 0.0, 0.2), vec3(0.0, 0.0, 0.8), luma / 0.2);
            } else if (luma < 0.4) { // Blue to Cyan
                color = mix(vec3(0.0, 0.0, 0.8), vec3(0.0, 0.8, 0.8), (luma - 0.2) / 0.2);
            } else if (luma < 0.6) { // Cyan to Green
                color = mix(vec3(0.0, 0.8, 0.8), vec3(0.0, 1.0, 0.0), (luma - 0.4) / 0.2);
            } else if (luma < 0.8) { // Green to Yellow
                color = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), (luma - 0.6) / 0.2);
            } else { // Yellow to Red
                color = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), (luma - 0.8) / 0.2);
            }

            gl_FragColor = vec4(color, texel.a);
        }
    `
};

const BloodShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to luminance

            vec3 color;
            if (luma < 0.2) { // Very dark red to black
                color = mix(vec3(0.0, 0.0, 0.0), vec3(0.3, 0.0, 0.0), luma / 0.2);
            } else if (luma < 0.4) { // Deep red to medium red
                color = mix(vec3(0.3, 0.0, 0.0), vec3(0.7, 0.0, 0.0), (luma - 0.2) / 0.2);
            } else if (luma < 0.6) { // Medium red to bright red
                color = mix(vec3(0.7, 0.0, 0.0), vec3(1.0, 0.1, 0.1), (luma - 0.4) / 0.2);
            } else if (luma < 0.8) { // Bright red to orange-red
                color = mix(vec3(1.0, 0.1, 0.1), vec3(1.0, 0.4, 0.0), (luma - 0.6) / 0.2);
            } else { // Orange-red to yellowish-orange
                color = mix(vec3(1.0, 0.4, 0.0), vec3(1.0, 0.7, 0.2), (luma - 0.8) / 0.2);
            }

            gl_FragColor = vec4(color, texel.a);
        }
    `
};

const CCTVFeedShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'time': { value: 0.0 },
        'resolution': { value: new THREE.Vector2() }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform vec2 resolution;
        varying vec2 vUv;

        float rand(vec2 co) {
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        void main() {
            vec2 uv = vUv;
            vec2 pixelatedUV = floor(uv * resolution / 16.0) * 16.0 / resolution; // Blocky effect

            // Glitch effect: random horizontal displacement and color channel split
            float randomVal = rand(floor(uv * 100.0) + fract(time * 0.1));
            float displacement = (randomVal - 0.5) * 0.05 * sin(time * 10.0 + uv.y * 50.0); // Oscillating displacement

            vec4 colorR = texture2D(tDiffuse, pixelatedUV + vec2(displacement, 0.0));
            vec4 colorG = texture2D(tDiffuse, pixelatedUV);
            vec4 colorB = texture2D(tDiffuse, pixelatedUV - vec2(displacement, 0.0));

            vec4 glitchedColor = vec4(colorR.r, colorG.g, colorB.b, 1.0);

            // Convert glitched color to luminance
            float lumaGlitched = dot(glitchedColor.rgb, vec3(0.299, 0.587, 0.114));
            
            // Apply a slight green tint
            vec3 tintedColor = mix(vec3(lumaGlitched), vec3(0.0, 0.5, 0.0), 0.3);

            // Add scanlines
            float scanline = sin(uv.y * resolution.y * 0.5) * 0.05 + 0.95; // Subtle scanlines
            tintedColor *= scanline;

            // Add subtle noise/static
            float noise = rand(uv + time * 0.01) * 0.1; // Small amount of noise
            tintedColor += noise;

            gl_FragColor = vec4(tintedColor, glitchedColor.a);
        }
    `
};

// UI controls state
const effectControls = {
    greyscale: false,
    threshold: false,
    thresholdValue: 0.4, // Decreased by 20% (0.5 * 0.8 = 0.4)
    shadow: false, // Renamed from 'dark' to 'shadow'
    pixelation: false,
    pixelSize: 8.0,
    glitch: false,
    matrix: false,
    ascii: false,
    xray: false,
    yRotation: false,
    cameraAnimation: false,
    redacted: false,
    redactedGlitch: false,
    heatmap: false,
    blood: false, // New control for BLOOD effect
    cctvFeed: false,
    marqueeText: false,
    biometricMarquee: false, // New control for biometric marquee
    anon: false, // New control for ANON effect
    og: false, // New control for OG effect
    bloodText: false, // New control for blood text
    hacker: false, // New control for HACKER effect
    surveillance: false, // New control for SURVEILLANCE effect
    greed: false // New control for GREED effect
};

let greyscalePass, thresholdPass, darkPass, pixelationPass, glitchPass, matrixPass, asciiPass, xrayPass, heatmapPass, bloodPass, cctvFeedPass;
let brightenShaderMaterial = null; // Global reference for the brighten shader material

let trashButtonElement = null; // Global reference for the trash button UI element
let leftUiContainer = null; // Global reference for the left UI container
let arrowContainer = null; // Global reference for the arrow container

// Array to store initial configurations of assets for reloading
const initialAssetConfigs = [];

// Helper function to update UI button state
const updateUIButtonState = (effectName, isActive) => {
    // Select all buttons with the given data-effect attribute
    const buttons = document.querySelectorAll(`button[data-effect="${effectName}"]`);
    buttons.forEach(button => {
        button.style.borderColor = isActive ? '#4CAF50' : 'white';
    });
};

/**
 * Checks if any post-processing visual effect is currently active.
 * Excludes camera controls, text visibility toggles, and combined effects.
 * @returns {boolean}
 */
function isAnyVisualEffectActive() {
    return effectControls.greyscale ||
           effectControls.threshold ||
           effectControls.shadow ||
           effectControls.pixelation ||
           effectControls.glitch ||
           effectControls.matrix ||
           effectControls.ascii ||
           effectControls.xray ||
           effectControls.redacted || // Redacted is a visual effect (eyes covered)
           effectControls.redactedGlitch ||
           effectControls.heatmap ||
           effectControls.blood ||
           effectControls.cctvFeed ||
           effectControls.anon ||
           effectControls.og || // OG enables multiple visual effects (ascii, heatmap)
           effectControls.hacker || // Hacker controls OG
           effectControls.surveillance || // Surveillance controls heatmap, glitch
           effectControls.greed; // Greed controls blood, bloodText
}

/**
 * Swaps materials on face meshes to apply or remove the brightness boost.
 */
function updateFaceMaterialBrightness() {
    const shouldBrighten = isAnyVisualEffectActive();

    faceMeshes.forEach(mesh => {
        const originalMaterial = mesh.userData.originalMaterial;
        const brightenMaterial = mesh.userData.brightenMaterial;

        if (shouldBrighten && mesh.material !== brightenMaterial) {
            // Apply brightness boost material
            mesh.material = brightenMaterial;
            mesh.material.needsUpdate = true;
        } else if (!shouldBrighten && mesh.material !== originalMaterial) {
            // Revert to original material
            mesh.material = originalMaterial;
            mesh.material.needsUpdate = true;
        }
    });
}


function createTextTexture(text, fontSize = 60, color = 'white', backgroundColor = 'rgba(0,0,0,0.5)', font = 'monospace') {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    context.font = `${fontSize}px ${font}`;
    const metrics = context.measureText(text);
    const textWidth = metrics.width;
    const textHeight = fontSize * 1.2; // Approximate height including line spacing

    canvas.width = textWidth + 20; // Add some padding
    canvas.height = textHeight + 20;

    context.font = `${fontSize}px ${font}`;
    context.fillStyle = backgroundColor;
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = color;
    context.fillText(text, 10, fontSize + 10); // Position text with padding

    const texture = new THREE.CanvasTexture(canvas);
    configureTexture(texture, renderer); // Apply texture settings to canvas texture
    texture.needsUpdate = true;
    return texture;
}

function createMarqueeTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    // Canvas size: large enough to hold multiple repetitions of lines for seamless scrolling
    // Width should be enough for the longest phrase
    let maxWidth = 0;
    context.font = `bold 108px 'Courier New', monospace`; // Increased font size and ASCII style font, now bold
    MARQUEE_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    canvas.width = maxWidth + 50; // Add padding
    canvas.height = MARQUEE_LINE_HEIGHT * (MARQUEE_TOTAL_LINES * 2); // Double the height to allow seamless scrolling

    marqueeTexture = new THREE.CanvasTexture(canvas);
    configureTexture(marqueeTexture, renderer); // Apply texture settings
    marqueeTexture.wrapS = THREE.RepeatWrapping;
    marqueeTexture.wrapT = THREE.RepeatWrapping;
    marqueeTexture.needsUpdate = true;
    return marqueeTexture;
}

function updateMarqueeTexture() {
    if (!marqueeTexture) return;

    const canvas = marqueeTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'rgba(0, 0, 0, 0.0)'; // Transparent background
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `bold 108px 'Courier New', monospace`; // Increased font size and ASCII style font, now bold
    context.fillStyle = 'rgba(255, 255, 255, 0.05)'; // Very faint white text
    context.textAlign = 'center';

    // Calculate the total height of one set of lines
    const singleSetHeight = MARQUEE_LINE_HEIGHT * MARQUEE_TOTAL_LINES;

    // Draw lines, repeating them to create a seamless loop
    for (let i = 0; i < MARQUEE_TOTAL_LINES * 2; i++) { // Draw two sets of lines
        const phraseIndex = i % MARQUEE_PHRASES.length;
        const line = MARQUEE_PHRASES[phraseIndex];

        let yPos = (i * MARQUEE_LINE_HEIGHT) + marqueeScrollOffset;

        // Loop the text when it scrolls off the top
        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 2; // Move it to the bottom of the second set
        }

        context.fillText(line, canvas.width / 2, yPos);
    }

    marqueeTexture.needsUpdate = true;
}

function createBiometricMarqueeTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    let maxWidth = 0;
    // Set a fixed width for the canvas to accommodate graphs/waves
    canvas.width = 1200; // Increased width

    context.font = `bold 36px 'Courier New', monospace`; // Smaller font for biometric data (72 / 2 = 36)
    BIOMETRIC_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    // Ensure canvas width is at least maxWidth + padding, but also allow for fixed size
    canvas.width = Math.max(canvas.width, maxWidth + 50);
    canvas.height = BIOMETRIC_MARQUEE_LINE_HEIGHT * (BIOMETRIC_MARQUEE_TOTAL_LINES * 2);

    biometricMarqueeTexture = new THREE.CanvasTexture(canvas);
    configureTexture(biometricMarqueeTexture, renderer); // Apply texture settings
    biometricMarqueeTexture.wrapS = THREE.RepeatWrapping;
    biometricMarqueeTexture.wrapT = THREE.RepeatWrapping;
    biometricMarqueeTexture.needsUpdate = true;
    return biometricMarqueeTexture;
}

function updateBiometricMarqueeTexture(currentTime) {
    if (!biometricMarqueeTexture) return;

    const canvas = biometricMarqueeTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'rgba(0, 0, 0, 0.0)'; // Transparent background
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `bold 36px 'Courier New', monospace`; // Smaller font for biometric data
    context.textAlign = 'center';

    const singleSetHeight = BIOMETRIC_MARQUEE_LINE_HEIGHT * BIOMETRIC_MARQUEE_TOTAL_LINES;

    // Update biometric animation states (slowed down)
    biometricAnimationState.sinePhase += 0.00125; // Reduced from 0.0025 by 200%
    if (biometricAnimationState.sinePhase > Math.PI * 2) biometricAnimationState.sinePhase -= Math.PI * 2;

    const HEARTBEAT_INTERVAL = 6000; // milliseconds (Increased from 3000 by 200%)
    if (currentTime - biometricAnimationState.lastHeartbeatTime > HEARTBEAT_INTERVAL) {
        biometricAnimationState.heartbeatPulse = true;
        biometricAnimationState.lastHeartbeatTime = currentTime;
    } else {
        biometricAnimationState.heartbeatPulse = false;
    }

    // Generate new graph data periodically or on demand
    if (biometricAnimationState.graphData.length === 0 || Math.random() < 0.01) { // Reduced probability to regenerate graph data
        biometricAnimationState.graphData = [];
        for (let j = 0; j < 20; j++) { // Increased number of data points for more detailed graphs
            biometricAnimationState.graphData.push(Math.random());
        }
    }

    for (let i = 0; i < BIOMETRIC_MARQUEE_TOTAL_LINES * 2; i++) {
        const phraseIndex = i % BIOMETRIC_PHRASES.length;
        const line = BIOMETRIC_PHRASES[phraseIndex];

        let yPos = (i * BIOMETRIC_MARQUEE_LINE_HEIGHT) + biometricMarqueeScrollOffset;

        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 2;
        }

        // Draw the full text first
        context.fillStyle = 'rgba(0, 255, 0, 0.1)'; // Faint green text
        context.fillText(line, canvas.width / 2, yPos);

        // Randomly redact parts of the text
        if (Math.random() < 0.6) { // 60% chance to redact a line
            const words = line.split(' ');
            if (words.length > 1) {
                const wordToRedactIndex = Math.floor(Math.random() * words.length);

                const textBeforeRedaction = words.slice(0, wordToRedactIndex).join(' ');
                const redactedWord = words[wordToRedactIndex];

                // Measure text up to the redacted word to get its starting X position
                const totalTextWidth = context.measureText(line).width;
                const startX = (canvas.width / 2) - (totalTextWidth / 2) + context.measureText(textBeforeRedaction).width;

                // Draw a black rectangle over the selected word
                context.fillStyle = 'black'; // Redaction color
                context.fillRect(startX, yPos - BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.7, context.measureText(redactedWord).width, BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.9);
            }
        }

        // Randomly draw animated biometric data (graphs, sine waves, heartbeat)
        if (Math.random() < 0.4) { // Increased chance to draw an animated element on this line
            const animType = Math.floor(Math.random() * 3); // 0: graph, 1: sine, 2: heartbeat
            const animWidth = 200 * 4; // Increased by 400%
            const animHeight = (BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.8) * 4; // Increased by 400%

            // Randomize X position to space graphs more
            const animX = (canvas.width * 0.05) + (Math.random() * (canvas.width * 0.8 - animWidth));

            // Randomize Y position to place graphs on different levels
            const animY = yPos - (animHeight / 2) + (Math.random() - 0.5) * BIOMETRIC_MARQUEE_LINE_HEIGHT * 1.5;

            context.save();
            context.beginPath();
            context.rect(animX, animY, animWidth, animHeight);
            context.clip(); // Clip drawing to this rectangle

            if (animType === 0) { // Graph
                context.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White color, slightly more opaque
                context.lineWidth = 3; // Thicker lines
                context.moveTo(animX, animY + animHeight); // Start at bottom left
                for (let j = 0; j < biometricAnimationState.graphData.length; j++) {
                    const x = animX + (j / (biometricAnimationState.graphData.length - 1)) * animWidth;
                    const y = animY + animHeight - (biometricAnimationState.graphData[j] * animHeight * (0.8 + 0.2 * Math.sin(currentTime * 0.0005))); // Animated height (speed reduced from 0.001 to 0.0005)
                    context.lineTo(x, y);
                }
                context.stroke();
            } else if (animType === 1) { // Sine Wave
                context.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White color, slightly more opaque
                context.lineWidth = 3; // Thicker lines
                context.moveTo(animX, animY + animHeight / 2 + Math.sin(biometricAnimationState.sinePhase) * animHeight * 0.1); // Initial point with slight offset
                for (let j = 0; j < animWidth; j++) {
                    const x = animX + j;
                    const y = animY + animHeight / 2 + Math.sin((j / animWidth) * Math.PI * 4 + biometricAnimationState.sinePhase) * animHeight * 0.3;
                    context.lineTo(x, y);
                }
                context.stroke();
            } else if (animType === 2) { // Heartbeat
                context.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White color, slightly more opaque
                context.lineWidth = 3; // Thicker lines
                const hbHeight = animHeight * 0.4;
                const hbCenterY = animY + animHeight / 2;

                context.moveTo(animX, hbCenterY);
                context.lineTo(animX + animWidth * 0.1, hbCenterY);
                context.lineTo(animX + animWidth * 0.2, hbCenterY - hbHeight * 0.8); // Q
                context.lineTo(animX + animWidth * 0.25, hbCenterY + hbHeight); // R
                context.lineTo(animX + animWidth * 0.3, hbCenterY - hbHeight * 0.3); // S
                context.lineTo(animX + animWidth * 0.4, hbCenterY); // End of QRS
                context.lineTo(animX + animWidth * 0.6, hbCenterY);
                context.lineTo(animX + animWidth * 0.7, hbCenterY - hbHeight * 0.2); // T wave peak
                context.lineTo(animX + animWidth * 0.8, hbCenterY);
                context.lineTo(animX + animWidth, hbCenterY);
                context.stroke();

                if (biometricAnimationState.heartbeatPulse) {
                    context.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    context.fillRect(animX, animY, animWidth, animHeight);
                }
            }
            context.restore();
        }

        // Add diagnostic text captions in black boxes
        if (Math.random() < 0.3) { // 30% chance to add a diagnostic caption
            const caption = DIAGNOSTIC_CAPTIONS[Math.floor(Math.random() * DIAGNOSTIC_CAPTIONS.length)];
            context.font = `bold 24px 'Courier New', monospace`; // Smaller font for captions (48 / 2 = 24)
            context.textAlign = 'left';
            const captionWidth = context.measureText(caption).width;
            const captionHeight = 24 * 1.2; // Approximate height

            // Position the caption randomly over the line, ensuring it's within bounds
            const captionX = (canvas.width * 0.1) + (Math.random() * (canvas.width * 0.7 - captionWidth));
            const captionY = yPos - (captionHeight / 2) + (Math.random() - 0.5) * (BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.5);

            const padding = 5; // Define padding here
            // Draw black box
            context.fillStyle = 'black';
            context.fillRect(captionX - padding, captionY - captionHeight * 0.7, captionWidth + padding * 2, captionHeight + padding);

            // Draw white text
            context.fillStyle = 'white';
            context.fillText(caption, captionX, captionY);
        }
    }

    biometricMarqueeTexture.needsUpdate = true;
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function createBloodTextTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    let maxWidth = 0;
    context.font = `bold ${BLOOD_TEXT_FONT_SIZE}px 'Impact', sans-serif`;
    BLOOD_TEXT_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    canvas.width = maxWidth + 100; // Add padding
    canvas.height = BLOOD_TEXT_LINE_HEIGHT * (BLOOD_TEXT_TOTAL_LINES * 2); // Double height for scrolling

    bloodTexture = new THREE.CanvasTexture(canvas);
    configureTexture(bloodTexture, renderer); // Apply texture settings
    bloodTexture.wrapS = THREE.RepeatWrapping;
    bloodTexture.wrapT = THREE.RepeatWrapping;
    bloodTexture.needsUpdate = true;
    return bloodTexture;
}

function updateBloodTextTexture() {
    if (!bloodTexture) return;

    const canvas = bloodTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'rgba(0, 0, 0, 0.0)'; // Transparent background
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `bold ${BLOOD_TEXT_FONT_SIZE}px 'Impact', sans-serif`;
    context.fillStyle = 'white'; // White text for contrast
    context.textAlign = 'center';

    const singleSetHeight = BLOOD_TEXT_LINE_HEIGHT * BLOOD_TEXT_TOTAL_LINES;

    // Draw lines, repeating them to create a seamless loop
    for (let i = 0; i < BLOOD_TEXT_TOTAL_LINES * 2; i++) { // Draw two sets of lines
        const phraseIndex = i % shuffledBloodPhrases.length;
        const line = shuffledBloodPhrases[phraseIndex];

        let yPos = (i * BLOOD_TEXT_LINE_HEIGHT) + bloodScrollOffset;

        // When the first set of phrases has scrolled completely off the top of the canvas,
        // wrap it around to the bottom, effectively creating a continuous loop.
        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 3; // Move it to the bottom of the second set
            shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]); // Reshuffle phrases on loop
        }

        context.fillText(line, canvas.width / 2, yPos);
    }

    bloodTexture.needsUpdate = true;
}

function createRedactedGlitchTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    let maxWidth = 0;
    context.font = `${REDACTED_GLITCH_FONT_SIZE}px 'Courier New', monospace`;
    REDACTED_GLITCH_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    canvas.width = maxWidth + 50; // Add padding
    canvas.height = REDACTED_GLITCH_LINE_HEIGHT * (REDACTED_GLITCH_TOTAL_LINES * 2); // Double for seamless scrolling

    redactedGlitchTexture = new THREE.CanvasTexture(canvas);
    configureTexture(redactedGlitchTexture, renderer); // Apply texture settings
    redactedGlitchTexture.wrapS = THREE.RepeatWrapping;
    redactedGlitchTexture.wrapT = THREE.RepeatWrapping;
    redactedGlitchTexture.needsUpdate = true;
    return redactedGlitchTexture;
}

function updateRedactedGlitchTexture() {
    if (!redactedGlitchTexture) return;

    const canvas = redactedGlitchTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    // Fill background with BLACK. When Threshold is applied, black becomes white (1.0) and white becomes black (0.0).
    // This allows the text meshes (which have a black background) to appear white/visible when threshold is on.
    context.fillStyle = 'rgba(0, 0, 0, 1.0)'; // Black background
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `${REDACTED_GLITCH_FONT_SIZE}px 'Courier New', monospace`;
    context.textAlign = 'left';

    const singleSetHeight = REDACTED_GLITCH_LINE_HEIGHT * REDACTED_GLITCH_TOTAL_LINES;

    for (let i = 0; i < REDACTED_GLITCH_TOTAL_LINES * 2; i++) {
        const phraseDataIndex = i % redactedGlitchPhraseData.length; // Use the new data structure
        const phraseData = redactedGlitchPhraseData[phraseDataIndex];
        const line = phraseData.text;
        const redactedWordIndices = phraseData.redactedWordIndices;

        let yPos = (i * REDACTED_GLITCH_LINE_HEIGHT) + redactedGlitchScrollOffset;

        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 2;
        }

        // Draw text in WHITE so it becomes BLACK/hidden with threshold effect
        context.fillStyle = 'white';
        context.fillText(line, 10, yPos + REDACTED_GLITCH_FONT_SIZE); // Add padding

        // Draw redaction bars (black rectangles on black background will appear white with threshold)
        if (redactedWordIndices.length > 0) {
            const words = line.split(/(\s+)/); // Split by one or more spaces, keeping spaces
            let currentX = 10; // Start X for text (accounting for padding)

            for (let j = 0; j < words.length; j++) {
                const word = words[j];
                const wordWidth = context.measureText(word).width;

                if (!/\s+/.test(word) && redactedWordIndices.includes(j)) { // If it's a word and flagged for redaction
                    // Draw a WHITE rectangle over the selected words (will appear BLACK with threshold)
                    context.fillStyle = 'white';
                    context.fillRect(currentX, yPos + REDACTED_GLITCH_FONT_SIZE * 0.2, wordWidth, REDACTED_GLITCH_FONT_SIZE * 0.9);

                    // Optionally draw a border around the redacted area to make it more pronounced
                    context.strokeStyle = 'white'; // White border (will be black with threshold)
                    context.lineWidth = 2;
                    context.strokeRect(currentX, yPos + REDACTED_GLITCH_FONT_SIZE * 0.2, wordWidth, REDACTED_GLITCH_FONT_SIZE * 0.9);
                }
                currentX += wordWidth;
            }
        }
    }

    redactedGlitchTexture.needsUpdate = true;
}

/**
 * Converts a layer number (minLayer to maxLayer) to a Z position.
 * Layer 1 is Z=0.
 * @param {number} layer - The layer number (minLayer to maxLayer).
 * @returns {number} The Z position.
 */
function layerToZ(layer) {
    return (layer - 1) * depthStep;
}

/**
 * Converts a Z position to the nearest layer number.
 * @param {number} z - The Z position.
 * @returns {number} The nearest layer number (minLayer to maxLayer).
 */
function zToLayer(z) {
    let layer = Math.round(z / depthStep) + 1;
    // Clamp the layer number to the defined range
    return THREE.MathUtils.clamp(layer, minLayer, maxLayer);
}

function stopCameraAnimationAndReset() {
    if (cameraAnimationActive || effectControls.yRotation) {
        cameraAnimationActive = false;
        effectControls.cameraAnimation = false;
        effectControls.yRotation = false;

        updateUIButtonState('cameraAnimation', false);
        updateUIButtonState('yRotation', false);

        camera.position.copy(initialGlobalCameraPos);
        controls.target.copy(initialGlobalCameraLookAt);
        camera.lookAt(controls.target);
        controls.enabled = true; // Re-enable orbit controls
        controls.update(); // Ensure controls are updated after manual camera set

        cameraAnimationState = 'idle';
        assetsVisitedCount = 0;
    }
    yRotationStartTime = 0; // Reset Y-rotation auto-start timer on interaction
}

/**
 * Generates a random position within the visible frustum at a given depth level.
 * @param {number} z - The target Z depth.
 * @returns {THREE.Vector3} A random position vector.
 */
function getRandomPosition(z) {
    // Calculate the world dimensions at the target Z depth
    const distance_from_camera = camera.position.z - z;
    const fovRad = THREE.MathUtils.degToRad(camera.fov / 2);
    const world_height = 2 * distance_from_camera * Math.tan(fovRad);
    const world_width = world_height * camera.aspect;

    // Define the boundaries (slightly outside the visible area for objects to drift in)
    const padding = 1.0;
    const maxX = (world_width / 2) + padding;
    const maxY = (world_height / 2) + padding;

    const randomX = (Math.random() * (2 * maxX)) - maxX;
    const randomY = (Math.random() * (2 * maxY)) - maxY;

    return new THREE.Vector3(randomX, randomY, z);
}

function resetPiecesToOriginalPositions() {
    
    // JUNO FIX: Reset the removed flag for all assets so they are reloaded.
    initialAssetConfigs.forEach(config => {
        config.removed = false;
    });

    // Remove all current draggable objects and their associated meshes (like redaction rectangles)
    draggableObjects.forEach(object => {
        scene.remove(object);
        if (object.geometry) object.geometry.dispose();
        if (object.material) {
            if (Array.isArray(object.material)) {
                object.material.forEach(m => m.dispose());
            } else if (!(object.material instanceof THREE.ShaderMaterial)) { // Don't dispose of shared shader material
                object.material.dispose();
            }
        }
    });
    draggableObjects = []; // Clear the array
    cameraAnimationTargets = []; // Clear camera animation targets
    faceMeshes = []; // Clear face meshes array

    // Reset specific global references
    dogecoinRef = null;
    rightEyeMesh = null;
    leftEyeMesh = null;
    if (rightEyeRedactionRect) { scene.remove(rightEyeRedactionRect); rightEyeRedactionRect.geometry.dispose(); rightEyeRedactionRect.material.dispose(); rightEyeRedactionRect = null; }
    if (leftEyeRedactionRect) { scene.remove(leftEyeRedactionRect); leftEyeRedactionRect.geometry.dispose(); leftEyeRedactionRect.material.dispose(); leftEyeRedactionRect = null; }

    // Remove existing text meshes before re-adding to avoid duplicates and ensure clean state
    if (marqueeTextMesh) { scene.remove(marqueeTextMesh); marqueeTextMesh.geometry.dispose(); marqueeTextMesh.material.dispose(); marqueeTextMesh = null; }
    if (biometricMarqueeTextMesh) { scene.remove(biometricMarqueeTextMesh); biometricMarqueeTextMesh.geometry.dispose(); biometricMarqueeTextMesh.material.dispose(); biometricMarqueeTextMesh = null; }
    if (bloodTextMesh) { scene.remove(bloodTextMesh); bloodTextMesh.geometry.dispose(); bloodTextMesh.material.dispose(); bloodTextMesh = null; }
    if (redactedGlitchTextMesh) { scene.remove(redactedGlitchTextMesh); redactedGlitchTextMesh.geometry.dispose(); redactedGlitchTextMesh.material.dispose(); redactedGlitchTextMesh = null; }

    // Turn off all effects on RESET (before re-adding assets)
    turnOffAllEffects();

    // Re-add all assets from their initial configurations
    initialAssetConfigs.forEach(config => {
        // Skip assets marked as removed
        if (config.removed) return;

        const textureLoader = new THREE.TextureLoader();
        let material, geometry, mesh;

        switch (config.type) {
            case 'background':
                // Do not re-add the background mesh if it was removed
                if (backgroundMesh) {
                    scene.remove(backgroundMesh);
                    backgroundMesh = null;
                }
                break;
            case 'image':
                // Only re-add if not a signature image or if it's the *first* signature image
                if (config.id === 'signature') {
                    // Count existing signature images in the scene
                    const existingSignatures = scene.children.filter(child => child.userData.id === 'signature');
                    if (existingSignatures.length >= 1) {
                        // If one signature already exists, skip adding another one
                        return;
                    }
                }

                // Handle multiple instances of the same asset (like thumb-up)
                if (config.instanceCount > 1) {
                    for (let i = 0; i < config.instanceCount; i++) {
                        textureLoader.load(config.url, (texture) => {
                            configureTexture(texture, renderer); // Apply texture settings
                            const currentMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                            // FIX: Use BASE_SCALE constant
                            const initialPlaneWidth = texture.image.width * BASE_SCALE * config.scaleFactor;
                            const initialPlaneHeight = texture.image.height * BASE_SCALE * config.scaleFactor;

                            const geometry = new THREE.PlaneGeometry(initialPlaneWidth, initialPlaneHeight);
                            const mesh = new THREE.Mesh(geometry, currentMaterial);

                            // Calculate random position and depth: between layer minLayer (-5) and maxLayer (20)
                            const randomLayer = Math.floor(Math.random() * totalZLayers) + minLayer; // Range: -5 to 20
                            
                            const randomZ = layerToZ(randomLayer);
                            const randomPos = getRandomPosition(randomZ);

                            mesh.position.copy(randomPos);
                            mesh.rotation.copy(config.initialRotation ? new THREE.Euler().copy(config.initialRotation) : new THREE.Euler());
                            
                            // Store the randomly assigned initial state
                            mesh.userData.currentLayer = randomLayer;
                            mesh.userData.initialPosition = randomPos.clone();
                            mesh.userData.initialLayer = randomLayer;
                            mesh.userData.id = `${config.id}_${i}`; // Unique ID for each instance
                            mesh.userData.originalId = config.id; // Original config ID for interaction
                            mesh.userData.initialScale = { width: initialPlaneWidth, height: initialPlaneHeight };
                            mesh.userData.flipped = false; // Add flip state

                            scene.add(mesh);
                            draggableObjects.push(mesh);
                            cameraAnimationTargets.push(mesh);
                        });
                    }
                    return; // Skip the rest of the switch case for multi-instance assets
                }

                // Handle single instances (original assets)
                textureLoader.load(config.url, (texture) => {
                    configureTexture(texture, renderer); // Apply texture settings
                    let currentMaterial;
                    // Calculate initial dimensions based on config's BASE_SCALE and scaleFactor
                    // FIX: Use BASE_SCALE constant
                    const initialPlaneWidth = texture.image.width * BASE_SCALE * config.scaleFactor;
                    const initialPlaneHeight = texture.image.height * BASE_SCALE * config.scaleFactor;

                    if (config.id === 'dogecoin' && config.url === URL_TESLA_SWAP) {
                        currentMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                    } else {
                        currentMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                    }
                    
                    // Create the brighten material (ShaderMaterial)
                    const brightenMaterial = new THREE.ShaderMaterial({
                        uniforms: {
                            tDiffuse: { value: texture },
                            brightnessFactor: { value: BrightenShader.uniforms.brightnessFactor.value }
                        },
                        vertexShader: BrightenShader.vertexShader,
                        fragmentShader: BrightenShader.fragmentShader,
                        transparent: true,
                        alphaTest: 0.5
                    });


                    geometry = new THREE.PlaneGeometry(initialPlaneWidth, initialPlaneHeight); // Use calculated initial dimensions
                    mesh = new THREE.Mesh(geometry, currentMaterial);
                    mesh.position.copy(new THREE.Vector3().copy(config.initialPosition)); // Fix: Create new Vector3
                    mesh.rotation.copy(config.initialRotation ? new THREE.Euler().copy(config.initialRotation) : new THREE.Euler()); // Apply initial rotation if present
                    mesh.userData.currentLayer = config.initialLayer;
                    mesh.userData.initialPosition = new THREE.Vector3().copy(config.initialPosition);
                    mesh.userData.initialLayer = config.initialLayer;
                    mesh.userData.id = config.id;
                    mesh.userData.initialScale = { width: initialPlaneWidth, height: initialPlaneHeight }; // Store initial scale
                    mesh.userData.originalMaterial = currentMaterial;
                    mesh.userData.brightenMaterial = brightenMaterial;


                    if (config.id !== 'signature') {
                        scene.add(mesh);
                        draggableObjects.push(mesh);
                        cameraAnimationTargets.push(mesh);
                    } else { // Signature is static, add directly to scene without making draggable
                        scene.add(mesh);
                    }

                    if (['forehead', 'rightEye', 'mouth', 'leftEye', 'nose', 'hair'].includes(config.id)) {
                        faceMeshes.push(mesh);
                    }

                    if (config.id === 'rightEye') {
                        rightEyeMesh = mesh;
                        const redactionWidth = initialPlaneWidth * 1.2;
                        const redactionHeight = initialPlaneHeight * 0.2645;
                        const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
                        const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Changed to BLACK
                        rightEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
                        rightEyeRedactionRect.position.set(mesh.position.x, mesh.position.y, mesh.position.z + (1.5 * depthStep));
                        rightEyeRedactionRect.visible = false;
                        scene.add(rightEyeRedactionRect);
                    } else if (config.id === 'leftEye') {
                        leftEyeMesh = mesh;
                        const redactionWidth = initialPlaneWidth * 1.2;
                        const redactionHeight = initialPlaneHeight * 0.2645;
                        // FIX: Corrected typo from redaactionHeight to redactionHeight
                        const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight); 
                        const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Changed to BLACK
                        leftEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
                        leftEyeRedactionRect.position.set(mesh.position.x, mesh.position.y, mesh.position.z + (1.5 * depthStep));
                        leftEyeRedactionRect.visible = false;
                        scene.add(leftEyeRedactionRect);
                    } else if (config.id === 'dogecoin') {
                        // Reload both textures for dogecoin/tesla swap
                        textureLoader.load(config.originalTextureUrl, (dogeTex) => {
                            configureTexture(dogeTex, renderer); // Apply texture settings
                            dogecoinOriginalTexture = dogeTex;
                            textureLoader.load(config.swapTextureUrl, (teslaTex) => {
                                configureTexture(teslaTex, renderer); // Apply texture settings
                                teslaTexture = teslaTex;
                                mesh.userData.originalTexture = dogecoinOriginalTexture;
                                mesh.userData.teslaTexture = teslaTex;
                                dogecoinRef = mesh;
                                
                                // Create the color material for the Tesla texture
                                teslaColorMaterial = new THREE.MeshBasicMaterial({ map: teslaTexture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                                // Create the greyscale and high contrast material for the Tesla texture (if needed, though currently not used in interaction)
                                teslaGreyscaleContrastMaterial = new THREE.ShaderMaterial({
                                    uniforms: {
                                        tDiffuse: { value: teslaTexture },
                                        contrast: { value: GreyscaleContrastShader.uniforms.contrast.value }
                                    },
                                    vertexShader: GreyscaleContrastShader.vertexShader,
                                    fragmentShader: GreyscaleContrastShader.fragmentShader,
                                    transparent: true,
                                    alphaTest: 0.5
                                });


                                // Apply the correct material based on whether Tesla is currently active
                                if (config.url === config.originalTextureUrl) {
                                    dogecoinRef.material = new THREE.MeshBasicMaterial({ map: dogecoinOriginalTexture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                                } else {
                                    // When reloading, set Tesla to color (MeshBasicMaterial)
                                    dogecoinRef.material = teslaColorMaterial;
                                }
                                dogecoinRef.material.needsUpdate = true;
                            });
                        });
                    }
                });
                break;
            case 'textMesh':
                // Re-initialize 3D text meshes (Marquee, Biometric, Blood, Redacted Glitch)
                if (config.id === 'marqueeTextMesh') {
                    // Re-create the mesh, as it was disposed earlier
                    marqueeTexture = createMarqueeTexture();
                    const newMarqueeMaterial = new THREE.MeshBasicMaterial({ map: marqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const newMarqueePlaneWidth = 20;
                    const newMarqueePlaneHeight = newMarqueePlaneWidth / (marqueeTexture.image.width / marqueeTexture.image.height);
                    const newMarqueeGeometry = new THREE.PlaneGeometry(newMarqueePlaneWidth, newMarqueePlaneHeight);

                    marqueeTextMesh = new THREE.Mesh(newMarqueeGeometry, newMarqueeMaterial);
                    marqueeTextMesh.position.copy(new THREE.Vector3().copy(config.initialPosition)); // Fix: Create new Vector3
                    marqueeTextMesh.userData.initialPosition = new THREE.Vector3().copy(config.initialPosition);
                    marqueeTextMesh.userData.initialLayer = config.initialLayer;
                    marqueeTextMesh.visible = effectControls.xray; // Tied to XRAY effect
                    scene.add(marqueeTextMesh);
                } else if (config.id === 'biometricMarqueeTextMesh') {
                    // Re-create the mesh, as it was disposed earlier
                    biometricMarqueeTexture = createBiometricMarqueeTexture();
                    const newBiometricMarqueeMaterial = new THREE.MeshBasicMaterial({ map: biometricMarqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const newBiometricMarqueePlaneWidth = 20;
                    const newBiometricMarqueePlaneHeight = newBiometricMarqueePlaneWidth / (biometricMarqueeTexture.image.width / biometricMarqueeTexture.image.height);
                    const newBiometricMarqueeGeometry = new THREE.PlaneGeometry(newBiometricMarqueePlaneWidth, newBiometricMarqueePlaneHeight);

                    biometricMarqueeTextMesh = new THREE.Mesh(newBiometricMarqueeGeometry, newBiometricMarqueeMaterial);
                    biometricMarqueeTextMesh.position.copy(new THREE.Vector3().copy(config.initialPosition)); // Fix: Create new Vector3
                    biometricMarqueeTextMesh.userData.initialPosition = new THREE.Vector3().copy(config.initialPosition);
                    biometricMarqueeTextMesh.userData.initialLayer = config.initialLayer;
                    biometricMarqueeTextMesh.visible = effectControls.biometricMarquee || effectControls.og || effectControls.hacker || effectControls.surveillance || effectControls.greed; // Visibility depends on multiple effects
                    scene.add(biometricMarqueeTextMesh);
                } else if (config.id === 'bloodTextMesh') {
                    // Re-create the mesh, as it was disposed earlier
                    bloodTexture = createBloodTextTexture();
                    const newBloodTextMaterial = new THREE.MeshBasicMaterial({ map: bloodTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const newBloodTextPlaneWidth = 20;
                    const newBloodTextPlaneHeight = newBloodTextPlaneWidth / (bloodTexture.image.width / bloodTexture.image.height);
                    const newBloodTextGeometry = new THREE.PlaneGeometry(newBloodTextPlaneWidth, newBloodTextPlaneHeight);

                    bloodTextMesh = new THREE.Mesh(newBloodTextGeometry, newBloodTextMaterial);
                    bloodTextMesh.position.copy(new THREE.Vector3().copy(config.initialPosition)); // Fix: Create new Vector3
                    bloodTextMesh.userData.initialPosition = new THREE.Vector3().copy(config.initialPosition);
                    bloodTextMesh.userData.initialLayer = config.initialLayer;
                    // Ensure bloodTextMesh is hidden on reset, as the effectControls are reset before this point
                    bloodTextMesh.visible = false;
                    scene.add(bloodTextMesh);
                } else if (config.id === 'redactedGlitchTextMesh') {
                    // Re-create the mesh, as it was disposed earlier
                    redactedGlitchTexture = createRedactedGlitchTexture();
                    const redactedGlitchMaterial = new THREE.MeshBasicMaterial({ map: redactedGlitchTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const redactedGlitchPlaneWidth = 15;
                    const redactedGlitchPlaneHeight = redactedGlitchPlaneWidth / (redactedGlitchTexture.image.width / redactedGlitchTexture.image.height);
                    const newRedactedGlitchGeometry = new THREE.PlaneGeometry(redactedGlitchPlaneWidth, redactedGlitchPlaneHeight);

                    redactedGlitchTextMesh = new THREE.Mesh(newRedactedGlitchGeometry, redactedGlitchMaterial);
                    redactedGlitchTextMesh.position.copy(new THREE.Vector3().copy(config.initialPosition)); // Fix: Create new Vector3
                    redactedGlitchTextMesh.userData.initialPosition = new THREE.Vector3().copy(config.initialPosition);
                    redactedGlitchTextMesh.userData.initialLayer = config.initialLayer;
                    redactedGlitchTextMesh.visible = effectControls.redactedGlitch; // Respect current effect control
                    scene.add(redactedGlitchTextMesh);
                    initializeRedactedGlitchPhraseData(); // Re-initialize redaction patterns
                }
                break;
        }
    });

    // Reset camera to initial global position and look-at
    camera.position.copy(initialGlobalCameraPos);
    controls.target.copy(initialGlobalCameraLookAt);
    camera.lookAt(controls.target);
    controls.update(); // Update controls after manual camera change

    // Stop any active camera animations or Y-rotation
    effectControls.cameraAnimation = false;
    effectControls.yRotation = false;
    cameraAnimationActive = false;
    controls.enabled = true; // Re-enable orbit controls
    // Update UI buttons for camera animation and Y-rotation
    updateUIButtonState('yRotation', false);
    updateUIButtonState('cameraAnimation', false);

    // Also disable redacted effects as they are tied to eye positions
    effectControls.redacted = false;
    effectControls.redactedGlitch = false;
    effectControls.anon = false; // Turn off anon effect on reset
    effectControls.hacker = false; // Turn off hacker effect on reset
    effectControls.surveillance = false; // Turn off surveillance effect on reset
    effectControls.greed = false; // Turn off greed effect on reset
    updateUIButtonState('redacted', false);
    updateUIButtonState('redactedGlitch', false);
    updateUIButtonState('anon', false);
    updateUIButtonState('hacker', false);
    updateUIButtonState('surveillance', false);
    updateUIButtonState('greed', false);

    // If threshold was forced on by redacted, turn it off if no other effect is using it.
    if (!effectControls.redacted && !effectControls.redactedGlitch && !effectControls.anon && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
        effectControls.threshold = false;
        thresholdPass.enabled = false;
        updateUIButtonState('threshold', false);
    }
    
    // Final step: Update face material brightness based on the reset state
    updateFaceMaterialBrightness();

    lastActivityTime = performance.now(); // Reset activity timer on reset
    yRotationStartTime = 0; // Reset Y-rotation auto-start timer on reset
}

function turnOffAllEffects() {
    // Deactivate all post-processing passes
    greyscalePass.enabled = false;
    thresholdPass.enabled = false;
    darkPass.enabled = false;
    pixelationPass.enabled = false;
    glitchPass.enabled = false;
    matrixPass.enabled = false;
    asciiPass.enabled = false;
    xrayPass.enabled = false;
    heatmapPass.enabled = false;
    bloodPass.enabled = false;
    cctvFeedPass.enabled = false;

    // Reset all effect control booleans to false
    for (const prop in effectControls) {
        if (effectControls.hasOwnProperty(prop)) {
            effectControls[prop] = false;
        }
    }

    // Update UI buttons to reflect inactive state
    updateUIButtonState('greyscale', false);
    updateUIButtonState('threshold', false);
    updateUIButtonState('shadow', false); // Updated from 'dark'
    updateUIButtonState('pixelation', false);
    updateUIButtonState('glitch', false);
    updateUIButtonState('matrix', false);
    updateUIButtonState('ascii', false);
    updateUIButtonState('xray', false);
    updateUIButtonState('heatmap', false);
    updateUIButtonState('blood', false);
    updateUIButtonState('cctvFeed', false);
    updateUIButtonState('yRotation', false);
    updateUIButtonState('cameraAnimation', false);
    updateUIButtonState('redacted', false);
    updateUIButtonState('redactedGlitch', false);
    updateUIButtonState('anon', false);
    updateUIButtonState('biometricMarquee', false);
    updateUIButtonState('og', false);
    updateUIButtonState('bloodText', false);
    updateUIButtonState('hacker', false); // Update hacker button state
    updateUIButtonState('surveillance', false); // Update surveillance button state
    updateUIButtonState('greed', false); // Update greed button state

    // Specific effect cleanups
    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false;
    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false;
    if (marqueeTextMesh) marqueeTextMesh.visible = false;
    if (biometricMarqueeTextMesh) biometricMarqueeTextMesh.visible = false;
    if (bloodTextMesh) bloodTextMesh.visible = false;
    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false;

    cameraAnimationActive = false;
    controls.enabled = true; // Re-enable orbit controls
    cameraAnimationState = 'idle';
    assetsVisitedCount = 0;
    
    // Final step: Update face material brightness after turning off all effects
    updateFaceMaterialBrightness();

    lastActivityTime = performance.now(); // Reset activity timer
    yRotationStartTime = 0; // Reset Y-rotation auto-start timer
}

let dogecoinRef = null; // To hold the dogecoin mesh for later reference
let dogecoinOriginalTexture = null; // To store the original dogecoin texture
let teslaTexture = null; // To store the Tesla logo texture
let teslaGreyscaleContrastMaterial = null; // New: To store the Tesla greyscale high contrast material
let teslaColorMaterial = null; // New: To store the Tesla color material

// Cache for canvas contexts to read texture alpha values efficiently
const textureAlphaCanvasCache = new Map();

function getAlphaAtUV(texture, uv) {
    if (!texture || !texture.image || !uv) return 0;

    // Use cached canvas context if available
    let canvas, context;
    if (textureAlphaCanvasCache.has(texture.id)) {
        ({ canvas, context } = textureAlphaCanvasCache.get(texture.id));
    } else {
        canvas = document.createElement('canvas');
        context = canvas.getContext('2d');
        canvas.width = texture.image.width;
        canvas.height = texture.image.height;
        context.drawImage(texture.image, 0, 0);
        textureAlphaCanvasCache.set(texture.id, { canvas, context });
    }

    const x = Math.floor(uv.x * canvas.width);
    const y = Math.floor((1 - uv.y) * canvas.height); // Y-axis needs to be inverted for canvas

    // Ensure coordinates are within bounds
    if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
        return 0;
    }

    const pixelData = context.getImageData(x, y, 1, 1).data;
    return pixelData[3] / 255; // Alpha channel
}

function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 10; // Zoomed out to see the full canvas
    camera.userData.yRotationAngle = 0; // Initialize angle for Y-axis camera rotation

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x1e1e1e); // Changed to DARK GREY background (0x333333)
    renderer.outputColorSpace = THREE.SRGBColorSpace; // Set renderer color space
    document.body.appendChild(renderer.domElement);

    renderer.sortObjects = true; // Enable object sorting for correct transparency rendering

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 20;
    controls.maxPolarAngle = Math.PI / 2;
    controls.addEventListener('change', () => {
        lastActivityTime = performance.now();
        stopCameraAnimationAndReset(); // Stop animation on camera control interaction
    });

    // Store initial global camera position and look-at target
    initialGlobalCameraPos.copy(camera.position);
    initialGlobalCameraLookAt.copy(controls.target);

    // Post-processing setup
    composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    greyscalePass = new ShaderPass(GreyScaleShader);
    composer.addPass(greyscalePass);
    greyscalePass.enabled = effectControls.greyscale;

    thresholdPass = new ShaderPass(ThresholdShader);
    thresholdPass.uniforms['threshold'].value = effectControls.thresholdValue;
    composer.addPass(thresholdPass);
    thresholdPass.enabled = effectControls.threshold;

    darkPass = new ShaderPass(DarkShader);
    darkPass.uniforms['threshold'].value = effectControls.thresholdValue;
    composer.addPass(darkPass);
    darkPass.enabled = effectControls.shadow;

    pixelationPass = new ShaderPass(PixelationShader);
    pixelationPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    pixelationPass.uniforms['pixelSize'].value = effectControls.pixelSize;
    composer.addPass(pixelationPass);
    pixelationPass.enabled = effectControls.pixelation;

    glitchPass = new GlitchPass();
    composer.addPass(glitchPass);
    glitchPass.enabled = effectControls.glitch;

    matrixPass = new ShaderPass(MatrixShader);
    composer.addPass(matrixPass);
    matrixPass.enabled = effectControls.matrix;

    asciiPass = new ShaderPass(ASCIIShader);
    asciiPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    asciiPass.uniforms['pixelSize'].value = effectControls.pixelSize;
    composer.addPass(asciiPass);
    asciiPass.enabled = false;

    xrayPass = new ShaderPass(XRayShader);
    composer.addPass(xrayPass);
    xrayPass.enabled = effectControls.xray;

    heatmapPass = new ShaderPass(HeatmapShader);
    composer.addPass(heatmapPass);
    heatmapPass.enabled = effectControls.heatmap;

    bloodPass = new ShaderPass(BloodShader);
    composer.addPass(bloodPass);
    bloodPass.enabled = effectControls.blood;

    cctvFeedPass = new ShaderPass(CCTVFeedShader);
    cctvFeedPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    cctvFeedPass.uniforms['time'].value = 0.0;
    composer.addPass(cctvFeedPass);
    cctvFeedPass.enabled = effectControls.cctvFeed;

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    const textureLoader = new THREE.TextureLoader();

    // Base scale factor to make images viewable at a reasonable size
    // const baseScale = 0.005; // Removed: Now using BASE_SCALE constant

    // Load and add the background image
    // REMOVED: Background image loading and adding
    initialAssetConfigs.push({
        id: 'background',
        type: 'background',
        url: URL_BACKGROUND,
        initialPosition: new THREE.Vector3(0, 0, .25 * depthStep),
        initialLayer: -4,
        scaleFactor: 1.10,
        removed: true // Mark as removed in config
    });
    // Set backgroundMesh to null initially since it's removed
    backgroundMesh = null;


    // Load and add the forehead image
    initialAssetConfigs.push({
        id: 'forehead',
        type: 'image',
        url: URL_FOREHEAD,
        initialPosition: new THREE.Vector3(0, (0.5 + 2.666) * 1.10, layerToZ(2)),
        initialLayer: 2,
        baseScale: BASE_SCALE, // FIX: Use BASE_SCALE
        scaleFactor: 1.25,
        removed: false // Add removed flag
    });
    textureLoader.load(URL_FOREHEAD, (texture) => {
        configureTexture(texture, renderer); // Apply texture settings
        const originalMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const brightenMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: texture }, brightnessFactor: { value: BrightenShader.uniforms.brightnessFactor.value } },
            vertexShader: BrightenShader.vertexShader,
            fragmentShader: BrightenShader.fragmentShader,
            transparent: true, alphaTest: 0.5
        });

        const material = originalMaterial;
        const scaleFactor = 1.25;
        const planeWidth = texture.image.width * BASE_SCALE * scaleFactor; // FIX: Use BASE_SCALE
        const planeHeight = texture.image.height * BASE_SCALE * scaleFactor; // FIX: Use BASE_SCALE
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const forehead = new THREE.Mesh(geometry, material);
        forehead.position.set(0, (0.5 + 2.666) * 1.10, layerToZ(2));
        forehead.userData.currentLayer = 2;
        forehead.userData.initialPosition = forehead.position.clone();
        forehead.userData.initialLayer = 2;
        forehead.userData.id = 'forehead'; // Added ID
        forehead.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        forehead.userData.originalMaterial = originalMaterial;
        forehead.userData.brightenMaterial = brightenMaterial;
        scene.add(forehead);
        draggableObjects.push(forehead);
        cameraAnimationTargets.push(forehead);
        faceMeshes.push(forehead);
    });

    // Load and add the right eye image
    initialAssetConfigs.push({
        id: 'rightEye',
        type: 'image',
        url: URL_RIGHT_EYE,
        initialPosition: new THREE.Vector3(-1.8 * .7 * 1, (0.175 * 1.15 * 1.20 * 3) + 2.0 - 1.2, layerToZ(7)),
        initialLayer: 7,
        baseScale: BASE_SCALE, // FIX: Use BASE_SCALE
        scaleFactor: 0.8, // Reduced by 20%
        removed: false // Add removed flag
    });
    textureLoader.load(URL_RIGHT_EYE, (texture) => {
        configureTexture(texture, renderer); // Apply texture settings
        const originalMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const brightenMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: texture }, brightnessFactor: { value: BrightenShader.uniforms.brightnessFactor.value } },
            vertexShader: BrightenShader.vertexShader,
            fragmentShader: BrightenShader.fragmentShader,
            transparent: true, alphaTest: 0.5
        });

        const material = originalMaterial;
        const planeWidth = texture.image.width * BASE_SCALE * 0.8; // FIX: Use BASE_SCALE
        const planeHeight = texture.image.height * BASE_SCALE * 0.8; // FIX: Use BASE_SCALE
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        rightEyeMesh = new THREE.Mesh(geometry, material);
        rightEyeMesh.position.set(-1.8 * .7 * 1, (0.175 * 1.15 * 1.20 * 3) + 2.0 - 1.2, layerToZ(7));
        rightEyeMesh.userData.currentLayer = 7;
        rightEyeMesh.userData.initialPosition = rightEyeMesh.position.clone();
        rightEyeMesh.userData.initialLayer = 7;
        rightEyeMesh.userData.id = 'rightEye'; // Added ID
        rightEyeMesh.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        rightEyeMesh.userData.originalMaterial = originalMaterial;
        rightEyeMesh.userData.brightenMaterial = brightenMaterial;
        scene.add(rightEyeMesh);
        draggableObjects.push(rightEyeMesh);
        cameraAnimationTargets.push(rightEyeMesh);
        faceMeshes.push(rightEyeMesh);

        // Create and add the redaction rectangle for the right eye
        const redactionWidth = planeWidth * 1.2;
        const redactionHeight = planeHeight * 0.2645;
        const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
        const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Redaction color: Black
        rightEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
        // Position it at the same X, Y as the eye, but 1.5 levels in front
        rightEyeRedactionRect.position.set(
            rightEyeMesh.position.x,
            rightEyeMesh.position.y,
            rightEyeMesh.position.z + (1.5 * depthStep)
        );
        rightEyeRedactionRect.visible = false;
        scene.add(rightEyeRedactionRect);
    });

    // Load and add the mouth image
    initialAssetConfigs.push({
        id: 'mouth',
        type: 'image',
        url: URL_MOUTH,
        initialPosition: new THREE.Vector3(0, -2.0, layerToZ(9)),
        initialLayer: 9,
        baseScale: BASE_SCALE, // FIX: Use BASE_SCALE
        scaleFactor: 1.0,
        removed: false // Add removed flag
    });
    textureLoader.load(URL_MOUTH, (texture) => {
        configureTexture(texture, renderer); // Apply texture settings
        const originalMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const brightenMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: texture }, brightnessFactor: { value: BrightenShader.uniforms.brightnessFactor.value } },
            vertexShader: BrightenShader.vertexShader,
            fragmentShader: BrightenShader.fragmentShader,
            transparent: true, alphaTest: 0.5
        });

        const material = originalMaterial;
        const planeWidth = texture.image.width * BASE_SCALE; // FIX: Use BASE_SCALE
        const planeHeight = texture.image.height * BASE_SCALE; // FIX: Use BASE_SCALE
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const mouth = new THREE.Mesh(geometry, material);
        mouth.position.set(0, -2.0, layerToZ(9));
        mouth.userData.currentLayer = 9;
        mouth.userData.initialPosition = mouth.position.clone();
        mouth.userData.initialLayer = 9;
        mouth.userData.id = 'mouth'; // Added ID
        mouth.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        mouth.userData.originalMaterial = originalMaterial;
        mouth.userData.brightenMaterial = brightenMaterial;
        scene.add(mouth);
        draggableObjects.push(mouth);
        cameraAnimationTargets.push(mouth);
        faceMeshes.push(mouth);
    });

    // Load and add the left eye image
    initialAssetConfigs.push({
        id: 'leftEye',
        type: 'image',
        url: URL_LEFT_EYE,
        initialPosition: new THREE.Vector3(0.84 * 1.2 * 1.2, (0.175 * 1.15 * 1.20 * 3) + 2.0 - 1.3, layerToZ(9)),
        initialLayer: 9,
        baseScale: BASE_SCALE, // FIX: Use BASE_SCALE
        scaleFactor: 1.0,
        removed: false // Add removed flag
    });
    textureLoader.load(URL_LEFT_EYE, (texture) => {
        configureTexture(texture, renderer); // Apply texture settings
        const originalMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const brightenMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: texture }, brightnessFactor: { value: BrightenShader.uniforms.brightnessFactor.value } },
            vertexShader: BrightenShader.vertexShader,
            fragmentShader: BrightenShader.fragmentShader,
            transparent: true, alphaTest: 0.5
        });

        const material = originalMaterial;
        const planeWidth = texture.image.width * BASE_SCALE; // FIX: Use BASE_SCALE
        const planeHeight = texture.image.height * BASE_SCALE; // FIX: Use BASE_SCALE
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        leftEyeMesh = new THREE.Mesh(geometry, material);
        leftEyeMesh.position.set(0.84 * 1.2 * 1.2, (0.175 * 1.15 * 1.20 * 3) + 2.0 - 1.3, layerToZ(9));
        leftEyeMesh.userData.currentLayer = 9;
        leftEyeMesh.userData.initialPosition = leftEyeMesh.position.clone();
        leftEyeMesh.userData.initialLayer = 9;
        leftEyeMesh.userData.id = 'leftEye'; // Added ID
        leftEyeMesh.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        leftEyeMesh.userData.originalMaterial = originalMaterial;
        leftEyeMesh.userData.brightenMaterial = brightenMaterial;
        scene.add(leftEyeMesh);
        draggableObjects.push(leftEyeMesh);
        cameraAnimationTargets.push(leftEyeMesh);
        faceMeshes.push(leftEyeMesh);

        // Create and add the redaction rectangle for the left eye
        const redactionWidth = planeWidth * 1.2;
        const redactionHeight = planeHeight * 0.42; // Increased height by 15% (0.23 * 1.15)
        const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
        const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 }); // Redaction color: Black
        leftEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
        // Position it at the same X, Y as the eye, but 1.5 levels in front
        leftEyeRedactionRect.position.set(
            leftEyeMesh.position.x,
            leftEyeMesh.position.y,
            leftEyeMesh.position.z + (1.5 * depthStep)
        );
        leftEyeRedactionRect.visible = false;
        scene.add(leftEyeRedactionRect);
    });

    // Load and add the nose image
    initialAssetConfigs.push({
        id: 'nose',
        type: 'image',
        url: URL_NOSE,
        initialPosition: new THREE.Vector3(0, 0.4, layerToZ(11)),
        initialLayer: 11,
        baseScale: BASE_SCALE, // FIX: Use BASE_SCALE
        scaleFactor: 0.93,
        removed: false // Add removed flag
    });
    textureLoader.load(URL_NOSE, (texture) => {
        configureTexture(texture, renderer); // Apply texture settings
        const originalMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const brightenMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: texture }, brightnessFactor: { value: BrightenShader.uniforms.brightnessFactor.value } },
            vertexShader: BrightenShader.vertexShader,
            fragmentShader: BrightenShader.fragmentShader,
            transparent: true, alphaTest: 0.5
        });

        const material = originalMaterial;
        const scaleFactor = 0.93;
        const planeWidth = texture.image.width * BASE_SCALE * scaleFactor; // FIX: Use BASE_SCALE
        const planeHeight = texture.image.height * BASE_SCALE * scaleFactor; // FIX: Use BASE_SCALE
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const nose = new THREE.Mesh(geometry, material);
        nose.position.set(0, 0.4, layerToZ(11));
        nose.userData.currentLayer = 11;
        nose.userData.initialPosition = nose.position.clone();
        nose.userData.initialLayer = 11;
        nose.userData.id = 'nose'; // Added ID
        nose.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        nose.userData.originalMaterial = originalMaterial;
        nose.userData.brightenMaterial = brightenMaterial;
        scene.add(nose);
        draggableObjects.push(nose);
        cameraAnimationTargets.push(nose);
        faceMeshes.push(nose);
    });

    // Load and add the hair image
    initialAssetConfigs.push({
        id: 'hair',
        type: 'image',
        url: URL_HAIR,
        initialPosition: new THREE.Vector3(0, 3.5 * 1.10, layerToZ(4)),
        initialLayer: 4,
        baseScale: BASE_SCALE, // FIX: Use BASE_SCALE
        scaleFactor: 1.15,
        removed: false // Add removed flag
    });
    textureLoader.load(URL_HAIR, (texture) => {
        configureTexture(texture, renderer); // Apply texture settings
        const originalMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const brightenMaterial = new THREE.ShaderMaterial({
            uniforms: { tDiffuse: { value: texture }, brightnessFactor: { value: BrightenShader.uniforms.brightnessFactor.value } },
            vertexShader: BrightenShader.vertexShader,
            fragmentShader: BrightenShader.fragmentShader,
            transparent: true, alphaTest: 0.5
        });

        const material = originalMaterial;
        const scaleFactor = 1.15;
        const planeWidth = texture.image.width * BASE_SCALE * scaleFactor; // FIX: Use BASE_SCALE
        const planeHeight = texture.image.height * BASE_SCALE * scaleFactor; // FIX: Use BASE_SCALE
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const hair = new THREE.Mesh(geometry, material);
        hair.position.set(0, 3.5 * 1.10, layerToZ(4));
        hair.userData.currentLayer = 4;
        hair.userData.initialPosition = hair.position.clone();
        hair.userData.initialLayer = 4;
        hair.userData.id = 'hair'; // Added ID
        hair.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        hair.userData.originalMaterial = originalMaterial;
        hair.userData.brightenMaterial = brightenMaterial;
        scene.add(hair);
        draggableObjects.push(hair);
        cameraAnimationTargets.push(hair);
        faceMeshes.push(hair);
    });

    // Load and add the blue bill image
    initialAssetConfigs.push({
        id: 'blueBill',
        type: 'image',
        url: URL_BLUE_BILL,
        initialPosition: new THREE.Vector3(3, -2, layerToZ(7)),
        initialLayer: 10,
        baseScale: BASE_SCALE, // FIX: Use BASE_SCALE
        scaleFactor: 1,
        removed: false // Add removed flag
    });
    textureLoader.load(URL_BLUE_BILL, (texture) => {
        configureTexture(texture, renderer); // Apply texture settings
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const planeWidth = texture.image.width * BASE_SCALE; // FIX: Use BASE_SCALE
        const planeHeight = texture.image.height * BASE_SCALE; // FIX: Use BASE_SCALE
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const blueBill = new THREE.Mesh(geometry, material);
        blueBill.position.set(3, -2, layerToZ(7));
        blueBill.userData.currentLayer = 10;
        blueBill.userData.initialPosition = blueBill.position.clone();
        blueBill.userData.initialLayer = 10;
        blueBill.userData.id = 'fbphone'; // Added ID
        blueBill.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(blueBill);
        draggableObjects.push(blueBill);
        cameraAnimationTargets.push(blueBill);
    });

    // Load Dogecoin and Tesla textures
    const dogecoinLayer = 3;
    const dogecoinZ = layerToZ(dogecoinLayer);
    const distance_from_camera_dogecoin = camera.position.z - dogecoinZ;
    const world_height_at_dogecoin_z = 2 * distance_from_camera_dogecoin * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
    const world_width_at_dogecoin_z = world_height_at_dogecoin_z * camera.aspect;
    const pixelToUnitFactorX_dogecoin = world_width_at_dogecoin_z / window.innerWidth;
    const pixelToUnitFactorY_dogecoin = world_height_at_dogecoin_z / window.innerHeight;
    const initialOffsetX_dogecoin = -60 * pixelToUnitFactorX_dogecoin;
    const initialOffsetY_dogecoin = 0;
    const dogecoinInitialPos = new THREE.Vector3(initialOffsetX_dogecoin - (60 * pixelToUnitFactorX_dogecoin), initialOffsetY_dogecoin - (200 * pixelToUnitFactorY_dogecoin), dogecoinZ);

    initialAssetConfigs.push({
        id: 'dogecoin',
        type: 'image',
        url: URL_TESLA_SWAP, // Changed to Tesla logo initially
        originalTextureUrl: URL_DOGECOIN_ORIGINAL,
        swapTextureUrl: URL_TESLA_SWAP, // Changed to Tesla logo
        initialPosition: dogecoinInitialPos.clone(), // Clone to ensure an independent copy
        initialLayer: dogecoinLayer,
        baseScale: BASE_SCALE, // FIX: Use BASE_SCALE
        scaleFactor: 1,
        removed: false // Add removed flag
    });
    textureLoader.load(URL_DOGECOIN_ORIGINAL, (dogeTex) => {
        configureTexture(dogeTex, renderer); // Apply texture settings
        dogecoinOriginalTexture = dogeTex;

        textureLoader.load(URL_TESLA_SWAP, (teslaTex) => {
            configureTexture(teslaTex, renderer); // Apply texture settings
            teslaTexture = teslaTex;

            // Create the greyscale and high contrast material for the Tesla texture
            teslaGreyscaleContrastMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: teslaTexture },
                    contrast: { value: GreyscaleContrastShader.uniforms.contrast.value }
                },
                vertexShader: GreyscaleContrastShader.vertexShader,
                fragmentShader: GreyscaleContrastShader.fragmentShader,
                transparent: true,
                alphaTest: 0.5 // Ensure alphaTest is applied to ShaderMaterial
            });
            
            // Create the color material for the Tesla texture
            teslaColorMaterial = new THREE.MeshBasicMaterial({ map: teslaTexture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });

            // Initial material should be Tesla with the color material
            const material = teslaColorMaterial;

            const dogecoinScaleFactor = 1;
            const planeWidth = teslaTexture.image.width * BASE_SCALE * dogecoinScaleFactor; // FIX: Use BASE_SCALE
            const planeHeight = teslaTexture.image.height * BASE_SCALE * dogecoinScaleFactor; // FIX: Use BASE_SCALE
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const dogecoin = new THREE.Mesh(geometry, material);

            // Position at layer 3
            dogecoin.position.z = layerToZ(3);

            // Calculate pixel to unit conversion factors for the specific Z-plane of the dogecoin
            const distance_from_camera = camera.position.z - dogecoin.position.z;
            const world_height_at_dogecoin_z = 2 * distance_from_camera * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
            const world_width_at_dogecoin_z = world_height_at_dogecoin_z * camera.aspect;

            const pixelToUnitFactorX_dogecoin = world_width_at_dogecoin_z / window.innerWidth;
            const pixelToUnitFactorY_dogecoin = world_height_at_dogecoin_z / window.innerHeight;

            // Initial position: 60px to the left of center, and vertically centered
            const initialOffsetX_dogecoin = -60 * pixelToUnitFactorX_dogecoin;
            const initialOffsetY_dogecoin = 0;

            dogecoin.position.x = initialOffsetX_dogecoin - (60 * pixelToUnitFactorX_dogecoin);
            dogecoin.position.y = initialOffsetY_dogecoin - (200 * pixelToUnitFactorY_dogecoin);

            dogecoin.userData.currentLayer = 3;
            dogecoin.userData.initialPosition = dogecoin.position.clone();
            dogecoin.userData.initialLayer = 3;
            dogecoin.userData.originalTexture = dogecoinOriginalTexture; // Store original texture
            dogecoin.userData.teslaTexture = teslaTexture; // Store tesla texture
            dogecoin.userData.id = 'dogecoin'; // Added ID
            dogecoin.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
            scene.add(dogecoin);
            draggableObjects.push(dogecoin);
            cameraAnimationTargets.push(dogecoin);

            dogecoinRef = dogecoin; // Store reference to dogecoin

            // Load and add the signature image
            const signatureNewLayer = 0; // Layer 0
            const signatureNewZ = layerToZ(signatureNewLayer); // (0 - 1) * 0.2 = -0.2
            const signatureNewX = -2.0; // Moved to the right from -2.5
            const signatureNewY = -4.7; // Same Y as where fiatWorthless was

            initialAssetConfigs.push({
                id: 'signature',
                type: 'image',
                url: URL_SIGNATURE,
                initialPosition: new THREE.Vector3(signatureNewX, signatureNewY, signatureNewZ),
                initialLayer: signatureNewLayer,
                baseScale: BASE_SCALE, // FIX: Use BASE_SCALE
                scaleFactor: 1.0,
                removed: false // Add removed flag
            });
            textureLoader.load(URL_SIGNATURE, (signatureTexture) => {
                configureTexture(signatureTexture, renderer); // Apply texture settings
                const signatureMaterial = new THREE.MeshBasicMaterial({ map: signatureTexture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                const signatureAspectRatio = signatureTexture.image.width / signatureTexture.image.height;
                const signatureHeight = 1.0; // Fixed height
                const signatureWidth = signatureHeight * signatureAspectRatio;
                const signatureGeometry = new THREE.PlaneGeometry(signatureWidth, signatureHeight);
                const signature = new THREE.Mesh(signatureGeometry, signatureMaterial);

                signature.position.set(signatureNewX, signatureNewY, signatureNewZ);

                signature.userData.currentLayer = signatureNewLayer;
                signature.userData.id = 'signature'; // Added ID
                signature.userData.initialScale = { width: signatureWidth, height: signatureHeight }; // Store initial scale
                scene.add(signature);
                // Note: signature is NOT added to draggableObjects, making it static and locked.
            });
        });
    });


    // Load and add the headset image
    const headsetLayer = 12; // In front of the nose (layer 11)
    const headsetZ = layerToZ(headsetLayer);
    initialAssetConfigs.push({
        id: 'headset',
        type: 'image',
        url: URL_HEADSET,
        initialPosition: new THREE.Vector3(0, 2.85, headsetZ), // Centered, covering eyes
        initialLayer: headsetLayer,
        baseScale: BASE_SCALE, // FIX: Use BASE_SCALE
        scaleFactor: 2.0, // Adjust scale as needed
        removed: false // Add removed flag
    });
    textureLoader.load(URL_HEADSET, (texture) => {
        configureTexture(texture, renderer); // Apply texture settings
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const headsetScaleFactor = 2;
        const planeWidth = texture.image.width * BASE_SCALE * headsetScaleFactor; // FIX: Use BASE_SCALE
        const planeHeight = texture.image.height * BASE_SCALE * headsetScaleFactor; // FIX: Use BASE_SCALE
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const headset = new THREE.Mesh(geometry, material);

        headset.position.set(0, 2.85, headsetZ); // Set initial position

        headset.userData.currentLayer = headsetLayer;
        headset.userData.id = 'headset';
        headset.userData.initialPosition = headset.position.clone();
        headset.userData.initialLayer = headsetLayer;
        headset.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(headset);
        draggableObjects.push(headset);
        cameraAnimationTargets.push(headset);
    });

    // --- NEW: Add 10 instances of thumb-up.gif ---
    initialAssetConfigs.push({
        id: 'thumb-up',
        type: 'image',
        url: URL_THUMB_UP,
        initialPosition: new THREE.Vector3(0, 0, 0), // Placeholder, actual position is random
        initialLayer: 0, // Placeholder, actual layer is random
        baseScale: BASE_SCALE, // FIX: Use BASE_SCALE
        scaleFactor: 1.0, // Default scale
        instanceCount: 10, // Define number of instances
        removed: false
    });
    
    for (let i = 0; i < 10; i++) {
        textureLoader.load(URL_THUMB_UP, (texture) => {
            configureTexture(texture, renderer); // Apply texture settings
            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
            const scaleFactor = 1;
            const planeWidth = texture.image.width * BASE_SCALE * scaleFactor; // FIX: Use BASE_SCALE
            const planeHeight = texture.image.height * BASE_SCALE * scaleFactor; // FIX: Use BASE_SCALE
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const thumbUp = new THREE.Mesh(geometry, material);

            // Random position and depth: between layer minLayer (-5) and maxLayer (20)
            const randomLayer = Math.floor(Math.random() * totalZLayers) + minLayer; // Range: -5 to 20
            
            const randomZ = layerToZ(randomLayer);
            const randomPos = getRandomPosition(randomZ);

            thumbUp.position.copy(randomPos);
            
            thumbUp.userData.currentLayer = randomLayer;
            thumbUp.userData.initialPosition = randomPos.clone();
            thumbUp.userData.initialLayer = randomLayer;
            thumbUp.userData.id = `thumb-up_${i}`; // Unique ID for each instance
            thumbUp.userData.originalId = 'thumb-up'; // Group ID for interaction logic
            thumbUp.userData.initialScale = { width: planeWidth, height: planeHeight };
            thumbUp.userData.flipped = false; // Add flip state
            
            scene.add(thumbUp);
            draggableObjects.push(thumbUp);
            cameraAnimationTargets.push(thumbUp);
        });
    }
    // --- END NEW ASSET ---

    // Initialize the Marquee Text (for XRAY effect)
    marqueeTexture = createMarqueeTexture();
    const marqueeMaterial = new THREE.MeshBasicMaterial({ map: marqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    // The plane size should be relative to the background or screen to fill it
    const marqueePlaneWidth = 20;
    const marqueePlaneHeight = marqueePlaneWidth / (marqueeTexture.image.width / marqueeTexture.image.height);
    const marqueeGeometry = new THREE.PlaneGeometry(marqueePlaneWidth, marqueePlaneHeight);
    initialAssetConfigs.push({
        id: 'marqueeTextMesh',
        type: 'textMesh',
        initialPosition: new THREE.Vector3(0, 0, layerToZ(-3)),
        initialLayer: -3,
        geometry: marqueeGeometry.clone(),
        material: marqueeMaterial.clone(),
        removed: false // Add removed flag
    });
    marqueeTextMesh = new THREE.Mesh(marqueeGeometry, marqueeMaterial);
    // Position far back in the background, but in front of the actual background image
    marqueeTextMesh.position.z = layerToZ(-3);
    marqueeTextMesh.visible = false;
    marqueeTextMesh.userData.initialPosition = marqueeTextMesh.position.clone();
    marqueeTextMesh.userData.initialLayer = -3;
    marqueeTextMesh.userData.id = 'marqueeTextMesh'; // Added ID
    scene.add(marqueeTextMesh);

    // Initialize the new Biometric Marquee Text
    biometricMarqueeTexture = createBiometricMarqueeTexture();
    const biometricMarqueeMaterial = new THREE.MeshBasicMaterial({ map: biometricMarqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    const biometricMarqueePlaneWidth = 20; // Same width as main marquee for consistency
    const biometricMarqueePlaneHeight = biometricMarqueePlaneWidth / (biometricMarqueeTexture.image.width / biometricMarqueeTexture.image.height);
    const biometricMarqueeGeometry = new THREE.PlaneGeometry(biometricMarqueePlaneWidth, biometricMarqueePlaneHeight);
    const biometricMarqueeZ = layerToZ(5);
    const distance_from_camera_biometric = camera.position.z - biometricMarqueeZ;
    const world_height_biometric = 2 * distance_from_camera_biometric * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
    const pixelToUnitFactorX_biometric = (world_height_biometric * camera.aspect) / window.innerWidth;
    const moveRightUnits_biometric = 30 * pixelToUnitFactorX_biometric;
    initialAssetConfigs.push({
        id: 'biometricMarqueeTextMesh',
        type: 'textMesh',
        initialPosition: new THREE.Vector3(moveRightUnits_biometric, 0, biometricMarqueeZ),
        initialLayer: 5,
        geometry: biometricMarqueeGeometry.clone(),
        material: biometricMarqueeMaterial.clone(),
        removed: false // Add removed flag
    });
    biometricMarqueeTextMesh = new THREE.Mesh(biometricMarqueeGeometry, biometricMarqueeMaterial);
    biometricMarqueeTextMesh.position.set(moveRightUnits_biometric, 0, biometricMarqueeZ);
    biometricMarqueeTextMesh.visible = false; // Initially hidden
    biometricMarqueeTextMesh.userData.initialPosition = biometricMarqueeTextMesh.position.clone();
    biometricMarqueeTextMesh.userData.initialLayer = 5;
    biometricMarqueeTextMesh.userData.id = 'biometricMarqueeTextMesh'; // Added ID
    scene.add(biometricMarqueeTextMesh);

    // Initialize the new Blood Text
    bloodTexture = createBloodTextTexture();
    const bloodTextMaterial = new THREE.MeshBasicMaterial({ map: bloodTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    const bloodTextPlaneWidth = 20; // Similar width to other marquees
    const bloodTextPlaneHeight = bloodTextPlaneWidth / (bloodTexture.image.width / bloodTexture.image.height);
    const bloodTextGeometry = new THREE.PlaneGeometry(bloodTextPlaneWidth, bloodTextPlaneHeight);
    initialAssetConfigs.push({
        id: 'bloodTextMesh',
        type: 'textMesh',
        initialPosition: new THREE.Vector3(0, 30, layerToZ(8)),
        initialLayer: 8,
        geometry: bloodTextGeometry.clone(),
        material: bloodTextMaterial.clone(),
        removed: false // Add removed flag
    });
    bloodTextMesh = new THREE.Mesh(bloodTextGeometry, bloodTextMaterial);
    // Position on Level 8 (moved back from Level 12 by 4 levels)
    bloodTextMesh.position.set(0, 30, layerToZ(8));
    bloodTextMesh.visible = false; // Initially hidden
    bloodTextMesh.userData.initialPosition = bloodTextMesh.position.clone();
    bloodTextMesh.userData.initialLayer = 8;
    bloodTextMesh.userData.id = 'bloodTextMesh'; // Added ID
    scene.add(bloodTextMesh);

    // Initialize the new Redacted Glitch Text
    redactedGlitchTexture = createRedactedGlitchTexture();
    const redactedGlitchMaterial = new THREE.MeshBasicMaterial({ map: redactedGlitchTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    const redactedGlitchPlaneWidth = 15; // Width for the text block
    const redactedGlitchPlaneHeight = redactedGlitchPlaneWidth / (redactedGlitchTexture.image.width / redactedGlitchTexture.image.height);
    const redactedGlitchGeometry = new THREE.PlaneGeometry(redactedGlitchPlaneWidth, redactedGlitchPlaneHeight);
    const redactedGlitchTextZ = layerToZ(1);
    const distance_from_camera_redacted = camera.position.z - redactedGlitchTextZ;
    const world_height_redacted = 2 * distance_from_camera_redacted * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
    const pixelToUnitFactorX_redacted = (world_height_redacted * camera.aspect) / window.innerWidth;
    const moveRightUnits_redacted = 40 * pixelToUnitFactorX_redacted;
    initialAssetConfigs.push({
        id: 'redactedGlitchTextMesh',
        type: 'textMesh',
        initialPosition: new THREE.Vector3(-5 + moveRightUnits_redacted, 0, redactedGlitchTextZ),
        initialLayer: 1,
        geometry: redactedGlitchGeometry.clone(),
        material: redactedGlitchMaterial.clone(),
        removed: false // Add removed flag
    });
    redactedGlitchTextMesh = new THREE.Mesh(redactedGlitchGeometry, redactedGlitchMaterial);
    redactedGlitchTextMesh.position.set(-5 + moveRightUnits_redacted, 0, redactedGlitchTextZ);
    redactedGlitchTextMesh.visible = false; // Initially hidden
    redactedGlitchTextMesh.userData.initialPosition = redactedGlitchTextMesh.position.clone();
    redactedGlitchTextMesh.userData.initialLayer = -1;
    redactedGlitchTextMesh.userData.id = 'redactedGlitchTextMesh'; // Added ID
    scene.add(redactedGlitchTextMesh);

    initializeRedactedGlitchPhraseData(); // Initialize the redaction patterns

    window.addEventListener('resize', onWindowResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
    renderer.domElement.addEventListener('click', onClick);

    // Helper function to add a toggle button for an effect
    const addButtonToggle = (parentContainer, label, property, pass) => {
        const button = document.createElement('button');
        button.textContent = label.toUpperCase();
        button.style.cssText = `
            background-color: black;
            color: white;
            padding: 4px;
            margin: 0;
            border: 0.5px solid ${effectControls[property] ? '#4CAF50' : 'white'};
            border-radius: 0;
            cursor: pointer;
            font-family: monospace;
            font-size: 7px;
            outline: none;
            box-sizing: border-box;
        `;
        button.onmouseover = () => {
            if (effectControls[property]) {
                button.style.borderColor = '#66CC66'; // Brighter green for active hover
            } else {
                button.style.borderColor = '#777';
            }
        };
        button.onmouseout = () => {
            if (effectControls[property]) {
                button.style.borderColor = '#4CAF50'; // Green for active
            } else {
                button.style.borderColor = 'white'; // White for inactive
            }
        };

        button.onclick = (event) => {
            // Prevent event from bubbling up to document and triggering other handlers
            event.stopPropagation();

            let targetProperty = property; // Default to the button's own property

            // If HACKER is clicked, toggle the 'og' effect and keep hacker state in sync for UI update
            if (property === 'hacker') {
                effectControls.og = !effectControls.og;
                effectControls.hacker = effectControls.og;
                targetProperty = 'og'; // Process as if 'og' was clicked
            }

            // If this effect is being turned on, turn off conflicting effects
            if (!effectControls[targetProperty]) { // If turning the effect ON (or the underlying 'og' effect for 'hacker')

                // Turn off 'Anon' if any other effect is explicitly turned on
                if (effectControls.anon && targetProperty !== 'anon') {
                    effectControls.anon = false;
                    thresholdPass.enabled = false;
                    bloodPass.enabled = false;
                    glitchPass.enabled = false;
                    if (rightEyeRedactionRect) { rightEyeRedactionRect.material.color.setHex(0x000000); rightEyeRedactionRect.visible = false; }
                    if (leftEyeRedactionRect) { leftEyeRedactionRect.material.color.setHex(0x000000); leftEyeRedactionRect.visible = false; }
                    updateUIButtonState('anon', false);
                }

                // Turn off conflicting visual effects
                if (targetProperty === 'cctvFeed') {
                    if (effectControls.heatmap) { effectControls.heatmap = false; heatmapPass.enabled = false; updateUIButtonState('heatmap', false); }
                    if (effectControls.blood) { effectControls.blood = false; bloodPass.enabled = false; updateUIButtonState('blood', false); } // Turn off blood when CCTV is on
                    if (effectControls.bloodText) { effectControls.bloodText = false; bloodTextMesh.visible = false; updateUIButtonState('bloodText', false); } // Turn off blood text
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                } else if (targetProperty === 'heatmap') {
                    if (effectControls.cctvFeed) { effectControls.cctvFeed = false; cctvFeedPass.enabled = false; updateUIButtonState('cctvFeed', false); }
                    if (effectControls.blood) { effectControls.blood = false; bloodPass.enabled = false; updateUIButtonState('blood', false); } // Turn off blood when Heatmap is on
                    if (effectControls.bloodText) { effectControls.bloodText = false; bloodTextMesh.visible = false; updateUIButtonState('bloodText', false); } // Turn off blood text
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                } else if (targetProperty === 'blood' || targetProperty === 'bloodText') { // If Blood or Blood Text is turned on
                    if (effectControls.heatmap) { effectControls.heatmap = false; heatmapPass.enabled = false; updateUIButtonState('heatmap', false); }
                    if (effectControls.cctvFeed) { effectControls.cctvFeed = false; cctvFeedPass.enabled = false; updateUIButtonState('cctvFeed', false); }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                } else if (targetProperty === 'redactedGlitch') {
                    if (effectControls.redacted) { effectControls.redacted = false; updateUIButtonState('redacted', false); } // Turn off simple redacted
                    if (effectControls.glitch) { effectControls.glitch = false; glitchPass.enabled = false; updateUIButtonState('glitch', false); } // Turn off general glitch
                    if (effectControls.xray) { effectControls.xray = false; xrayPass.enabled = false; updateUIButtonState('xray', false); } // Turn off xray
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.cctvFeed) { effectControls.cctvFeed = false; cctvFeedPass.enabled = false; updateUIButtonState('cctvFeed', false); } // Turn off CCTV
                    if (effectControls.heatmap) { effectControls.heatmap = false; heatmapPass.enabled = false; updateUIButtonState('heatmap', false); } // Turn off Heatmap
                    if (effectControls.blood) { effectControls.blood = false; bloodPass.enabled = false; updateUIButtonState('blood', false); } // Turn off Blood
                    if (effectControls.bloodText) { effectControls.bloodText = false; bloodTextMesh.visible = false; updateUIButtonState('bloodText', false); } // Turn off Blood Text
                    if (effectControls.biometricMarquee) { effectControls.biometricMarquee = false; biometricMarqueeTextMesh.visible = false; updateUIButtonState('biometricMarquee', false); } // Turn off Biometric
                    if (effectControls.marqueeText) { effectControls.marqueeText = false; marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false); } // Turn off Marquee
                    if (effectControls.matrix) { effectControls.matrix = false; matrixPass.enabled = false; updateUIButtonState('matrix', false); } // Turn off Matrix
                    if (effectControls.pixelation) { effectControls.pixelation = false; pixelationPass.enabled = false; updateUIButtonState('pixelation', false); } // Turn off Pixelation
                    if (effectControls.ascii) { effectControls.ascii = false; asciiPass.enabled = false; updateUIButtonState('ascii', false); } // Turn off Greyscale
                } else if (targetProperty === 'redacted') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'glitch') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'xray') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                    // If XRAY is turned on, ensure biometric marquee is turned off
                    if (effectControls.biometricMarquee) {
                        effectControls.biometricMarquee = false;
                        biometricMarqueeTextMesh.visible = false;
                        updateUIButtonState('biometricMarquee', false);
                    }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'biometricMarquee') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                    // If biometric marquee is turned on, ensure XRAY is turned off
                    if (effectControls.xray) {
                        effectControls.xray = false;
                        xrayPass.enabled = false;
                        marqueeTextMesh.visible = false; // Also hide main marquee if XRAY is off
                        updateUIButtonState('xray', false);
                    }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'threshold') {
                    if (effectControls.shadow) { effectControls.shadow = false; darkPass.enabled = false; updateUIButtonState('shadow', false); } // Updated to effectControls.shadow
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'shadow') {
                    if (effectControls.threshold) { effectControls.threshold = false; thresholdPass.enabled = false; updateUIButtonState('threshold', false); }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                }

                // Turn off all other non-combined visual effects if 'Anon' is being turned ON
                if (targetProperty === 'anon') {
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) && key !== 'anon' && key !== 'redacted' && key !== 'redactedGlitch' && key !== 'threshold' && key !== 'blood' && key !== 'glitch' && key !== 'marqueeText' && key !== 'biometricMarquee' && key !== 'yRotation' && key !== 'cameraAnimation' && key !== 'og' && key !== 'bloodText' && key !== 'hacker' && key !== 'surveillance' && key !== 'greed') { // Added greed
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Ensure redacted and redactedGlitch are off
                    effectControls.redacted = false; updateUIButtonState('redacted', false);
                    effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false);

                    // Turn off both marquees and blood text
                    effectControls.marqueeText = false; marqueeTextMesh.visible = false;
                    effectControls.biometricMarquee = false; biometricMarqueeTextMesh.visible = false;
                    effectControls.bloodText = false; bloodTextMesh.visible = false;
                    updateUIButtonState('marqueeText', false);
                    updateUIButtonState('biometricMarquee', false);
                    updateUIButtonState('bloodText', false);

                    // Turn off OG and Hacker and Surveillance and Greed if they're on
                    if (effectControls.og) {
                        effectControls.og = false;
                        asciiPass.enabled = false;
                        heatmapPass.enabled = false;
                        biometricMarqueeTextMesh.visible = false;
                        updateUIButtonState('og', false);
                    }
                    if (effectControls.hacker) {
                        effectControls.hacker = false;
                        updateUIButtonState('hacker', false);
                    }
                    if (effectControls.surveillance) {
                        effectControls.surveillance = false;
                        updateUIButtonState('surveillance', false);
                    }
                    if (effectControls.greed) {
                        effectControls.greed = false;
                        updateUIButtonState('greed', false);
                    }
                }

                // Handle turning on 'OG' effect (now also triggered by 'HACKER')
                if (targetProperty === 'og') {
                    // Turn off all other visual effects, excluding camera/y-rotation/feargreedindex
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) && key !== 'og' && key !== 'hacker' && key !== 'yRotation' && key !== 'cameraAnimation' && key !== 'bloodText' && key !== 'surveillance' && key !== 'greed') { // Added greed
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Specific cleanups for effects that don't have a pass or have special visibility
                    if (marqueeTextMesh) marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false);
                    if (rightEyeRedactionRect) { rightEyeRedactionRect.material.color.setHex(0x000000); rightEyeRedactionRect.visible = false; updateUIButtonState('redacted', false); }
                    if (leftEyeRedactionRect) { leftEyeRedactionRect.material.color.setHex(0x000000); leftEyeRedactionRect.visible = false; updateUIButtonState('redactedGlitch', false); }
                    if (bloodTextMesh) bloodTextMesh.visible = false; updateUIButtonState('bloodText', false);
                    if (biometricMarqueeTextMesh) biometricMarqueeTextMesh.visible = false; updateUIButtonState('biometricMarquee', false); // Ensure biometric is off if OG is turning on
                    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false; // Ensure redacted glitch text is off

                    // Turn off surveillance if OG is turned on
                    if (effectControls.surveillance) {
                        effectControls.surveillance = false;
                        updateUIButtonState('surveillance', false);
                    }
                    // Turn off greed if OG is turned on
                    if (effectControls.greed) {
                        effectControls.greed = false;
                        updateUIButtonState('greed', false);
                    }
                }

                // Handle turning on 'SURVEILLANCE' effect
                if (targetProperty === 'surveillance') {
                    // Turn off all other visual effects, excluding camera/y-rotation/feargreedindex
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) &&
                            key !== 'surveillance' &&
                            key !== 'heatmap' &&
                            key !== 'biometricMarquee' &&
                            key !== 'glitch' && // Added glitch to exclusion list for turning off
                            key !== 'yRotation' &&
                            key !== 'cameraAnimation' &&
                            key !== 'greed' // Exclude greed from being turned off by surveillance
                        ) {
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Specific cleanups for effects that don't have a pass or have special visibility
                    if (marqueeTextMesh) marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false);
                    if (rightEyeRedactionRect) { rightEyeRedactionRect.material.color.setHex(0x000000); rightEyeRedactionRect.visible = false; updateUIButtonState('redacted', false); }
                    if (leftEyeRedactionRect) { leftEyeRedactionRect.material.color.setHex(0x000000); leftEyeRedactionRect.visible = false; updateUIButtonState('redactedGlitch', false); }
                    if (bloodTextMesh) bloodTextMesh.visible = false; updateUIButtonState('bloodText', false);
                    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false; // Ensure redacted glitch text is off

                    // Ensure Anon, OG, Hacker are off
                    if (effectControls.anon) {
                        effectControls.anon = false;
                        updateUIButtonState('anon', false);
                    }
                    if (effectControls.og) {
                        effectControls.og = false;
                        updateUIButtonState('og', false);
                    }
                    if (effectControls.hacker) {
                        effectControls.hacker = false;
                        updateUIButtonState('hacker', false);
                    }
                }

                // Handle turning on 'GREED' effect
                if (targetProperty === 'greed') {
                    // Turn off all other visual effects, excluding camera/y-rotation/feargreedindex
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) &&
                            key !== 'greed' &&
                            key !== 'blood' &&
                            key !== 'bloodText' &&
                            key !== 'yRotation' &&
                            key !== 'cameraAnimation'
                        ) {
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Specific cleanups for effects that don't have a pass or have special visibility
                    if (marqueeTextMesh) marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false);
                    if (rightEyeRedactionRect) { rightEyeRedactionRect.material.color.setHex(0x000000); rightEyeRedactionRect.visible = false; updateUIButtonState('redacted', false); }
                    if (leftEyeRedactionRect) { leftEyeRedactionRect.material.color.setHex(0x000000); leftEyeRedactionRect.visible = false; updateUIButtonState('redactedGlitch', false); }
                    if (biometricMarqueeTextMesh) biometricMarqueeTextMesh.visible = false; updateUIButtonState('biometricMarquee', false);
                    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false; // Ensure redacted glitch text is off

                    // Ensure Anon, OG, Hacker, Surveillance, CCTV, Heatmap are off
                    if (effectControls.anon) {
                        effectControls.anon = false;
                        updateUIButtonState('anon', false);
                    }
                    if (effectControls.og) {
                        effectControls.og = false;
                        updateUIButtonState('og', false);
                    }
                    if (effectControls.hacker) {
                        effectControls.hacker = false;
                        updateUIButtonState('hacker', false);
                    }
                    if (effectControls.surveillance) {
                        effectControls.surveillance = false;
                        updateUIButtonState('surveillance', false);
                    }
                    if (effectControls.cctvFeed) {
                        effectControls.cctvFeed = false;
                        updateUIButtonState('cctvFeed', false);
                    }
                    if (effectControls.heatmap) {
                        effectControls.heatmap = false;
                        updateUIButtonState('heatmap', false);
                    }
                }

            } else if (targetProperty === 'shadow') { // If turning SHADOW OFF, also turn off Glitch if it was enabled by SHADOW
                if (effectControls.glitch) { // Check if glitch is currently active
                    // Only turn off glitch if it's not being used by another effect like 'Anon' or 'Redacted Glitch' or 'OG' or 'HACKER' or 'Surveillance' or 'Greed'
                    if (!effectControls.anon && !effectControls.redactedGlitch && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.glitch = false;
                        glitchPass.enabled = false;
                        updateUIButtonState('glitch', false);
                    }
                }
            }

            // Toggle the effect control state if it wasn't already toggled by 'hacker' logic
            if (property !== 'hacker') {
                effectControls[property] = !effectControls[property];
            }

            if (targetProperty === 'shadow') {
                darkPass.enabled = effectControls.shadow;
                // If SHADOW is active, also activate Glitch
                if (effectControls.shadow) {
                    effectControls.glitch = true;
                    glitchPass.enabled = true;
                } else { // If SHADOW is being turned off
                    // Only turn off glitch if it's not being used by another effect like 'Anon' or 'Redacted Glitch' or 'OG' or 'HACKER' or 'Surveillance' or 'Greed'
                    if (!effectControls.anon && !effectControls.redactedGlitch && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.glitch = false;
                        glitchPass.enabled = false;
                    }
                }
                updateUIButtonState('shadow', effectControls.shadow);
                updateUIButtonState('glitch', effectControls.glitch);
            } else if (targetProperty === 'og') {
                asciiPass.enabled = effectControls.og;
                heatmapPass.enabled = effectControls.og;
                biometricMarqueeTextMesh.visible = effectControls.og;
                updateUIButtonState('ascii', effectControls.og);
                updateUIButtonState('heatmap', effectControls.og);
                updateUIButtonState('biometricMarquee', effectControls.og);
                updateUIButtonState('og', effectControls.og);
                updateUIButtonState('hacker', effectControls.og); // Update HACKER button state
            } else if (targetProperty === 'bloodText') {
                // When bloodText is turned on, also ensure blood effect is on
                if (effectControls.bloodText) {
                    effectControls.blood = true;
                    bloodPass.enabled = true;
                    updateUIButtonState('blood', true);
                    // On initial enable, set bloodScrollOffset to ensure the text starts higher
                    if (bloodTextMesh && bloodTextMesh.material.map) {
                        bloodScrollOffset = bloodTextMesh.material.map.image.height; // Start at the bottom of the canvas
                        shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]);
                    }
                }
                bloodTextMesh.visible = effectControls.bloodText;
                updateUIButtonState('bloodText', effectControls.bloodText);
            } else if (targetProperty === 'surveillance') {
                // When SURVEILLANCE is turned on/off, toggle heatmap, biometric marquee, AND glitch
                effectControls.heatmap = effectControls.surveillance;
                heatmapPass.enabled = effectControls.surveillance;
                updateUIButtonState('heatmap', effectControls.surveillance);

                effectControls.biometricMarquee = effectControls.surveillance;
                biometricMarqueeTextMesh.visible = effectControls.surveillance;
                updateUIButtonState('biometricMarquee', effectControls.surveillance);

                effectControls.glitch = effectControls.surveillance; // Add glitch control
                glitchPass.enabled = effectControls.surveillance; // Enable/disable glitch pass
                updateUIButtonState('glitch', effectControls.surveillance); // Update glitch button state

                // Update the button for surveillance itself
                updateUIButtonState('surveillance', effectControls.surveillance);

            } else if (targetProperty === 'greed') {
                // When GREED is turned on/off, toggle blood and bloodText
                effectControls.blood = effectControls.greed;
                bloodPass.enabled = effectControls.greed;
                updateUIButtonState('blood', effectControls.greed);

                effectControls.bloodText = effectControls.greed;
                bloodTextMesh.visible = effectControls.greed;
                updateUIButtonState('bloodText', effectControls.greed);

                // If turning on, ensure text starts from bottom and reshuffle
                if (effectControls.greed) {
                    if (bloodTextMesh && bloodTextMesh.material.map) {
                        bloodScrollOffset = bloodTextMesh.material.map.image.height; // Start at the bottom of the canvas
                        shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]);
                    }
                }

                // Update the button for greed itself
                updateUIButtonState('greed', effectControls.greed);

            } else if (targetProperty === 'redactedGlitch') { // Handle Redacted Glitch effect toggle
                if (rightEyeRedactionRect) { rightEyeRedactionRect.material.color.setHex(0x000000); rightEyeRedactionRect.visible = effectControls.redactedGlitch; } // Set color to black
                if (leftEyeRedactionRect) { leftEyeRedactionRect.material.color.setHex(0x000000); leftEyeRedactionRect.visible = effectControls.redactedGlitch; } // Set color to black
                // redactedGlitchTextMesh.visible = effectControls.redactedGlitch;

                // When redactedGlitch is active, force threshold effect and glitch effect on
                if (effectControls.redactedGlitch) {
                    effectControls.threshold = true;
                    thresholdPass.enabled = true;
                    updateUIButtonState('threshold', true);
                    
                    // NEW: Force glitch on
                    effectControls.glitch = true;
                    glitchPass.enabled = true;
                    updateUIButtonState('glitch', true);

                    // Ensure shadow is off if threshold is forced on
                    if (effectControls.shadow) {
                        effectControls.shadow = false;
                        darkPass.enabled = false;
                        updateUIButtonState('shadow', false);
                    }
                }
                else { // If turning off redactedGlitch
                    // Only turn off threshold if no other effect is using it
                    if (!effectControls.redacted && !effectControls.anon && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.threshold = false;
                        thresholdPass.enabled = false;
                        updateUIButtonState('threshold', false);
                    }
                    // Only turn off glitch if no other effect is using it
                    if (!effectControls.shadow && !effectControls.anon && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.glitch = false;
                        glitchPass.enabled = false;
                        updateUIButtonState('glitch', false);
                    }
                }
                updateUIButtonState('redactedGlitch', effectControls.redactedGlitch);
                redactedGlitchTextMesh.visible = effectControls.redactedGlitch;

            } else if (pass) {
                pass.enabled = effectControls[targetProperty];
                updateUIButtonState(targetProperty, effectControls[targetProperty]);
            }

            // Update marquee text visibility based on XRAY only
            const shouldMarqueeBeVisible = effectControls.xray;
            if (effectControls.marqueeText !== shouldMarqueeBeVisible) {
                effectControls.marqueeText = shouldMarqueeBeVisible;
                marqueeTextMesh.visible = shouldMarqueeBeVisible;
            }

            // Toggle biometric marquee visibility (if not controlled by surveillance/OG/HACKER/GREED)
            if (targetProperty === 'biometricMarquee' && !effectControls.surveillance && !effectControls.og && !effectControls.hacker && !effectControls.greed) {
                biometricMarqueeTextMesh.visible = effectControls.biometricMarquee;
            }

            // Handle redacted effect toggle
            if (targetProperty === 'redacted') {
                if (rightEyeRedactionRect) { rightEyeRedactionRect.material.color.setHex(0x000000); rightEyeRedactionRect.visible = effectControls.redacted; } // Set color to black
                if (leftEyeRedactionRect) { leftEyeRedactionRect.material.color.setHex(0x000000); leftEyeRedactionRect.visible = effectControls.redacted; } // Set color to black
                // When redacted is active, force threshold effect and glitch effect on
                if (effectControls.redacted) {
                    effectControls.threshold = true;
                    thresholdPass.enabled = true;
                    updateUIButtonState('threshold', true);
                    
                    // NEW: Force glitch on
                    effectControls.glitch = true;
                    glitchPass.enabled = true;
                    updateUIButtonState('glitch', true);

                    // Ensure shadow is off if threshold is forced on
                    if (effectControls.shadow) {
                        effectControls.shadow = false;
                        darkPass.enabled = false;
                        updateUIButtonState('shadow', false);
                        // Also turn off glitch if it was enabled by shadow and not by other effects
                        if (!effectControls.anon && !effectControls.redactedGlitch && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                            effectControls.glitch = false;
                            glitchPass.enabled = false;
                            updateUIButtonState('glitch', false);
                        }
                    }
                } else {
                    if (!effectControls.redactedGlitch && !effectControls.anon && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.threshold = false;
                        thresholdPass.enabled = false;
                        updateUIButtonState('threshold', false);
                    }
                    // Only turn off glitch if no other effect is using it
                    if (!effectControls.shadow && !effectControls.anon && !effectControls.redactedGlitch && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.glitch = false;
                        glitchPass.enabled = false;
                        updateUIButtonState('glitch', false);
                    }
                }
            }

            // Handle Anon effect toggle
            if (targetProperty === 'anon') {
                if (effectControls.anon) {
                    thresholdPass.enabled = true;
                    bloodPass.enabled = true;
                    glitchPass.enabled = true;
                    if (rightEyeRedactionRect) { rightEyeRedactionRect.material.color.setHex(0x000000); rightEyeRedactionRect.visible = true; } // Set color to black
                    if (leftEyeRedactionRect) { leftEyeRedactionRect.material.color.setHex(0x000000); leftEyeRedactionRect.visible = true; } // Set color to black

                    // Ensure shadow is off if threshold is forced on by Anon
                    if (effectControls.shadow) {
                        effectControls.shadow = false;
                        darkPass.enabled = false;
                        updateUIButtonState('shadow', false);
                        // Glitch is already being turned on by Anon, so no need to turn off if it was from shadow
                    }
                }
                else {
                    thresholdPass.enabled = false;
                    bloodPass.enabled = false;
                    glitchPass.enabled = false;
                    if (rightEyeRedactionRect) { rightEyeRedactionRect.material.color.setHex(0x000000); rightEyeRedactionRect.visible = false; }
                    if (leftEyeRedactionRect) { leftEyeRedactionRect.material.color.setHex(0x000000); leftEyeRedactionRect.visible = false; }
                }
                // Update threshold, blood, glitch buttons to reflect Anon's state
                updateUIButtonState('threshold', effectControls.anon);
                updateUIButtonState('blood', effectControls.anon);
                updateUIButtonState('glitch', effectControls.anon);
            }

            // Handle camera animation toggle
            if (property === 'cameraAnimation') {
                cameraAnimationActive = effectControls.cameraAnimation;
                controls.enabled = !cameraAnimationActive;
                if (cameraAnimationActive) {
                    // Ensure Y-rotation is off if camera animation is activated
                    if (effectControls.yRotation) {
                        effectControls.yRotation = false;
                        updateUIButtonState('yRotation', false);
                    }
                    // Capture current camera state as the *initial* global start point for the loop
                    initialGlobalCameraPos.copy(camera.position);
                    initialGlobalCameraLookAt.copy(controls.target);
                    // Set loop start to global start for the first exploration
                    cameraPreviousPos.copy(initialGlobalCameraPos);
                    cameraPreviousLookAt.copy(initialGlobalCameraLookAt);
                    assetsVisitedCount = 0;
                    startCameraAnimation(performance.now());
                } else {
                    // Reset camera to default or current OrbitControls view when animation stops
                    camera.position.copy(initialGlobalCameraPos);
                    controls.target.copy(initialGlobalCameraLookAt);
                    camera.lookAt(controls.target);
                    cameraAnimationState = 'idle';
                    assetsVisitedCount = 0;
                    // Re-enable controls if Y-rotation is not active
                    if (!effectControls.yRotation) {
                        controls.enabled = true;
                    }
                }
                yRotationStartTime = 0; // Reset Y-rotation auto-start timer if camera anim is manually toggled
            }

            // Handle Y-axis rotation toggle
            if (property === 'yRotation') {
                if (effectControls.yRotation) {
                    // When Y-rotation starts, disable OrbitControls and camera animation
                    controls.enabled = false;
                    cameraAnimationActive = false;
                    updateUIButtonState('cameraAnimation', false);
                    // Store initial camera position for the bounce animation
                    yBounceInitialCameraX = camera.position.x;
                    yBounceInitialCameraY = camera.position.y;
                    yBounceInitialCameraZ = camera.position.z;
                    yRotationStartTime = performance.now(); // Record start time for Y-rotation
                } else {
                    // When Y-rotation stops, re-enable OrbitControls if no other camera animation is active
                    if (!cameraAnimationActive) {
                        controls.enabled = true;
                    }
                    // Optionally reset camera to its original position before bounce
                    camera.position.set(yBounceInitialCameraX, yBounceInitialCameraY, yBounceInitialCameraZ);
                    controls.target.set(0, 0, layerToZ(1));
                    camera.lookAt(controls.target);
                    yRotationStartTime = 0; // Reset Y-rotation auto-start timer if Y-rotation is manually toggled off
                }
                lastActivityTime = performance.now();
            }
            
            // --- NEW: Update face material brightness after any effect toggle ---
            updateFaceMaterialBrightness();
        };
        button.setAttribute('data-effect', property);
        parentContainer.appendChild(button);
    };

    // Helper to get pass by name
    const getPassByName = (name) => {
        switch (name) {
            case 'greyscale': return greyscalePass;
            case 'threshold': return thresholdPass;
            case 'shadow': return darkPass;
            case 'pixelation': return pixelationPass;
            case 'glitch': return glitchPass;
            case 'matrix': return matrixPass;
            case 'ascii': return asciiPass;
            case 'xray': return xrayPass;
            case 'heatmap': return heatmapPass;
            case 'blood': return bloodPass;
            case 'cctvFeed': return cctvFeedPass;
            default: return null;
        }
    };

    // Define buttons to be added to both UIs
    const buttonsConfig = [
        { label: '3D', property: 'yRotation', pass: null },
        { label: 'FLY', property: 'cameraAnimation', pass: null },
        { label: 'SHADOW', property: 'shadow', pass: darkPass },
        { label: 'ASCII', property: 'ascii', pass: asciiPass },
        { label: 'HEATMAP', property: 'heatmap', pass: heatmapPass },
        { label: 'BLOOD', property: 'blood', pass: bloodPass },
        { label: 'REDACTED', property: 'redactedGlitch', pass: null },
        { label: 'ANON', property: 'anon', pass: null },
        { label: 'BIOMETRIC', property: 'biometricMarquee', pass: null },
        { label: 'OG', property: 'og', pass: null },
        { label: 'BLOOD TEXT', property: 'bloodText', pass: null },
        { label: 'DATA SCRAPER', property: 'hacker', pass: null },
        { label: 'BIO-CODER', property: 'surveillance', pass: null },
        { label: 'HIDDEN HAND', property: 'greed', pass: null },
        { label: 'Greyscale', property: 'greyscale', pass: greyscalePass },
        { label: 'Threshold', property: 'threshold', pass: thresholdPass },
        { label: 'Pixelation', property: 'pixelation', pass: pixelationPass },
        { label: 'Glitch', property: 'glitch', pass: glitchPass },
        { label: 'Matrix', property: 'matrix', pass: matrixPass },
        { label: 'XRAY', property: 'xray', pass: xrayPass },
        { label: 'CCTV FEED', property: 'cctvFeed', pass: cctvFeedPass },

    ];

    // Create and append the left UI container
    leftUiContainer = document.createElement('div'); // Assign to global variable
    leftUiContainer.id = 'left-ui-container';
    leftUiContainer.style.position = 'absolute';
    leftUiContainer.style.top = '-190px'; // Start mostly hidden, revealing only the arrow
    leftUiContainer.style.left = '10px';
    leftUiContainer.style.backgroundColor = 'rgba(0, 0, 0, 0)';
    leftUiContainer.style.color = 'white';
    leftUiContainer.style.padding = '10px'; /* Reduced padding for more compact layout */
    leftUiContainer.style.borderRadius = '5px';
    leftUiContainer.style.fontFamily = 'monospace';
    leftUiContainer.style.zIndex = '100';
    leftUiContainer.style.display = 'flex';
    leftUiContainer.style.flexDirection = 'column'; /* Changed to column for vertical layout */
    leftUiContainer.style.flexWrap = 'nowrap'; /* Not needed for single column */
    leftUiContainer.style.gap = '5px'; /* Adjusted gap for vertical layout */
    leftUiContainer.style.transition = 'top 0.5s ease-in-out'; // Smooth transition for top property
    document.body.appendChild(leftUiContainer);

    // Create and append the right UI container
    const rightUiContainer = document.createElement('div');
    rightUiContainer.id = 'right-ui-container';
    rightUiContainer.style.position = 'absolute';
    rightUiContainer.style.top = '10px';
    rightUiContainer.style.right = '10px';
    rightUiContainer.style.backgroundColor = 'rgba(0, 0, 0, 0)';
    rightUiContainer.style.color = 'white';
    rightUiContainer.style.padding = '10px';
    rightUiContainer.style.borderRadius = '5px';
    rightUiContainer.style.fontFamily = 'monospace';
    rightUiContainer.style.zIndex = '100';
    rightUiContainer.style.display = 'none'; // Hide the right UI container
    rightUiContainer.style.flexDirection = 'column';
    rightUiContainer.style.gap = '5px';
    document.body.appendChild(rightUiContainer);

    // Define the desired order of buttons for the left UI
    const leftUiOrder = [
        'yRotation', // 3D
        'cameraAnimation', // FLY
        'surveillance', // NEW SURVEILLANCE BUTTON
        'greed', // NEW GREED BUTTON (now ULTERIOR MOVTIVES)
        'hacker', // HACKER moved to position 5
        'shadow',
        'redactedGlitch'
    ];

    // Map property names to their full config objects for easy lookup
    const buttonConfigMap = new Map(buttonsConfig.map(config => [config.property, config]));

    // Add buttons to the left UI container in the specified order
    leftUiOrder.forEach(propertyName => {
        const config = buttonConfigMap.get(propertyName);
        if (config) {
            addButtonToggle(leftUiContainer, config.label, config.property, config.pass);
        }
    });

    // Add all buttons to the right UI container
    buttonsConfig.forEach(config => {
        if (!leftUiOrder.includes(config.property)) { // Only add if not already in left UI
            addButtonToggle(rightUiContainer, config.label, config.property, config.pass);
        }
    });

    // Add the RESET button to both UI containers
    const createResetButton = () => {
        const button = document.createElement('button');
        button.textContent = 'RESET';
        button.style.cssText = `
            background-color: black; /* Changed from #CC0000 to black */
            color: white;
            padding: 4px;
            margin-top: 10px;
            border: 0.5px solid rgba(0, 0, 0, 0.8);
            border-radius: 0;
            cursor: pointer;
            font-family: monospace;
            font-size: 7px;
            outline: none;
            white-space: nowrap;
            box-sizing: border-box;
        `;
        button.onmouseover = () => { button.style.borderColor = 'rgba(0, 0, 0, 1.0)'; };
        button.onmouseout = () => { button.style.borderColor = 'rgba(0, 0, 0, 0.8)'; };
        button.onclick = (event) => { event.stopPropagation(); resetPiecesToOriginalPositions(); };
        return button;
    };
    leftUiContainer.appendChild(createResetButton());
    rightUiContainer.appendChild(createResetButton());

    // Create and append the TRASH button to the left UI container
    const createTrashButton = () => {
        const button = document.createElement('button');
        button.id = 'trash-button'; // Unique ID for easy targeting
        button.innerHTML = 'TRASH'; // Text with trashcan icon
        button.style.cssText = `
            background-color: black; /* Changed from #CC0000 to black */
            color: white;
            padding: 4px;
            margin-top: 10px;
            border: none;
            border-radius: 0;
            cursor: pointer;
            font-family: monospace;
            font-size: 7px;
            outline: none;
            white-space: nowrap;
            box-sizing: border-box;
        `;
        button.onmouseover = () => { }; /* Removed border change on hover */
        button.onmouseout = () => { }; /* Removed border change on mouseout */
        // The actual removal logic will be in onPointerUp, triggered by dropping onto this button
        return button;
    };
    trashButtonElement = createTrashButton(); // Store reference to the button element
    leftUiContainer.appendChild(trashButtonElement);

    // Add the thin black rectangle with a down-facing arrow below the TRASH button
    arrowContainer = document.createElement('div'); // Assign to global variable
    arrowContainer.id = 'arrow-container'; // Add ID for better targeting
    arrowContainer.style.cssText = `
        position: absolute; /* Position relative to the viewport */
        top: 0px; /* Initially at the top, peeking out */
        left: 20px;
        background-color: black;
        width: 60px; /* Fixed width for the arrow tab */
        height: 15px; /* Height of the arrow tab */
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        z-index: 101; /* Higher z-index than leftUiContainer to be clickable */
        border-bottom-left-radius: 5px; /* Rounded corners for the tab */
        border-bottom-right-radius: 5px;
        transition: top 0.5s ease-in-out; /* Smooth transition for top property */
        box-sizing: border-box; /* Include padding and border in the element's total width and height */
    `;
    const arrowSpan = document.createElement('span');
    arrowSpan.style.cssText = `
        color: white;
        font-size: 10px; /* Larger arrow */
    `;
    arrowSpan.innerHTML = '&#x25BC;'; // Down-facing triangle
    arrowContainer.appendChild(arrowSpan);
    document.body.appendChild(arrowContainer); // Append to body, not leftUiContainer

    // Add click listener for the arrow container to toggle left UI visibility
    arrowContainer.onclick = (event) => {
        event.stopPropagation(); // Prevent clicks from interacting with 3D scene
        if (leftUiContainer.style.top === '10px') {
            leftUiContainer.style.top = '-190px'; // Hide it, revealing only the arrow
            trashButtonElement.style.display = 'none'; // Hide TRASH button
            arrowContainer.style.top = '0px'; // Keep arrow at the top
            arrowSpan.innerHTML = '&#x25BC;'; // Change to down arrow
        } else {
            leftUiContainer.style.top = '10px'; // Show it
            trashButtonElement.style.display = 'block'; // Show TRASH button
            arrowContainer.style.top = `${leftUiContainer.offsetHeight + 10}px`; // Move arrow below the UI
            arrowSpan.innerHTML = '&#x25B2'; // Change to up arrow
        }
    };

    // Initial state setup for TRASH button and arrowContainer
    // When the page loads, the left UI is hidden, so the trash button should be hidden. 
    trashButtonElement.style.display = 'none';

    window.addEventListener('resize', onWindowResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
    renderer.domElement.addEventListener('click', onClick);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    if (composer) {
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    if (pixelationPass) {
        pixelationPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    }
    if (asciiPass) {
        asciiPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    }
    if (cctvFeedPass) {
        cctvFeedPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    }

    // Adjust arrow container position on resize if UI is open
    if (leftUiContainer.style.top === '10px') {
        arrowContainer.style.top = `${leftUiContainer.offsetHeight + 10}px`;
    }

    lastActivityTime = performance.now();
    stopCameraAnimationAndReset();
}

function onPointerDown(event) {
    lastActivityTime = performance.now();
    // stopCameraAnimationAndReset(); // Removed: Only stop FLY camera on explicit click
    isDragging = false;
    pointerDownPosition.set(event.clientX, event.clientY);

    // Check if the click is on a UI element
    if (event.target.closest('#left-ui-container') || event.target.closest('#right-ui-container') || event.target.closest('#arrow-container')) {
        selectedObject = null;
        controls.enabled = true;
        return;
    }

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(draggableObjects, true); // Intersect with all descendants

    // Filter intersects to only consider those with alpha > 0.1
    for (const intersect of intersects) {
        const object = intersect.object;
        const material = object.material;

        // Ensure the material has a map property before trying to access its alpha
        if (material && material.map && material.transparent) {
            const uv = intersect.uv;
            const alpha = getAlphaAtUV(material.map, uv);

            if (alpha > 0.1) { // Alpha threshold for drag detection
                selectedObject = object;
                controls.enabled = false;
                initialObjectZ = selectedObject.position.z;
                offset.copy(intersect.point).sub(selectedObject.position);
                break; // Found a draggable opaque part, stop searching
            }
        } else if (material instanceof THREE.ShaderMaterial && material.alphaTest !== undefined && material.alphaTest > 0) {
            // For ShaderMaterial with alphaTest, treat as always opaque if intersect occurs
            selectedObject = object;
            controls.enabled = false;
            initialObjectZ = selectedObject.position.z;
            offset.copy(intersect.point).sub(selectedObject.position);
            break; // Found a draggable opaque part, stop searching
        } else if (material && !material.transparent) {
            // For opaque materials, any intersect means it's draggable
            selectedObject = object;
            controls.enabled = false;
            initialObjectZ = selectedObject.position.z;
            offset.copy(intersect.point).sub(selectedObject.position);
            break; // Found a draggable opaque part, stop searching
        }
    }
}

function onPointerMove(event) {
    lastActivityTime = performance.now();
    // stopCameraAnimationAndReset(); // Removed: Only stop FLY camera on explicit click
    if (selectedObject) {
        // Check if the pointer has moved beyond the drag threshold
        const currentPointerPosition = new THREE.Vector2(event.clientX, event.clientY);
        if (currentPointerPosition.distanceTo(pointerDownPosition) > DRAG_THRESHOLD) {
            isDragging = true;
        }

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // Create a plane that is parallel to the camera's view plane
        // and passes through the object's initial Z-position.
        const plane = new THREE.Plane();
        plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), new THREE.Vector3(0, 0, initialObjectZ));

        const intersection = new THREE.Vector3();
        if (raycaster.ray.intersectPlane(plane, intersection)) {
            // Update X and Y, but keep the original Z-position
            selectedObject.position.x = intersection.x - offset.x;
            selectedObject.position.y = intersection.y - offset.y;
            selectedObject.position.z = initialObjectZ;

            // Update redaction rectangle positions if the selected object is an eye
            if (selectedObject === rightEyeMesh) {
                if (rightEyeRedactionRect) {
                    rightEyeRedactionRect.position.x = selectedObject.position.x;
                    rightEyeRedactionRect.position.y = selectedObject.position.y;
                }
            } else if (selectedObject === leftEyeMesh) {
                if (leftEyeRedactionRect) {
                    leftEyeRedactionRect.position.x = selectedObject.position.x;
                    leftEyeRedactionRect.position.y = selectedObject.position.y;
                }
            }
        }
    }
}

function onPointerUp(event) {
    lastActivityTime = performance.now();
    // stopCameraAnimationAndReset(); // Removed: Only stop FLY camera on explicit click

    if (isDragging && selectedObject) {
        // Check if the pointer was released over the TRASH button
        if (trashButtonElement) {
            const rect = trashButtonElement.getBoundingClientRect();

            // Define a larger target area for the trash button
            const expandedRect = {
                left: rect.left - 20, // 20 pixels extra padding on left
                right: rect.right + 20, // 20 pixels extra padding on right
                top: rect.top - 20, // 20 pixels extra padding on top
                bottom: rect.bottom + 20 // 20 pixels extra padding on bottom
            };

            if (event.clientX >= expandedRect.left && event.clientX <= expandedRect.right &&
                event.clientY >= expandedRect.top && event.clientY <= expandedRect.bottom) {

                // Mark the object as removed in the initialAssetConfigs for later reloading
                // Need to handle single instance assets (by ID) vs multi-instance assets (by originalId)
                const originalId = selectedObject.userData.originalId || selectedObject.userData.id;
                const configIndex = initialAssetConfigs.findIndex(config => config.id === originalId);
                
                if (configIndex !== -1 && initialAssetConfigs[configIndex].instanceCount === undefined) {
                    // Single instance asset: mark as removed
                    initialAssetConfigs[configIndex].removed = true;
                }
                // Multi-instance assets are simply removed from the scene/arrays, they will be regenerated on reset

                // Object was dropped onto the trash button, remove it
                scene.remove(selectedObject);
                // Remove from draggableObjects array
                draggableObjects = draggableObjects.filter(obj => obj !== selectedObject);
                // Remove from cameraAnimationTargets array
                cameraAnimationTargets = cameraAnimationTargets.filter(obj => obj !== selectedObject);
                
                // Remove from faceMeshes array if it was a face part
                faceMeshes = faceMeshes.filter(obj => obj !== selectedObject);

                // Dispose of geometry and material to free up memory
                if (selectedObject.geometry) selectedObject.geometry.dispose();
                if (selectedObject.material) {
                    // Only dispose of materials if they are not shared ShaderMaterials (like the BrightenShader)
                    if (Array.isArray(selectedObject.material)) {
                        selectedObject.material.forEach(m => { if (!(m instanceof THREE.ShaderMaterial)) m.dispose(); });
                    } else if (!(selectedObject.material instanceof THREE.ShaderMaterial)) {
                        selectedObject.material.dispose();
                    }
                }
                
                // Dispose of the original and brighten materials stored in userData if they exist
                if (selectedObject.userData.originalMaterial) selectedObject.userData.originalMaterial.dispose();
                if (selectedObject.userData.brightenMaterial) selectedObject.userData.brightenMaterial.dispose();

                // Special handling for specific removed objects (set global refs to null)
                if (selectedObject.userData.id === 'dogecoin') {
                    dogecoinRef = null;
                }
                if (selectedObject.userData.id === 'rightEye') {
                    if (rightEyeRedactionRect) { scene.remove(rightEyeRedactionRect); rightEyeRedactionRect.geometry.dispose(); rightEyeRedactionRect.material.dispose(); }
                    rightEyeMesh = null;
                    rightEyeRedactionRect = null;
                }
                if (selectedObject.userData.id === 'leftEye') {
                    if (leftEyeRedactionRect) { scene.remove(leftEyeRedactionRect); leftEyeRedactionRect.geometry.dispose(); leftEyeRedactionRect.material.dispose(); }
                    leftEyeMesh = null;
                    leftEyeRedactionRect = null;
                }
                console.log("Object removed:", selectedObject.name || selectedObject.uuid);
            }
        }
    }

    selectedObject = null;
    // Re-enable controls only if camera animation AND yRotation are not active
    if (!cameraAnimationActive && !effectControls.yRotation) {
        controls.enabled = true;
    }
    // isDragging is reset by onPointerDown for the next interaction
}

function onClick(event) {
    lastActivityTime = performance.now();
    // Use performance.now() to get current time for button interactions
    const currentTime = performance.now();
    // stopCameraAnimationAndReset(); // Moved: Only stop FLY camera on explicit click
    // Only process click if no dragging occurred and not clicking on UI
    if (isDragging || event.target.closest('#left-ui-container') || event.target.closest('#right-ui-container') || event.target.closest('#arrow-container')) {
        return;
    }

    stopCameraAnimationAndReset(); // Only stop FLY camera on explicit click if not dragging and not on UI

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(draggableObjects, true); // Intersect with all descendants

    // Filter intersects to only consider those with alpha > 0.1
    let clickedObject = null;
    for (const intersect of intersects) {
        const object = intersect.object;
        const material = object.material;

        // Special handling for ShaderMaterial with alphaTest, as getAlphaAtUV is for MeshBasicMaterial
        if (material instanceof THREE.ShaderMaterial && material.alphaTest !== undefined && material.alphaTest > 0) {
            clickedObject = object;
            break;
        } else if (material && material.map && material.transparent) {
            const uv = intersect.uv;
            const alpha = getAlphaAtUV(material.map, uv);

            if (alpha > 0.1) { // Alpha threshold for click detection
                clickedObject = object;
                break; // Found a clickable opaque part, stop searching
            }
        }
        else if (material && !material.transparent) {
            // For opaque materials, any intersect means it's clickable
            clickedObject = object;
            break; // Found a clickable opaque part, stop searching
        }
    }

    if (clickedObject) {
        // --- Handle Thumb-Up Flip and Depth Cycle on Click ---
        if (clickedObject.userData.originalId === 'thumb-up') {
            // 1. Flip the image vertically (180 degrees rotation around X-axis)
            clickedObject.userData.flipped = !clickedObject.userData.flipped;
            clickedObject.rotation.x += Math.PI; // Add 180 degrees (PI radians) to X rotation
            
            // 2. Cycle through depth layers (maxLayer down to minLayer) in the INVERTED direction
            let currentLayer = clickedObject.userData.currentLayer || maxLayer;
            
            // Move one layer backward (e.g., 20 -> 19, 1 -> 0, -5 -> -6)
            currentLayer = Math.round(currentLayer) - 1; 
            
            // Wrap around: if layer goes past minLayer (-5, i.e., reaches -6), wrap back to maxLayer (20)
            if (currentLayer < minLayer) { 
                currentLayer = maxLayer; // Wrap from -6 to 20
            }
            
            // Re-apply the layer number to the object's userData
            clickedObject.userData.currentLayer = currentLayer;
            clickedObject.position.z = layerToZ(currentLayer);

            console.log(`Thumb-up moved to layer: ${currentLayer}, Z-position: ${clickedObject.position.z}`);
            return;
        }

        // --- Handle FB Phone (Blue Bill) Layer Cycle and Image Swap ---
        if (clickedObject.userData.id === 'fbphone') {
            // 1. Cycle through depth layers (maxLayer down to minLayer)
            let currentLayer = clickedObject.userData.currentLayer || maxLayer;
            
            // Move one layer backward
            currentLayer = Math.round(currentLayer) - 1;
            
            // Wrap around: if layer goes past minLayer (-5, i.e., reaches -6), wrap back to maxLayer (20)
            if (currentLayer < minLayer) {
                currentLayer = maxLayer; // Wrap around to the highest layer (20)
            }
            clickedObject.userData.currentLayer = currentLayer;
            clickedObject.position.z = layerToZ(currentLayer);

            // 2. Switch between the two images (URL_BLUE_BILL and URL_ZUCK_PHONE_2)
            let nextTextureUrl;
            if (clickedObject.userData.currentTextureUrl === URL_BLUE_BILL) {
                nextTextureUrl = URL_ZUCK_PHONE_2;
            } else {
                nextTextureUrl = URL_BLUE_BILL;
            }

            // Load the new texture and apply it
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(nextTextureUrl, (newTexture) => {
                configureTexture(newTexture, renderer); // Apply texture settings
                // Determine the new dimensions based on the aspect ratio of the new texture
                const initialScale = clickedObject.userData.initialScale;
                const targetHeight = initialScale.height;
                const targetWidth = targetHeight * (newTexture.image.width / newTexture.image.height);

                // Dispose of old geometry and material map
                clickedObject.geometry.dispose();
                if (clickedObject.material.map) clickedObject.material.map.dispose();

                // Create new geometry
                clickedObject.geometry = new THREE.PlaneGeometry(targetWidth, targetHeight);
                // Update material map
                clickedObject.material.map = newTexture;
                clickedObject.material.needsUpdate = true;
                
                // Store the new current texture URL
                clickedObject.userData.currentTextureUrl = nextTextureUrl;
            });
            return;
        }

        // Handle Dogecoin/Tesla logo swap
        if (clickedObject === dogecoinRef) {
            let newTexture;
            
            // If currently showing the original Dogecoin texture (color),
            // switch to Tesla texture with color material.
            if (dogecoinRef.material.map === dogecoinRef.userData.originalTexture) {
                newTexture = teslaTexture;
                dogecoinRef.material = teslaColorMaterial;
            } else { // If currently showing Tesla texture (color),
                // switch back to original Dogecoin texture with basic material.
                dogecoinRef.material = new THREE.MeshBasicMaterial({ map: dogecoinRef.userData.originalTexture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
            }
            dogecoinRef.material.needsUpdate = true;
            newTexture = dogecoinRef.material.map; // Set newTexture reference correctly for geometry update

            // Dispose of old geometry to prevent memory leaks
            dogecoinRef.geometry.dispose();
            // Create new geometry with updated dimensions based on the new texture's aspect ratio
            // Use the initial height of the Tesla logo as a reference to keep vertical scale consistent.
            const targetHeight = dogecoinRef.userData.initialScale.height;
            const targetWidth = targetHeight * (newTexture.image.width / newTexture.image.height);
            dogecoinRef.geometry = new THREE.PlaneGeometry(targetWidth, targetHeight);
        }

        // Skip depth cycling for non-draggable elements or those with special handling
        if (clickedObject === backgroundMesh || clickedObject === rightEyeRedactionRect || clickedObject === leftEyeRedactionRect || clickedObject === marqueeTextMesh || clickedObject === biometricMarqueeTextMesh || clickedObject === bloodTextMesh || clickedObject === redactedGlitchTextMesh) { // Added redactedGlitchTextMesh
            return;
        }

        // Cycle through depth levels for ALL OTHER ASSETS (maxLayer down to minLayer)
        let currentLayer = clickedObject.userData.currentLayer || maxLayer;
        
        // Move backward one layer
        currentLayer = Math.round(currentLayer) - 1;
        
        // Wrap around: if layer goes past minLayer (-5, i.e., reaches -6), wrap back to maxLayer (20)
        if (currentLayer < minLayer) {
            currentLayer = maxLayer; // Wrap around to the highest layer (20)
        }
        
        clickedObject.userData.currentLayer = currentLayer;
        clickedObject.position.z = layerToZ(currentLayer);

        // Update redaction rectangle Z position if the clicked object is an eye
        if (clickedObject === rightEyeMesh) {
            if (rightEyeRedactionRect) {
                rightEyeRedactionRect.position.z = clickedObject.position.z + (1.5 * depthStep);
            }
        }
        else if (clickedObject === leftEyeMesh) {
            if (leftEyeRedactionRect) {
                leftEyeRedactionRect.position.z = clickedObject.position.z + (1.5 * depthStep);
            }
        }

        console.log(`Object moved to layer: ${currentLayer}, Z-position: ${clickedObject.position.z}`);
    }
}

// Ease-in-out function
function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function startCameraAnimation(currentTime) {
    if (!cameraAnimationActive || cameraAnimationTargets.length === 0) return;

    // Store current camera state as the start for the next animation segment
    cameraPreviousPos.copy(camera.position);
    cameraPreviousLookAt.copy(controls.target);
    cameraAnimationStartTime = currentTime;

    let duration = 0;
    if (cameraAnimationState === 'exploring') {
        duration = cameraExplorationDuration;
    }
    else if (cameraAnimationState === 'returningToGlobalStart') {
        duration = cameraReturnDuration;
    }

    if (cameraAnimationState === 'returningToGlobalStart' || assetsVisitedCount >= ASSETS_PER_GLOBAL_RETURN) {
        cameraAnimationState = 'exploring';
        assetsVisitedCount = 0;

        // Pick a random target for the next exploration
        let newTarget;
        do {
            newTarget = cameraAnimationTargets[Math.floor(Math.random() * cameraAnimationTargets.length)];
        } while (newTarget === cameraTargetObject && cameraAnimationTargets.length > 1);
        cameraTargetObject = newTarget;

        // Calculate end position and lookAt based on the target object
        const targetPos = cameraTargetObject.position;
        const targetBounds = new THREE.Box3().setFromObject(cameraTargetObject);
        const center = targetBounds.getCenter(new THREE.Vector3());
        const size = targetBounds.getSize(new THREE.Vector3());

        const fovRad = THREE.MathUtils.degToRad(camera.fov);
        const baseDistance = Math.max(size.x, size.y) / (2 * Math.tan(fovRad / 2));

        const minZOffset = baseDistance * 0.8;
        const maxZOffset = baseDistance * 1.5;
        const randomZOffset = minZOffset + (Math.random() * (maxZOffset - minZOffset));

        const lateralOffsetRange = baseDistance * 0.5;
        const randomOffsetX = (Math.random() - 0.5) * lateralOffsetRange;
        const randomOffsetY = (Math.random() - 0.5) * lateralOffsetRange;

        cameraCurrentTargetPos.set(
            center.x + randomOffsetX,
            center.y + randomOffsetY,
            targetPos.z + randomZOffset
        );

        cameraCurrentTargetLookAt.copy(center);

        cameraCurrentTargetPos.z = THREE.MathUtils.clamp(cameraCurrentTargetPos.z, -5, 20); // Clamped Z to maxLayer 20

    } else { // Continue exploring
        cameraAnimationState = 'exploring';
        assetsVisitedCount++;

        // Pick a random target, ensuring it's not the same as the previous one if possible
        let newTarget;
        do {
            newTarget = cameraAnimationTargets[Math.floor(Math.random() * cameraAnimationTargets.length)];
        } while (newTarget === cameraTargetObject && cameraAnimationTargets.length > 1);
        cameraTargetObject = newTarget;

        // Calculate end position and lookAt based on the target object
        const targetPos = cameraTargetObject.position;
        const targetBounds = new THREE.Box3().setFromObject(cameraTargetObject);
        const center = targetBounds.getCenter(new THREE.Vector3());
        const size = targetBounds.getSize(new THREE.Vector3());

        // Determine a suitable base distance to frame the object based on its size and camera FOV
        const fovRad = THREE.MathUtils.degToRad(camera.fov);
        const baseDistance = Math.max(size.x, size.y) / (2 * Math.tan(fovRad / 2));

        // Introduce randomness to the Z-distance from the target object
        const minZOffset = baseDistance * 0.8;
        const maxZOffset = baseDistance * 1.5;
        const randomZOffset = minZOffset + (Math.random() * (maxZOffset - minZOffset));

        // Set a random offset around the target object for camera position in X and Y
        const lateralOffsetRange = baseDistance * 0.5;
        const randomOffsetX = (Math.random() - 0.5) * lateralOffsetRange;
        const randomOffsetY = (Math.random() - 0.5) * lateralOffsetRange;

        cameraCurrentTargetPos.set(
            center.x + randomOffsetX,
            center.y + randomOffsetY,
            targetPos.z + randomZOffset
        );

        cameraCurrentTargetLookAt.copy(center);

        // Clamp cameraCurrentTargetPos.z to be within reasonable bounds for the scene
        cameraCurrentTargetPos.z = THREE.MathUtils.clamp(cameraCurrentTargetPos.z, -5, 20); // Clamped Z to maxLayer 20
    }
}

function updateCameraAnimation(currentTime) {
    if (cameraAnimationState === 'idle' || !cameraAnimationActive) return;

    const elapsed = currentTime - cameraAnimationStartTime;

    let duration = 0;
    if (cameraAnimationState === 'exploring') {
        duration = cameraExplorationDuration;
    }
    else if (cameraAnimationState === 'returningToGlobalStart') {
        duration = cameraReturnDuration;
    }

    let t = Math.min(1, elapsed / duration);
    t = easeInOutCubic(t);

    camera.position.lerpVectors(cameraPreviousPos, cameraCurrentTargetPos, t);
    controls.target.lerpVectors(cameraPreviousLookAt, cameraCurrentTargetLookAt, t);

    if (elapsed >= duration) {
        // If returning to global start, then after completion, start a new exploration cycle
        if (cameraAnimationState === 'returningToGlobalStart') {
            cameraAnimationState = 'exploring';
            assetsVisitedCount = 0;
        }
        startCameraAnimation(currentTime);
    }
    camera.lookAt(controls.target);
}

function animate(currentTime) {
    requestAnimationFrame(animate);

    // Auto-start Y-rotation and Camera Animation are now controlled only by button presses.
    // The following blocks have been removed to prevent automatic activation.

    // Apply Y-rotation if explicitly enabled
    if (effectControls.yRotation) {
        // Ensure camera animation is turned off if Y-rotation is activated
        if (cameraAnimationActive) {
            cameraAnimationActive = false;
            updateUIButtonState('cameraAnimation', false);
        }
        controls.enabled = false;
        const convergencePoint = new THREE.Vector3(0, 0, layerToZ(1));
        camera.position.x = yBounceInitialCameraX + yBounceRangeX * Math.sin(currentTime * yBounceSpeed);
        camera.position.y = yBounceInitialCameraY;
        camera.position.z = yBounceInitialCameraZ;
        camera.lookAt(convergencePoint);
    }

    // Apply Camera Animation if explicitly enabled
    if (cameraAnimationActive) {
        // Ensure Y-rotation is turned off if camera animation is active
        if (effectControls.yRotation) {
            effectControls.yRotation = false;
            updateUIButtonState('yRotation', false);
        }
        controls.enabled = false;
        updateCameraAnimation(currentTime);
    } else if (!effectControls.yRotation) {
        controls.update();
    }

    // Update the time uniform for the CCTVFeedShader
    if (cctvFeedPass.enabled) {
        cctvFeedPass.uniforms['time'].value = currentTime * 0.001;
    }

    // Update marquee text scrolling
    if (effectControls.xray) { // Marquee text is now only tied to XRAY effect
        marqueeScrollOffset -= MARQUEE_SCROLL_SPEED;
        // Reset offset when one full set of lines has scrolled off
        if (marqueeScrollOffset <= -MARQUEE_LINE_HEIGHT * MARQUEE_TOTAL_LINES) {
            marqueeScrollOffset = 0;
        }
        updateMarqueeTexture();
    }

    // Update biometric marquee text scrolling
    if (effectControls.biometricMarquee || effectControls.og || effectControls.hacker || effectControls.surveillance || effectControls.greed) { // Update if either biometric or OG or HACKER or SURVEILLANCE or GREED is active
        biometricMarqueeScrollOffset -= BIOMETRIC_MARQUEE_SCROLL_SPEED;
        if (biometricMarqueeScrollOffset <= -BIOMETRIC_MARQUEE_LINE_HEIGHT * BIOMETRIC_MARQUEE_TOTAL_LINES) {
            biometricMarqueeScrollOffset = 0;
        }
        updateBiometricMarqueeTexture(currentTime);
    }

    // Update blood text scrolling
    if (effectControls.bloodText) {
        bloodScrollOffset -= BLOOD_TEXT_SCROLL_SPEED;
        const singleSetHeight = BLOOD_TEXT_LINE_HEIGHT * BLOOD_TEXT_TOTAL_LINES;

        // When the first set of phrases has scrolled completely off the top of the canvas,
        // wrap it around to the bottom, effectively creating a continuous loop.
        if (bloodScrollOffset <= -singleSetHeight) {
            bloodScrollOffset += singleSetHeight * 3; // Move it to the bottom of the second set
            shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]); // Reshuffle phrases on loop
        }

        updateBloodTextTexture();
    }

    // Update redacted glitch text scrolling
    if (effectControls.redactedGlitch) {
        redactedGlitchScrollOffset -= REDACTED_GLITCH_SCROLL_SPEED;
        const singleSetHeight = REDACTED_GLITCH_LINE_HEIGHT * REDACTED_GLITCH_TOTAL_LINES;
        if (redactedGlitchScrollOffset <= -singleSetHeight) {
            redactedGlitchScrollOffset = 0;
            // Re-initialize redaction patterns when the text loops
            initializeRedactedGlitchPhraseData();
        }
        updateRedactedGlitchTexture();
    }

    composer.render();
}

init();
animate();

// Expose for dae hooks
setTimeout(function () {
    window.animate = typeof animate == "function" ? animate : () => { };
    window.camera = typeof camera != "undefined" ? camera : undefined;
    window.renderer = typeof renderer != "undefined" ? renderer : undefined;
    window.scene = typeof scene != "undefined" ? scene : undefined;
}, 1000)
    
    // Expose for dae hooks
    setTimeout(function() {
      window.animate = typeof animate == "function" ? animate : () => {}; 
      window.camera = typeof camera != "undefined" ? camera : undefined; 
      window.renderer = typeof renderer != "undefined" ? renderer : undefined; 
      window.scene = typeof scene != "undefined" ? scene : undefined; 
    }, 1000)
  </script>

</body></html>