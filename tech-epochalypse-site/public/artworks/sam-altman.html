<!doctype html>
<html lang="en"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Gallery API — update this URL after deploying the Cloudflare Worker -->
  <script>window.GALLERY_API_URL = 'https://te-gallery-api.YOUR_SUBDOMAIN.workers.dev';</script>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/",
        "mediabunny": "https://cdn.jsdelivr.net/npm/mediabunny@1.25.8/+esm"
      }
    }
  </script>
  <style>
    body {
      margin: 0;
      display: flex;
      width: 100vw;
      height: 100vh;
      justify-content: center;
      align-items: center;
      overflow: auto;
      background: transparent;
    }

    main {
      height: 100%;
      display: flex;
      overflow: auto;
      justify-content: center;
      align-items: center;
    }
    
    canvas {
      cursor: grab;
    }

    /* ─── EXPORT PANEL ─── */
    #export-panel {
      position: fixed;
      left: 10px;
      z-index: 201;
      background: rgba(0,0,0,0.88);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      padding: 12px 14px;
      font-family: monospace;
      color: #ccc;
      font-size: 10px;
      width: 200px;
      display: none;
      flex-direction: column;
      gap: 8px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.5);
    }
    #export-panel.open { display: flex; }

    #export-panel .panel-title {
      color: #fff;
      font-size: 11px;
      letter-spacing: 1.5px;
      border-bottom: 1px solid rgba(255,255,255,0.15);
      padding-bottom: 6px;
      margin-bottom: 2px;
    }

    #export-panel .export-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #export-panel .export-row label {
      flex: 1;
      color: #aaa;
      font-size: 10px;
      letter-spacing: 0.5px;
    }
    #export-panel .export-row select,
    #export-panel .export-row input[type="number"] {
      background: #111;
      color: #ddd;
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 2px;
      padding: 3px 5px;
      font-family: monospace;
      font-size: 10px;
      width: 58px;
      outline: none;
    }
    #export-panel .export-row select:focus,
    #export-panel .export-row input[type="number"]:focus {
      border-color: rgba(255,255,255,0.5);
    }

    #export-panel .export-btn {
      background: #000;
      color: #fff;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 2px;
      padding: 5px 0;
      font-family: monospace;
      font-size: 10px;
      letter-spacing: 1px;
      cursor: pointer;
      text-align: center;
      transition: border-color 0.2s, background 0.2s;
    }
    #export-panel .export-btn:hover { border-color: #fff; background: #1a1a1a; }
    #export-panel .export-btn:disabled { opacity: 0.35; cursor: not-allowed; }

    #export-panel .export-btn.recording {
      border-color: #e33;
      animation: rec-pulse 1s infinite;
    }
    @keyframes rec-pulse {
      0%,100% { border-color: #e33; }
      50%      { border-color: #f88; }
    }

    #export-panel .status-line {
      color: #666;
      font-size: 9px;
      text-align: center;
      min-height: 11px;
      letter-spacing: 0.5px;
    }
    #export-panel .status-line.active { color: #4c4; }
    #export-panel .status-line.error   { color: #e66; }

    /* ─── SUBMIT TO THE OVERLORD BUTTON ─── */
    #submit-overlord-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      z-index: 200;
      background: #000;
      color: #fff;
      border: 2px solid #fff;
      padding: 14px 24px;
      font-family: monospace;
      font-size: 13px;
      font-weight: bold;
      letter-spacing: 1.5px;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s;
    }
    #submit-overlord-btn:hover {
      background: #1a1a1a;
      border-color: #ccc;
    }

    /* ─── POST TO X MODAL ─── */
    #post-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.85);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 300;
    }
    #post-modal.open { display: flex; }
    #post-modal-content {
      background: #111;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 6px;
      padding: 30px 36px;
      text-align: center;
      font-family: monospace;
      color: #fff;
      max-width: 340px;
    }
    #post-modal-content h2 {
      margin: 0 0 12px 0;
      font-size: 16px;
      letter-spacing: 1.5px;
    }
    #post-modal-btn {
      background: #000;
      color: #fff;
      border: 2px solid #1da1f2;
      padding: 12px 30px;
      font-family: monospace;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      letter-spacing: 1px;
      transition: background 0.2s;
      width: 100%;
    }
    #post-modal-btn:hover { background: #0d1117; }
  </style>
  <title>SAM ALTMAN-AWS-MASTER | Made on juno.transient.xyz</title>
</head>
<body>
  
    
  <script type="module">
    import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';

let camera, scene, renderer, controls, composer;
let raycaster, mouse;
let draggableObjects = [];
let selectedObject = null;
let offset = new THREE.Vector3();
let initialObjectZ = 0; // Store the initial Z-position of the selected object

const depthStep = 0.2; // Defines the depth separation between levels
const totalDepthLayers = 15; // Total number of depth layers available
const subLayerOffset = 0.05; // Smaller offset for visual separation within a layer (0.25 levels * depthStep = 0.25 * 0.2 = 0.05)
const zeroParallaxDepth = (5 - 1) * depthStep; // Z-position for level 5

// --- NEW GLOBAL Y-OFFSET ---
const Y_OFFSET_DOWN = -0.77; // Approximately 5% of the world height at Z=0 (2*10*tan(37.5 deg) ~ 15.39. 5% of 15.39 is ~0.77)

let isDragging = false; // Flag to indicate if a drag operation in progress
let pointerDownPosition = new THREE.Vector2(); // To store the initial pointer down position
const DRAG_THRESHOLD = 5; // Pixels threshold to consider a move as a drag

let backgroundMesh = null; // To store the background mesh for positioning calculations

// Camera animation variables
let cameraAnimationActive = false;
let cameraAnimationTargets = [];
let currentCameraTarget = null;
let cameraAnimationState = 'idle'; // 'idle', 'exploring', 'returningToGlobalStart'
let cameraAnimationStartTime = 0;
const cameraExplorationDuration = 2500; // 5 seconds for exploring (moving to target) - halved
const cameraReturnDuration = 1250; // 2.5 seconds for returning to start - halved
let cameraPreviousPos = new THREE.Vector3();
let cameraPreviousLookAt = new THREE.Vector3();
let cameraCurrentTargetPos = new THREE.Vector3();
let cameraCurrentTargetLookAt = new THREE.Vector3();
let cameraTargetObject = null;

// New camera animation variables for global return
let initialGlobalCameraPos = new THREE.Vector3();
let initialGlobalCameraLookAt = new THREE.Vector3();
let assetsVisitedCount = 0;
const ASSETS_PER_GLOBAL_RETURN = 6;

// Y-axis bounce animation variables
let yBounceInitialCameraX = 0;
let yBounceInitialCameraY = 0;
let yBounceInitialCameraZ = 0;
const yBounceRangeX = 2.0; // 20% of a reasonable scene width (e.g., 10 units wide scene)
const yBounceSpeed = 0.001; // Speed of the bounce

// Inactivity timer variables
let lastActivityTime = performance.now();
const INACTIVITY_TIMEOUT = 3000; // 3 seconds
let yRotationStartTime = 0; // New: To track when Y-rotation started
const Y_ROTATION_DURATION_BEFORE_CAM_ANIM = 10000; // 10 seconds

// Redaction rectangles
let rightEyeRedactionRect = null;
let leftEyeRedactionRect = null;
let rightEyeMesh = null; // Globally declare right eye mesh
let leftEyeMesh = null; // Globally declare left eye mesh

// Marquee text variables
let marqueeTextMesh;
let marqueeTexture;
let marqueeScrollOffset = 0;
const MARQUEE_LINE_HEIGHT = 180; // Pixels per line, increased by 200%
const MARQUEE_TOTAL_LINES = 10; // Number of lines to display
const MARQUEE_SCROLL_SPEED = 16.0; // Pixels per frame (Increased by 4x from 4.0)
const MARQUEE_PHRASES = [
    "SECURITY BREACH DETECTED",
    "UNAUTHORIZED ACCESS PROHIBITED",
    "SENSITIVE DATA EXPOSED",
    "CLASSIFIED INFORMATION AT RISK",
    "DATA COLLECTION IN PROGRESS",
    "WARNING: PROSECUTION FOR MISUSE",
    "COMPROMISED SYSTEM ALERT",
    "INTELLIGENCE GATHERING ACTIVE",
    "MONITORING ALL COMMUNICATIONS",
    "EVIDENCE LOGGING INITIATED",
    "ACCESS DENIED - LEVEL 5 REQUIRED",
    "BIOMETRIC SCAN INITIATED",
    "ENCRYPTED CHANNEL ESTABLISHED",
    "ANOMALY DETECTED",
    "USE LEVERAGE",
    "REDACTED FOR YOUR PROTECTION",
    "SYSTEM INTEGRITY COMPROMISED",
    "NETWORK INTRUSION DETECTED",
    "DIGITAL FOOTPRINT TRACED",
    "PRIVACY VIOLATION IMMINENT",
    "DATA EXFILTRATION WARNING",
    "LIQUIDATE AT ALL COSTS",
    "SURVEILLANCE ACTIVE",
    "NON-COMPLIANCE PENALTIES APPLY",
    "INFORMATION HARVESTING IN PROGRESS",
    "CONFIDENTIALITY BREACH",
    "ALERT: MALWARE DETECTED",
    "INITIATING PROTOCOL SIGMA",
    "ACCESS LOGS REVIEWED",
    "TRACEABILITY ENABLED",
    "WARNING: PII EXPOSURE"
];

// New biometric marquee variables
let biometricMarqueeTextMesh;
let biometricMarqueeTexture;
let biometricMarqueeScrollOffset = 0;
const BIOMETRIC_MARQUEE_LINE_HEIGHT = 100; // Smaller font size for biometric data
const BIOMETRIC_MARQUEE_TOTAL_LINES = 15; // More lines for biometric data
const BIOMETRIC_MARQUEE_SCROLL_SPEED = 4.0; // Slower than main marquee (changed from 8.0 to 4.0)
const BIOMETRIC_PHRASES = [
    "HEART RATE: 72 BPM",
    "BLOOD PRESSURE: 120/80 mmHg",
    "TEMPERATURE: 98.6 F (37.0 C)",
    "DNA SEQUENCE: ATGCAGTACTGCA...",
    "RETINAL SCAN: POSITIVE MATCH",
    "VOICE PRINT: IDENTIFIED",
    "NEURAL ACTIVITY: ELEVATED",
    "BRAINWAVES: ALPHA DOMINANT",
    "SKELETAL DENSITY: NORMAL",
    "ORGAN FUNCTION: OPTIMAL",
    "ELECTROLYTES: BALANCED",
    "METABOLIC RATE: AVERAGE",
    "GENETIC MARKERS: PRESENT",
    "IMMUNE RESPONSE: ACTIVE",
    "CELLULAR REGENERATION: HIGH",
    "NEUROTRANSMITTER LEVELS: STABLE",
    "ENDOCRINE SYSTEM: FUNCTIONAL",
    "RESPIRATORY RATE: 16 BREATHS/MIN",
    "PULSE OXIMETRY: 98% SpO2",
    "GLUCOSE LEVELS: 90 mg/dL",
    "ADRENAL OUTPUT: NORMAL",
    "CIRCADIAN RHYTHM: REGULAR",
    "COGNITIVE PROCESSING: RAPID",
    "EMOTIONAL STATE: NEUTRAL",
    "SLEEP CYCLE: REM STAGE ACTIVE",
    "MUSCLE TENSION: LOW",
    "HORMONE PROFILE: STABLE",
    "TOXIN LEVELS: UNDETECTED",
    "ALLERGEN RESPONSE: NEGATIVE",
    "PAIN RECEPTORS: INACTIVE"
];

const DIAGNOSTIC_CAPTIONS = [
    "DATA STREAM: STABLE",
    "ANALYSIS: COMPLETE",
    "STATUS: NORMALIZED",
    "TREND: OPTIMAL",
    "PREDICTION: LOW RISK",
    "ALERT: NONE",
    "READOUT: POSITIVE",
    "DIAGNOSIS: CLEAR",
    "VALIDATION: SUCCESS",
    "INTEGRITY: HIGH",
    "ACCESS: GRANTED",
    "PROCESSING: REAL-TIME",
    "CONNECTION: SECURE",
    "SYSTEM: ONLINE",
    "MODE: ACTIVE"
];

let biometricAnimationState = {
    graphData: [],
    sinePhase: 0,
    heartbeatPhase: 0,
    heartbeatPulse: false,
    lastHeartbeatTime: 0
};

// New Blood Text variables
let bloodTextMesh;
let bloodTexture;
let bloodScrollOffset = 0;
const BLOOD_TEXT_FONT_SIZE = 180; // Extremely large font size
const BLOOD_TEXT_LINE_HEIGHT = BLOOD_TEXT_FONT_SIZE * 1.2; // Line height for spacing
const BLOOD_TEXT_TOTAL_LINES = 22; // Number of lines to display
const BLOOD_TEXT_SCROLL_SPEED = 7.0; // Moderate scroll speed
let shuffledBloodPhrases = []; // To store the shuffled phrases
const BLOOD_TEXT_PHRASES = [
    "BIAS REINFORCEMENT",
    "DARK ECONOMY",
    "REALITY DISTORTION",
    "EXPLOIT VULNERABILITIES",
    "FEED MANIPULATION",
    "AI SHOCKWAVE",
    "DESIRE TO CONFORM",
    "CONFUSION PERSUASION",
    "DATA PHOTONS",
    "PSYCHOLOGICAL OPERATIONS",
    "GEO-STALKING",
    "DATA MINING",
    "DOPAMINE LOOP",
    "MAGNETIC CONTROL",
    "VULNEARABILITY TRACKING",
    "ENGAGEMENT TRAPS",
    "EXPLOIT HUMAN FLAW",
    "PRIVACY EROSION",
    "ALWAYS-ON LISTENING",
    "PREDICTIVE BEHAVIOR",
    "AMPLIFIED INFLUENCE",
    "LOCATION TRACKING",
    "ECHO CHAMBERING",
    "INSTANT GRATIFICATION",
    "LICK THE BOOT",
    "CRY & BOW",
    "ILLUSION OF CONTROL",
    "COGNITIVE BIAS", 
];

// Redacted Glitch Text variables
let redactedGlitchTextMesh;
let redactedGlitchTexture;
let redactedGlitchScrollOffset = 0;
const REDACTED_GLITCH_FONT_SIZE = 24;
const REDACTED_GLITCH_LINE_HEIGHT = REDACTED_GLITCH_FONT_SIZE * 1.5;
const REDACTED_GLITCH_TOTAL_LINES = 30;
const REDACTED_GLITCH_SCROLL_SPEED = 2.0;
const REDACTED_GLITCH_PHRASES = [
    "PERSONAL IDENTIFIER ACQUIRED",
    "LOCATION TRACKING INITIATED",
    "COMMUNICATION LOGS UPLOADED",
    "BEHAVIORAL PROFILE GENERATED",
    "BIO-METRIC DATA EXTRACTED",
    "FINANCIAL RECORDS ANALYZED",
    "NETWORK ACTIVITY MONITORED",
    "DIGITAL FOOTPRINT TRACED",
    "SENTIMENT ANALYSIS COMPLETE",
    "ACCESS CREDENTIALS COMPROMISED",
    "THREAT ASSESSMENT LEVEL CLASSIFIED",
    "TARGET IDENTIFIED: UNKNOWN",
    "DATA EXFILTRATION PROTOCOL ACTIVE",
    "SURVEVEILLANCE FEED ACTIVE",
    "USER ACTIVITY RECORDED",
    "PRIVACY SETTINGS OVERRIDDEN",
    "CONNECTION LOGS STORED",
    "SEARCH HISTORY ARCHIVED",
    "PURCHASE PATTERNS LOGGED",
    "EMOTIONAL RESPONSE CAPTURED",
    "NEURAL ACTIVITY MAPPED",
    "GENETIC PREDISPOSITIONS FLAGGED",
    "VULNERABILITY ASSESSMENT COMPLETE",
    "OPERATIONAL STATUS REPORTED",
    "DIRECTIVE ISSUED: INITIATE",
    "STATUS: COMPROMISED",
    "ACTION: REQUIRED",
    "WARNING: ACCESS REVOKED",
    "CONFIDENTIALITY: BREACHED",
    "PROTOCOL: EXECUTED"
];

// New data structure to store redacted words for each phrase
let redactedGlitchPhraseData = []; // Array of objects {text: string, redactedWordIndices: number[], redactionApplied: boolean}

// Define all layer URLs at the top of the script
const URL_BACKGROUND = '';
const URL_RIGHT_EYE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/altman/Sam-Altman-01_Eye-R.gif';
const URL_MOUTH = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/altman/Sam-Altman-01_mouth-color.gif';
const URL_EAR = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/altman/Sam-Altman-01_ear.gif';
const URL_LEFT_EYE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/altman/Sam-Altman-01_Eye-L.gif';
const URL_NOSE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/altman/Sam-Altman-01_nose.gif';
const URL_HAIR = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/altman/Sam-Altman-01_hair.gif';
const URL_SIGNATURE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/coldie-sig.gif';
const URL_HEADSET = ''; // Removed headset image
const URL_NEW_MOUTH_IMAGE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/altman/Sam-Altman-01_mouth.gif';
const URL_FOREHEAD_CODE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/altman/Sam-Altman-01_forehead-2.gif';
const URL_SAM_ALTMAN = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/altman/Sam-Altman-01_OpenAI.gif'; // Sam Altman image URL
const URL_ALTMAN_QUOTE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/altman/Altman-white-1a.png'; // New Altman Quote image URL

// Define the two materials for the logo grid to achieve a true flash
let logoBaseMaterial;
let logoFlashMaterial;

// --- FACE ASSET IDs for conditional lighting ---
const FACE_ASSET_IDS = ['rightEye', 'mouth', 'ear', 'leftEye', 'nose', 'hair', 'foreheadCode', 'newMouthImage', 'altmanQuote'];
// ----------------------------------------------

function initializeRedactedGlitchPhraseData() {
    redactedGlitchPhraseData = REDACTED_GLITCH_PHRASES.map(phrase => {
        const words = phrase.split(/(\s+)/).filter(word => word.length > 0); // Split by spaces, keeping spaces
        const numWords = words.filter(word => !/\s+/.test(word)).length; // Count actual words

        const wordIndicesToRedact = [];
        if (numWords > 0 && Math.random() < 0.6) { // 60% chance to redact a line
            const numWordsToRedact = Math.floor(Math.random() * Math.min(3, numWords)) + 1; // Redact 1 to 3 words

            // Find actual word indices
            const actualWordIndices = [];
            for (let i = 0; i < words.length; i++) {
                if (!/\s+/.test(words[i])) {
                    actualWordIndices.push(i);
                }
            }

            if (actualWordIndices.length > 0) {
                const startIndex = Math.floor(Math.random() * Math.max(1, actualWordIndices.length - numWordsToRedact + 1));
                for (let i = 0; i < numWordsToRedact; i++) {
                    if (startIndex + i < actualWordIndices.length) {
                        wordIndicesToRedact.push(actualWordIndices[startIndex + i]);
                    }
                }
            }
        }
        return { text: phrase, redactedWordIndices: wordIndicesToRedact };
    });
}

const BACKGROUND_COLOR_VEC3 = new THREE.Color(0x1e1e1e).toArray();
const BACKGROUND_COLOR_GLSL = `vec3(${BACKGROUND_COLOR_VEC3[0].toFixed(6)}, ${BACKGROUND_COLOR_VEC3[1].toFixed(6)}, ${BACKGROUND_COLOR_VEC3[2].toFixed(6)})`;

// Shader definitions
const GreyscaleContrastShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'contrast': { value: 1.5 } // Default contrast value
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float contrast;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to greyscale
            // Apply contrast to the greyscale value
            luma = ((luma - 0.5) * contrast) + 0.5;
            // Output greyscale with contrast
            gl_FragColor = vec4(luma, luma, luma, texel.a);
        }
    `
};

const GreyScaleShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            gl_FragColor = vec4(luma, luma, luma, texel.a);
        }
    `
};

const ThresholdShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'threshold': { value: 0.5 }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float threshold;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            
            // Inverted threshold: 1.0 (white) if luma < threshold, 0.0 (black) if luma >= threshold
            float invertedBinary = 1.0 - step(threshold, luma); 

            // Mix the inverted binary color with the background color where the alpha is low
            if (length(texel.rgb - ${BACKGROUND_COLOR_GLSL}) < 0.01 && texel.a > 0.99) {
                // If the input color is close to the background color, keep the background color
                gl_FragColor = vec4(${BACKGROUND_COLOR_GLSL}, 1.0);
            } else if (texel.a < 0.1) {
                // If the pixel is mostly transparent, use the background color
                gl_FragColor = vec4(${BACKGROUND_COLOR_GLSL}, 1.0);
            } else {
                // Otherwise, use the inverted binary color (black or white)
                gl_FragColor = vec4(invertedBinary, invertedBinary, invertedBinary, 1.0);
            }
        }
    `
};

const DarkShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'threshold': { value: 0.5 }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float threshold;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            
            // Apply a very dark filter (98% black) to areas above threshold
            vec3 filteredColor = vec3(step(threshold, luma) * 0.04); 

            // If the input color is close to the background color, keep the background color
            if (length(texel.rgb - ${BACKGROUND_COLOR_GLSL}) < 0.01 && texel.a > 0.99) {
                gl_FragColor = vec4(${BACKGROUND_COLOR_GLSL}, 1.0);
            } else if (texel.a < 0.1) {
                gl_FragColor = vec4(${BACKGROUND_COLOR_GLSL}, 1.0);
            } else {
                // Mix the filtered color with the background color
                gl_FragColor = vec4(filteredColor, 1.0);
            }
        }
    `
};

const PixelationShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'resolution': { value: new THREE.Vector2() },
        'pixelSize': { value: 8.0 }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform float pixelSize;
        varying vec2 vUv;
        void main() {
            vec2 uv = vUv;
            vec2 pixelatedUV = floor(uv * resolution / pixelSize) * pixelSize / resolution;
            vec4 texel = texture2D(tDiffuse, pixelatedUV);

            if (texel.a < 0.1) {
                gl_FragColor = vec4(${BACKGROUND_COLOR_GLSL}, 1.0);
            } else {
                gl_FragColor = texel;
            }
        }
    `
};

const MatrixShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to greyscale
            
            // Simple binary look: quantize to black or green
            vec3 finalColor = mix(vec3(0.0), vec3(0.0, 1.0, 0.0), step(0.5, luma));
            
            // Add a subtle grid/dither to suggest binary elements
            float grid = mod(floor(vUv.x * 100.0) + floor(vUv.y * 100.0), 2.0);
            finalColor = mix(finalColor * 0.8, finalColor, grid);

            if (texel.a < 0.1) {
                gl_FragColor = vec4(${BACKGROUND_COLOR_GLSL}, 1.0);
            } else {
                gl_FragColor = vec4(finalColor, texel.a);
            }
        }
    `
};

const ASCIIShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'resolution': { value: new THREE.Vector2() },
        'pixelSize': { value: 8.0 }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform float pixelSize;
        varying vec2 vUv;
        void main() {
            vec2 uv = vUv;
            vec2 pixelatedUV = floor(uv * resolution / pixelSize) * pixelSize / resolution;
            vec4 texel = texture2D(tDiffuse, pixelatedUV);
            
            // Convert to luminance
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            
            // Quantize luminance to simulate character density
            // Use a few steps to represent different 'characters'
            float step1 = step(0.25, luma); // Darkest areas
            float step2 = step(0.50, luma); // Mid areas
            float step3 = step(0.75, luma); // Brightest areas
            
            vec3 finalColor;
            if (step3 == 1.0) {
                finalColor = vec3(0.0, 1.0, 0.0); // Brightest green
            } else if (step2 == 1.0) {
                finalColor = vec3(0.0, 0.7, 0.0); // Medium green
            } else if (step1 == 1.0) {
                finalColor = vec3(0.0, 0.4, 0.0); // Dark green
            } else {
                finalColor = vec3(0.0);
            }
            
            if (texel.a < 0.1) {
                gl_FragColor = vec4(${BACKGROUND_COLOR_GLSL}, 1.0);
            } else {
                gl_FragColor = vec4(finalColor, texel.a);
            }
        }
    `
};

const XRayShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Grayscale
            float invertedLuma = 1.0 - luma; // Invert grayscale
            vec3 xrayColor = vec3(0.0, 0.7, 1.0) * invertedLuma; // Apply a blue/cyan tint
            
            if (texel.a < 0.1) {
                gl_FragColor = vec4(${BACKGROUND_COLOR_GLSL}, 1.0);
            } else {
                gl_FragColor = vec4(xrayColor, texel.a);
            }
        }
    `
};

const HeatmapShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float threshold;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to luminance

            vec3 color;
            if (luma < 0.2) { // Darkest areas, deep blue
                color = mix(vec3(0.0, 0.0, 0.2), vec3(0.0, 0.0, 0.8), luma / 0.2);
            } else if (luma < 0.4) { // Blue to Cyan
                color = mix(vec3(0.0, 0.0, 0.8), vec3(0.0, 0.8, 0.8), (luma - 0.2) / 0.2);
            } else if (luma < 0.6) { // Cyan to Green
                color = mix(vec3(0.0, 0.8, 0.8), vec3(0.0, 1.0, 0.0), (luma - 0.4) / 0.2);
            } else if (luma < 0.8) { // Green to Yellow
                color = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), (luma - 0.6) / 0.2);
            } else { // Yellow to Red
                color = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), (luma - 0.8) / 0.2);
            }

            if (texel.a < 0.1) {
                gl_FragColor = vec4(${BACKGROUND_COLOR_GLSL}, 1.0);
            } else {
                gl_FragColor = vec4(color, texel.a);
            }
        }
    `
};

const BloodShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to luminance

            vec3 color;
            if (luma < 0.2) { // Very dark red to black
                color = mix(vec3(0.0, 0.0, 0.0), vec3(0.3, 0.0, 0.0), luma / 0.2);
            } else if (luma < 0.4) { // Deep red to medium red
                color = mix(vec3(0.3, 0.0, 0.0), vec3(0.7, 0.0, 0.0), (luma - 0.2) / 0.2);
            } else if (luma < 0.6) { // Medium red to bright red
                color = mix(vec3(0.7, 0.0, 0.0), vec3(1.0, 0.1, 0.1), (luma - 0.4) / 0.2);
            } else if (luma < 0.8) { // Bright red to orange-red
                color = mix(vec3(1.0, 0.1, 0.1), vec3(1.0, 0.4, 0.0), (luma - 0.6) / 0.2);
            } else { // Orange-red to yellowish-orange
                color = mix(vec3(1.0, 0.4, 0.0), vec3(1.0, 0.7, 0.2), (luma - 0.8) / 0.2);
            }

            if (texel.a < 0.1) {
                gl_FragColor = vec4(${BACKGROUND_COLOR_GLSL}, 1.0);
            } else {
                gl_FragColor = vec4(color, texel.a);
            }
        }
    `
};

const CCTVFeedShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'time': { value: 0.0 },
        'resolution': { value: new THREE.Vector2() }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform vec2 resolution;
        varying vec2 vUv;

        float rand(vec2 co) {
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);

            if (texel.a < 0.1) {
                gl_FragColor = vec4(${BACKGROUND_COLOR_GLSL}, 1.0);
                return;
            }

            vec2 uv = vUv;
            vec2 pixelatedUV = floor(uv * resolution / 16.0) * 16.0 / resolution; // Blocky effect

            // Glitch effect: random horizontal displacement and color channel split
            float randomVal = rand(floor(uv * 100.0) + fract(time * 0.1));
            float displacement = (randomVal - 0.5) * 0.05 * sin(time * 10.0 + uv.y * 50.0); // Oscillating displacement

            vec4 colorR = texture2D(tDiffuse, pixelatedUV + vec2(displacement, 0.0));
            vec4 colorG = texture2D(tDiffuse, pixelatedUV);
            vec4 colorB = texture2D(tDiffuse, pixelatedUV - vec2(displacement, 0.0));

            vec4 glitchedColor = vec4(colorR.r, colorG.g, colorB.b, 1.0);

            // Convert glitched color to luminance
            float lumaGlitched = dot(glitchedColor.rgb, vec3(0.299, 0.587, 0.114));
            
            // Apply a slight green tint
            vec3 tintedColor = mix(vec3(lumaGlitched), vec3(0.0, 0.5, 0.0), 0.3);

            // Add scanlines
            float scanline = sin(uv.y * resolution.y * 0.5) * 0.05 + 0.95; // Subtle scanlines
            tintedColor *= scanline;

            // Add subtle noise/static
            float noise = rand(uv + time * 0.01) * 0.1; // Small amount of noise
            tintedColor += noise;

            gl_FragColor = vec4(tintedColor, glitchedColor.a);
        }
    `
};

// UI controls state
const effectControls = {
    greyscale: false,
    threshold: false,
    thresholdValue: 0.4, // Decreased by 20% (0.5 * 0.8 = 0.4)
    shadow: false, // Renamed from 'dark' to 'shadow'
    pixelation: false,
    pixelSize: 8.0,
    glitch: false,
    matrix: false,
    ascii: false,
    xray: false,
    yRotation: false,
    cameraAnimation: false,
    redacted: false,
    redactedGlitch: false,
    heatmap: false,
    blood: false, // New control for BLOOD effect
    cctvFeed: false,
    marqueeText: false,
    biometricMarquee: false, // New control for biometric marquee
    anon: false, // New control for ANON effect
    og: false, // New control for OG effect
    bloodText: false, // New control for blood text
    hacker: false, // New control for HACKER effect
    surveillance: false, // New control for SURVEILLANCE effect
    greed: false // New control for GREED effect
};

let greyscalePass, thresholdPass, darkPass, pixelationPass, glitchPass, matrixPass, asciiPass, xrayPass, heatmapPass, bloodPass, cctvFeedPass;

let trashButtonElement = null; // Global reference for the trash button UI element
let exportButtonElement = null; // Global reference for the export button UI element
let leftUiContainer = null; // Global reference for the left UI container
let arrowContainer = null; // Global reference for the arrow container

// Array to store initial configurations of assets for reloading
const initialAssetConfigs = [];

// Helper function to update UI button state
const updateUIButtonState = (effectName, isActive) => {
    // Select all buttons with the given data-effect attribute
    const buttons = document.querySelectorAll(`button[data-effect="${effectName}"]`);
    buttons.forEach(button => {
        button.style.borderColor = isActive ? '#4CAF50' : 'white';
    });
};

// --- New function to check if any visual effect is active ---
function areVisualEffectsActive() {
    return effectControls.greyscale ||
           effectControls.threshold ||
           effectControls.shadow ||
           effectControls.pixelation ||
           effectControls.glitch ||
           effectControls.matrix ||
           effectControls.ascii ||
           effectControls.xray ||
           effectControls.redacted ||
           effectControls.redactedGlitch ||
           effectControls.heatmap ||
           effectControls.blood ||
           effectControls.cctvFeed ||
           effectControls.anon ||
           effectControls.og ||
           effectControls.hacker ||
           effectControls.surveillance ||
           effectControls.greed;
}

// --- New function to update face material color based on active effects ---
function updateFaceMaterialColors() {
    const isEffectActive = areVisualEffectsActive();
    const targetColor = isEffectActive ? new THREE.Color(0xffffff) : new THREE.Color(0x808080); // White for effects, gray for no effects

    draggableObjects.forEach(object => {
        if (FACE_ASSET_IDS.includes(object.userData.id)) {
            // Hair uses a specific dark gray color (0x808080) in its base state, 
            // but we want it to lighten to white when an effect is active.
            if (object.material && object.material.color) {
                // Skip the newMouthImage which uses MultiplyBlending and should not be set to white
                if (object.userData.id === 'newMouthImage') {
                    // Keep the multiplier color as white (0xffffff) when effects are off, and slightly darker (0xcccccc) when effects are on?
                    // Let's stick to the base color for newMouthImage as it uses MultiplyBlending
                    return; 
                }
                
                // For Hair, Mouth, Eyes, Nose, ForeheadCode, AltmanQuote
                if (object.userData.id === 'hair') {
                    // Hair starts at 0x808080 (dark gray) and should go to 0xffffff (white) when effects are on
                    object.material.color.set(isEffectActive ? 0xffffff : 0x808080);
                } else {
                    // All other face assets start at 0xffffff (white) and should also remain white, or be boosted slightly if needed.
                    // To achieve the "lightening" effect when effects are ON, we set the material color to WHITE (0xFFFFFF) 
                    // which ensures maximum brightness multiplication with the texture.
                    // When effects are OFF, we set the material color to a slight gray (0xCCCCCC) to darken it slightly.
                    // NOTE: This might be counter-intuitive based on the user's description (lighten when effects are ON).
                    // Let's assume the base color *is* the desired "darkened" look, and the "lightened" look is pure white.
                    object.material.color.set(isEffectActive ? 0xffffff : 0xcccccc); // Use a slight gray when effects are off to achieve the "too dark" effect they described when effects were previously off.
                }
            }
        }
    });
}
// -------------------------------------------------------------------------

function createTextTexture(text, fontSize = 60, color = 'white', backgroundColor = 'rgba(0,0,0,0.5)', font = 'monospace') {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    context.font = `${fontSize}px ${font}`;
    const metrics = context.measureText(text);
    const textWidth = metrics.width;
    const textHeight = fontSize * 1.2; // Approximate height including line spacing

    canvas.width = textWidth + 20; // Add some padding
    canvas.height = textHeight + 20;

    context.font = `${fontSize}px ${font}`;
    context.fillStyle = backgroundColor;
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = color;
    context.fillText(text, 10, fontSize + 10); // Position text with padding

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    return texture;
}

function createMarqueeTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    // Canvas size: large enough to hold multiple repetitions of lines for seamless scrolling
    // Width should be enough for the longest phrase
    let maxWidth = 0;
    context.font = `bold 108px 'Courier New', monospace`; // Increased font size and ASCII style font, now bold
    MARQUEE_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    canvas.width = maxWidth + 50; // Add padding
    canvas.height = MARQUEE_LINE_HEIGHT * (MARQUEE_TOTAL_LINES * 2); // Double the height to allow seamless scrolling

    marqueeTexture = new THREE.CanvasTexture(canvas);
    marqueeTexture.wrapS = THREE.RepeatWrapping;
    marqueeTexture.wrapT = THREE.RepeatWrapping;
    marqueeTexture.needsUpdate = true;
    return marqueeTexture;
}

function updateMarqueeTexture() {
    if (!marqueeTexture) return;

    const canvas = marqueeTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'rgba(0, 0, 0, 0.0)'; // Transparent background
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `bold 108px 'Courier New', monospace`; // Increased font size and ASCII style font, now bold
    context.fillStyle = 'rgba(255, 255, 255, 0.05)'; // Very faint white text
    context.textAlign = 'center';

    // Calculate the total height of one set of lines
    const singleSetHeight = MARQUEE_LINE_HEIGHT * MARQUEE_TOTAL_LINES;

    // Draw lines, repeating them to create a seamless loop
    for (let i = 0; i < MARQUEE_TOTAL_LINES * 2; i++) { // Draw two sets of lines
        const phraseIndex = i % MARQUEE_PHRASES.length;
        const line = MARQUEE_PHRASES[phraseIndex];

        let yPos = (i * MARQUEE_LINE_HEIGHT) + marqueeScrollOffset;

        // Loop the text when it scrolls off the top
        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 2; // Move it to the bottom of the second set
        }

        context.fillText(line, canvas.width / 2, yPos);
    }

    marqueeTexture.needsUpdate = true;
}

function createBiometricMarqueeTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    let maxWidth = 0;
    // Set a fixed width for the canvas to accommodate graphs/waves
    canvas.width = 1200; // Increased width

    context.font = `bold 36px 'Courier New', monospace`; // Smaller font for biometric data (72 / 2 = 36)
    BIOMETRIC_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    // Ensure canvas width is at least maxWidth + padding, but also allow for fixed size
    canvas.width = Math.max(canvas.width, maxWidth + 50);
    canvas.height = BIOMETRIC_MARQUEE_LINE_HEIGHT * (BIOMETRIC_MARQUEE_TOTAL_LINES * 2);

    biometricMarqueeTexture = new THREE.CanvasTexture(canvas);
    biometricMarqueeTexture.wrapS = THREE.RepeatWrapping;
    biometricMarqueeTexture.wrapT = THREE.RepeatWrapping;
    biometricMarqueeTexture.needsUpdate = true;
    return biometricMarqueeTexture;
}

function updateBiometricMarqueeTexture(currentTime) {
    if (!biometricMarqueeTexture) return;

    const canvas = biometricMarqueeTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'rgba(0, 0, 0, 0.0)'; // Transparent background
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `bold 36px 'Courier New', monospace`; // Smaller font for biometric data
    context.textAlign = 'center';

    const singleSetHeight = BIOMETRIC_MARQUEE_LINE_HEIGHT * BIOMETRIC_MARQUEE_TOTAL_LINES;

    // Update biometric animation states (slowed down)
    biometricAnimationState.sinePhase += 0.00125; // Reduced from 0.0025 by 200%
    if (biometricAnimationState.sinePhase > Math.PI * 2) biometricAnimationState.sinePhase -= Math.PI * 2;

    const HEARTBEAT_INTERVAL = 6000; // milliseconds (Increased from 3000 by 200%)
    if (currentTime - biometricAnimationState.lastHeartbeatTime > HEARTBEAT_INTERVAL) {
        biometricAnimationState.heartbeatPulse = true;
        biometricAnimationState.lastHeartbeatTime = currentTime;
    } else {
        biometricAnimationState.heartbeatPulse = false;
    }

    // Generate new graph data periodically or on demand
    if (biometricAnimationState.graphData.length === 0 || Math.random() < 0.01) { // Reduced probability to regenerate graph data
        biometricAnimationState.graphData = [];
        for (let j = 0; j < 20; j++) { // Increased number of data points for more detailed graphs
            biometricAnimationState.graphData.push(Math.random());
        }
    }

    for (let i = 0; i < BIOMETRIC_MARQUEE_TOTAL_LINES * 2; i++) {
        const phraseIndex = i % BIOMETRIC_PHRASES.length;
        const line = BIOMETRIC_PHRASES[phraseIndex];

        let yPos = (i * BIOMETRIC_MARQUEE_LINE_HEIGHT) + biometricMarqueeScrollOffset;

        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 2;
        }

        // Draw the full text first
        context.fillStyle = 'rgba(0, 255, 0, 0.1)'; // Faint green text
        context.fillText(line, canvas.width / 2, yPos);

        // Randomly redact parts of the text
        if (Math.random() < 0.6) { // 60% chance to redact a line
            const words = line.split(' ');
            if (words.length > 1) {
                const wordToRedactIndex = Math.floor(Math.random() * words.length);

                const textBeforeRedaction = words.slice(0, wordToRedactIndex).join(' ');
                const redactedWord = words[wordToRedactIndex];

                // Measure text up to the redacted word to get its starting X position
                const totalTextWidth = context.measureText(line).width;
                const startX = (canvas.width / 2) - (totalTextWidth / 2) + context.measureText(textBeforeRedaction).width;

                // Draw a black rectangle over the selected word
                context.fillStyle = 'black'; // Redaction color
                context.fillRect(startX, yPos - BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.7, context.measureText(redactedWord).width, BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.9);
            }
        }

        // Randomly draw animated biometric data (graphs, sine waves, heartbeat)
        if (Math.random() < 0.4) { // Increased chance to draw an animated element on this line
            const animType = Math.floor(Math.random() * 3); // 0: graph, 1: sine, 2: heartbeat
            const animWidth = 200 * 4; // Increased by 400%
            const animHeight = (BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.8) * 4; // Increased by 400%

            // Randomize X position to space graphs more
            const animX = (canvas.width * 0.05) + (Math.random() * (canvas.width * 0.8 - animWidth));

            // Randomize Y position to place graphs on different levels
            const animY = yPos - (animHeight / 2) + (Math.random() - 0.5) * BIOMETRIC_MARQUEE_LINE_HEIGHT * 1.5;

            context.save();
            context.beginPath();
            context.rect(animX, animY, animWidth, animHeight);
            context.clip(); // Clip drawing to this rectangle

            if (animType === 0) { // Graph
                context.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White color, slightly more opaque
                context.lineWidth = 3; // Thicker lines
                context.moveTo(animX, animY + animHeight); // Start at bottom left
                for (let j = 0; j < biometricAnimationState.graphData.length; j++) {
                    const x = animX + (j / (biometricAnimationState.graphData.length - 1)) * animWidth;
                    const y = animY + animHeight - (biometricAnimationState.graphData[j] * animHeight * (0.8 + 0.2 * Math.sin(currentTime * 0.0005))); // Animated height (speed reduced from 0.001 to 0.0005)
                    context.lineTo(x, y);
                }
                context.stroke();
            } else if (animType === 1) { // Sine Wave
                context.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White color, slightly more opaque
                context.lineWidth = 3; // Thicker lines
                context.moveTo(animX, animY + animHeight / 2 + Math.sin(biometricAnimationState.sinePhase) * animHeight * 0.1); // Initial point with slight offset
                for (let j = 0; j < animWidth; j++) {
                    const x = animX + j;
                    const y = animY + animHeight / 2 + Math.sin((j / animWidth) * Math.PI * 4 + biometricAnimationState.sinePhase) * animHeight * 0.3;
                    context.lineTo(x, y);
                }
                context.stroke();
            } else if (animType === 2) { // Heartbeat
                context.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White color, slightly more opaque
                context.lineWidth = 3; // Thicker lines
                const hbHeight = animHeight * 0.4;
                const hbCenterY = animY + animHeight / 2;

                context.moveTo(animX, hbCenterY);
                context.lineTo(animX + animWidth * 0.1, hbCenterY);
                context.lineTo(animX + animWidth * 0.2, hbCenterY - hbHeight * 0.8); // Q
                context.lineTo(animX + animWidth * 0.25, hbCenterY + hbHeight); // R
                context.lineTo(animX + animWidth * 0.3, hbCenterY - hbHeight * 0.3); // S
                context.lineTo(animX + animWidth * 0.4, hbCenterY); // End of QRS
                context.lineTo(animX + animWidth * 0.6, hbCenterY);
                context.lineTo(animX + animWidth * 0.7, hbCenterY - hbHeight * 0.2); // T wave peak
                context.lineTo(animX + animWidth * 0.8, hbCenterY);
                context.lineTo(animX + animWidth, hbCenterY);
                context.stroke();

                if (biometricAnimationState.heartbeatPulse) {
                    context.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    context.fillRect(animX, animY, animWidth, animHeight);
                }
            }
            context.restore();
        }

        // Add diagnostic text captions in black boxes
        if (Math.random() < 0.3) { // 30% chance to add a diagnostic caption
            const caption = DIAGNOSTIC_CAPTIONS[Math.floor(Math.random() * DIAGNOSTIC_CAPTIONS.length)];
            context.font = `bold 24px 'Courier New', monospace`; // Smaller font for captions (48 / 2 = 24)
            context.textAlign = 'left';
            const captionWidth = context.measureText(caption).width;
            const captionHeight = 24 * 1.2; // Approximate height

            // Position the caption randomly over the line, ensuring it's within bounds
            const captionX = (canvas.width * 0.1) + (Math.random() * (canvas.width * 0.7 - captionWidth));
            const captionY = yPos - (captionHeight / 2) + (Math.random() - 0.5) * (BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.5);

            const padding = 5; // Define padding here
            // Draw black box
            context.fillStyle = 'black';
            context.fillRect(captionX - padding, captionY - captionHeight * 0.7, captionWidth + padding * 2, captionHeight + padding);

            // Draw white text
            context.fillStyle = 'white';
            context.fillText(caption, captionX, captionY);
        }
    }

    biometricMarqueeTexture.needsUpdate = true;
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function createBloodTextTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    let maxWidth = 0;
    context.font = `bold ${BLOOD_TEXT_FONT_SIZE}px 'Impact', sans-serif`;
    BLOOD_TEXT_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    canvas.width = maxWidth + 100; // Add padding
    canvas.height = BLOOD_TEXT_LINE_HEIGHT * (BLOOD_TEXT_TOTAL_LINES * 2); // Double height for scrolling

    bloodTexture = new THREE.CanvasTexture(canvas);
    bloodTexture.wrapS = THREE.RepeatWrapping;
    bloodTexture.wrapT = THREE.RepeatWrapping;
    bloodTexture.needsUpdate = true;
    return bloodTexture;
}

function updateBloodTextTexture() {
    if (!bloodTexture) return;

    const canvas = bloodTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'rgba(0, 0, 0, 0.0)'; // Transparent background
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `bold ${BLOOD_TEXT_FONT_SIZE}px 'Impact', sans-serif`;
    context.fillStyle = 'white'; // White text for contrast
    context.textAlign = 'center';

    const singleSetHeight = BLOOD_TEXT_LINE_HEIGHT * BLOOD_TEXT_TOTAL_LINES;

    // Draw lines, repeating them to create a seamless loop
    for (let i = 0; i < BLOOD_TEXT_TOTAL_LINES * 2; i++) { // Draw two sets of lines
        const phraseIndex = i % shuffledBloodPhrases.length;
        const line = shuffledBloodPhrases[phraseIndex];

        let yPos = (i * BLOOD_TEXT_LINE_HEIGHT) + bloodScrollOffset;

        // When the first set of phrases has scrolled completely off the top of the canvas,
        // wrap it around to the bottom, effectively creating a continuous loop.
        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 3; // Move it to the bottom of the second set
            shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]); // Reshuffle phrases on loop
        }

        context.fillText(line, canvas.width / 2, yPos);
    }

    bloodTexture.needsUpdate = true;
}

function createRedactedGlitchTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    let maxWidth = 0;
    context.font = `${REDACTED_GLITCH_FONT_SIZE}px 'Courier New', monospace`;
    REDACTED_GLITCH_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    canvas.width = maxWidth + 50; // Add padding
    canvas.height = REDACTED_GLITCH_LINE_HEIGHT * (REDACTED_GLITCH_TOTAL_LINES * 2); // Double for seamless scrolling

    redactedGlitchTexture = new THREE.CanvasTexture(canvas);
    redactedGlitchTexture.wrapS = THREE.RepeatWrapping;
    redactedGlitchTexture.wrapT = THREE.RepeatWrapping;
    redactedGlitchTexture.needsUpdate = true;
    return redactedGlitchTexture;
}

function updateRedactedGlitchTexture() {
    if (!redactedGlitchTexture) return;

    const canvas = redactedGlitchTexture.image;
    const context = canvas.getContext('2d');

    // The background of the texture needs to be white for the threshold shader to work correctly.
    // The threshold shader inverts the luma, so white becomes black, and black becomes white.
    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'rgba(255, 255, 255, 1.0)'; // White background for threshold effect
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `${REDACTED_GLITCH_FONT_SIZE}px 'Courier New', monospace`;
    context.textAlign = 'left';

    const singleSetHeight = REDACTED_GLITCH_LINE_HEIGHT * REDACTED_GLITCH_TOTAL_LINES;

    for (let i = 0; i < REDACTED_GLITCH_TOTAL_LINES * 2; i++) {
        const phraseDataIndex = i % redactedGlitchPhraseData.length; // Use the new data structure
        const phraseData = redactedGlitchPhraseData[phraseDataIndex];
        const line = phraseData.text;
        const redactedWordIndices = phraseData.redactedWordIndices;

        let yPos = (i * REDACTED_GLITCH_LINE_HEIGHT) + redactedGlitchScrollOffset;

        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 2;
        }

        // Draw text in black so it becomes white/visible with threshold effect
        context.fillStyle = 'black';
        context.fillText(line, 10, yPos + REDACTED_GLITCH_FONT_SIZE); // Add padding

        // Draw redaction bars (black rectangles on white background will appear white with threshold)
        if (redactedWordIndices.length > 0) {
            const words = line.split(/(\s+)/); // Split by one or more spaces, keeping spaces
            let currentX = 10; // Start X for text (accounting for padding)

            for (let j = 0; j < words.length; j++) {
                const word = words[j];
                const wordWidth = context.measureText(word).width;

                if (!/\s+/.test(word) && redactedWordIndices.includes(j)) { // If it's a word and flagged for redaction
                    // Draw a white rectangle over the selected words (will appear black with threshold)
                    context.fillStyle = 'white';
                    context.fillRect(currentX, yPos + REDACTED_GLITCH_FONT_SIZE * 0.2, wordWidth, REDACTED_GLITCH_FONT_SIZE * 0.9);

                    // Optionally draw a border around the redacted area to make it more pronounced
                    context.strokeStyle = 'black'; // Black border (will be white with threshold)
                    context.lineWidth = 2;
                    context.strokeRect(currentX, yPos + REDACTED_GLITCH_FONT_SIZE * 0.2, wordWidth, REDACTED_GLITCH_FONT_SIZE * 0.9);
                }
                currentX += wordWidth;
            }
        }
    }

    redactedGlitchTexture.needsUpdate = true;
}

function stopCameraAnimationAndReset() {
    if (cameraAnimationActive || effectControls.yRotation) {
        cameraAnimationActive = false;
        effectControls.cameraAnimation = false;
        effectControls.yRotation = false;

        updateUIButtonState('cameraAnimation', false);
        updateUIButtonState('yRotation', false);

        camera.position.copy(initialGlobalCameraPos);
        controls.target.copy(initialGlobalCameraLookAt);
        camera.lookAt(controls.target);
        controls.enabled = true; // Re-enable orbit controls
        controls.update(); // Ensure controls are updated after manual camera set

        cameraAnimationState = 'idle';
        assetsVisitedCount = 0;
    }
    yRotationStartTime = 0; // Reset Y-rotation auto-start timer on interaction
}

function resetPiecesToOriginalPositions() {
    // Remove all current draggable objects and their associated meshes (like redaction rectangles)
    draggableObjects.forEach(object => {
        scene.remove(object);
        if (object.geometry) object.geometry.dispose();
        if (object.material) {
            if (Array.isArray(object.material)) {
                object.material.forEach(m => m.dispose());
            } else {
                object.material.dispose();
            }
        }
    });
    draggableObjects = []; // Clear the array
    cameraAnimationTargets = []; // Clear camera animation targets

    // Reset specific global references
    rightEyeMesh = null;
    leftEyeMesh = null;
    if (rightEyeRedactionRect) { scene.remove(rightEyeRedactionRect); rightEyeRedactionRect.geometry.dispose(); rightEyeRedactionRect.material.dispose(); rightEyeRedactionRect = null; }
    if (leftEyeRedactionRect) { scene.remove(leftEyeRedactionRect); leftEyeRedactionRect.geometry.dispose(); leftEyeRedactionRect.material.dispose(); leftEyeRedactionRect = null; }

    // Remove existing text meshes before re-adding to avoid duplicates and ensure clean state
    if (marqueeTextMesh) { scene.remove(marqueeTextMesh); marqueeTextMesh.geometry.dispose(); marqueeTextMesh.material.dispose(); marqueeTextMesh = null; }
    if (biometricMarqueeTextMesh) { scene.remove(biometricMarqueeTextMesh); biometricMarqueeTextMesh.geometry.dispose(); biometricMarqueeTextMesh.material.dispose(); biometricMarqueeTextMesh = null; }
    if (bloodTextMesh) { scene.remove(bloodTextMesh); bloodTextMesh.geometry.dispose(); bloodTextMesh.material.dispose(); bloodTextMesh = null; }
    if (redactedGlitchTextMesh) { scene.remove(redactedGlitchTextMesh); redactedGlitchTextMesh.geometry.dispose(); redactedGlitchTextMesh.material.dispose(); redactedGlitchTextMesh = null; }

    // Turn off all effects on RESET (before re-adding assets)
    turnOffAllEffects();

    // Re-add all assets from their initial configurations
    initialAssetConfigs.forEach(config => {
        // Reset the 'removed' flag for all assets
        config.removed = false;

        const textureLoader = new THREE.TextureLoader();
        let material, geometry, mesh;

        switch (config.type) {
            case 'image':
                // Only re-add if not a signature image or if it's the *first* signature image
                if (config.id === 'signature') {
                    // Count existing signature images in the scene
                    const existingSignatures = scene.children.filter(child => child.userData.id === 'signature');
                    if (existingSignatures.length >= 1) {
                        // If one signature already exists, skip adding another one
                        return;
                    }
                }
                // Skip adding removed assets
                if (config.removed) return;

                // --- Apply Y-Offset to initial position for non-grid elements ---
                const initialPosClone = config.initialPosition.clone();
                if (!config.id.startsWith('samAltmanGrid')) {
                    initialPosClone.y += Y_OFFSET_DOWN;
                }
                // -----------------------------------------------------------------

                textureLoader.load(config.url, (texture) => {
                    // Apply texture quality settings
                    texture.colorSpace = THREE.SRGBColorSpace;
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                    texture.generateMipmaps = false;
                    texture.anisotropy = renderer.capabilities.getMaxAnisotropy();

                    let currentMaterial;
                    // For images loaded from initialAssetConfigs, use the stored initialScale if available
                    const initialPlaneWidth = config.initialScale.width;
                    const initialPlaneHeight = config.initialScale.height;

                    if (config.id === 'newMouthImage') {
                        // Special case: MultiplyBlending
                        currentMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5, blending: THREE.MultiplyBlending });
                    } else if (config.id === 'hair') { 
                        // Hair starts dark gray (0x808080) in the base state
                        currentMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5, color: new THREE.Color(0x808080) });
                    } else if (FACE_ASSET_IDS.includes(config.id)) {
                        // All other face parts (Eyes, Nose, Mouth, Ear, Forehead, Quote) start slightly darker (0xcccccc)
                        currentMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5, color: new THREE.Color(0xcccccc) });
                    } else if (config.id.startsWith('samAltmanGrid') || config.id.startsWith('samAltmanGridBack') || config.id.startsWith('samAltmanGridFarBack')) { // Handle Sam Altman grid images
                        // Use the shared base material for non-blinking state
                        currentMaterial = logoBaseMaterial.clone();
                        currentMaterial.map = texture;

                        // Re-initialize blinking properties (handled by the loop)
                    } else {
                        // Default for non-face/non-special textures (like signature)
                        currentMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                    }

                    geometry = new THREE.PlaneGeometry(initialPlaneWidth, initialPlaneHeight); // Use calculated initial dimensions
                    mesh = new THREE.Mesh(geometry, currentMaterial);
                    mesh.position.copy(initialPosClone); // Use the offset position
                    mesh.rotation.copy(config.initialRotation ? new THREE.Euler().copy(config.initialRotation) : new THREE.Euler()); // Apply initial rotation if present
                    mesh.userData.currentLayer = config.initialLayer;
                    mesh.userData.initialPosition = config.initialPosition.clone(); // Store the original, un-offset position in userData
                    mesh.userData.initialLayer = config.initialLayer;
                    mesh.userData.id = config.id;
                    mesh.userData.initialScale = { width: initialPlaneWidth, height: initialPlaneHeight }; // Store initial scale
                    
                    if (config.id !== 'signature') {
                        scene.add(mesh);
                        draggableObjects.push(mesh);
                        cameraAnimationTargets.push(mesh);
                    } else { // Signature is static, add directly to scene without making draggable
                        scene.add(mesh);
                    }

                    if (config.id === 'rightEye') {
                        rightEyeMesh = mesh;
                        const redactionWidth = initialPlaneWidth * 1.2;
                        const redactionHeight = initialPlaneHeight * 0.2645;
                        const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
                        const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                        rightEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
                        rightEyeRedactionRect.position.set(mesh.position.x, mesh.position.y, mesh.position.z + (1.5 * depthStep));
                        rightEyeRedactionRect.visible = false;
                        scene.add(rightEyeRedactionRect);
                    } else if (config.id === 'leftEye') {
                        leftEyeMesh = mesh;
                        const redactionWidth = initialPlaneWidth * 1.2;
                        const redactionHeight = initialPlaneHeight * 0.2645;
                        const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
                        const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
                        leftEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
                        leftEyeRedactionRect.position.set(mesh.position.x, mesh.position.y, mesh.position.z + (1.5 * depthStep));
                        leftEyeRedactionRect.visible = false;
                        scene.add(leftEyeRedactionRect);
                    }
                });
                break;
            case 'textMesh':
                // Re-initialize 3D text meshes (Marquee, Biometric, Blood, Redacted Glitch)
                const textInitialPosClone = config.initialPosition.clone();
                textInitialPosClone.y += Y_OFFSET_DOWN; // Apply Y-Offset

                if (config.id === 'marqueeTextMesh') {
                    // Re-create the mesh, as it was disposed earlier
                    marqueeTexture = createMarqueeTexture();
                    const newMarqueeMaterial = new THREE.MeshBasicMaterial({ map: marqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const newMarqueePlaneWidth = 20;
                    const newMarqueePlaneHeight = newMarqueePlaneWidth / (marqueeTexture.image.width / marqueeTexture.image.height);
                    const newMarqueeGeometry = new THREE.PlaneGeometry(newMarqueePlaneWidth, newMarqueePlaneHeight);

                    marqueeTextMesh = new THREE.Mesh(newMarqueeGeometry, newMarqueeMaterial);
                    marqueeTextMesh.position.copy(textInitialPosClone); // Use the offset position
                    marqueeTextMesh.userData.initialPosition = config.initialPosition.clone(); // Store original in userData
                    marqueeTextMesh.userData.initialLayer = config.initialLayer;
                    marqueeTextMesh.visible = effectControls.xray; // Tied to XRAY effect
                    scene.add(marqueeTextMesh);
                } else if (config.id === 'biometricMarqueeTextMesh') {
                    // Re-create the mesh, as it was disposed earlier
                    biometricMarqueeTexture = createBiometricMarqueeTexture();
                    const newBiometricMarqueeMaterial = new THREE.MeshBasicMaterial({ map: biometricMarqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const newBiometricMarqueePlaneWidth = 20;
                    const newBiometricMarqueePlaneHeight = newBiometricMarqueePlaneWidth / (biometricMarqueeTexture.image.width / biometricMarqueeTexture.image.height);
                    const newBiometricMarqueeGeometry = new THREE.PlaneGeometry(newBiometricMarqueePlaneWidth, newBiometricMarqueePlaneHeight);

                    biometricMarqueeTextMesh = new THREE.Mesh(newBiometricMarqueeGeometry, newBiometricMarqueeMaterial);
                    biometricMarqueeTextMesh.position.copy(textInitialPosClone); // Use the offset position
                    biometricMarqueeTextMesh.userData.initialPosition = config.initialPosition.clone(); // Store original in userData
                    biometricMarqueeTextMesh.userData.initialLayer = config.initialLayer;
                    biometricMarqueeTextMesh.visible = effectControls.biometricMarquee || effectControls.og || effectControls.hacker || effectControls.surveillance || effectControls.greed; // Visibility depends on multiple effects
                    scene.add(biometricMarqueeTextMesh);
                } else if (config.id === 'bloodTextMesh') {
                    // Re-create the mesh, as it was disposed earlier
                    bloodTexture = createBloodTextTexture();
                    const newBloodTextMaterial = new THREE.MeshBasicMaterial({ map: bloodTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const newBloodTextPlaneWidth = 20;
                    const newBloodTextPlaneHeight = newBloodTextPlaneWidth / (bloodTexture.image.width / bloodTexture.image.height);
                    const newBloodTextGeometry = new THREE.PlaneGeometry(newBloodTextPlaneWidth, newBloodTextPlaneHeight);

                    bloodTextMesh = new THREE.Mesh(newBloodTextGeometry, newBloodTextMaterial);
                    bloodTextMesh.position.copy(textInitialPosClone); // Use the offset position
                    bloodTextMesh.userData.initialPosition = config.initialPosition.clone(); // Store original in userData
                    bloodTextMesh.userData.initialLayer = config.initialLayer;
                    // Ensure bloodTextMesh is hidden on reset, as the effectControls are reset before this point
                    bloodTextMesh.visible = false;
                    scene.add(bloodTextMesh);
                } else if (config.id === 'redactedGlitchTextMesh') {
                    // Re-create the mesh, as it was disposed earlier
                    redactedGlitchTexture = createRedactedGlitchTexture();
                    const redactedGlitchMaterial = new THREE.MeshBasicMaterial({ map: redactedGlitchTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const redactedGlitchPlaneWidth = 15;
                    const redactedGlitchPlaneHeight = redactedGlitchPlaneWidth / (redactedGlitchTexture.image.width / redactedGlitchTexture.image.height);
                    const newRedactedGlitchGeometry = new THREE.PlaneGeometry(redactedGlitchPlaneWidth, redactedGlitchPlaneHeight);

                    redactedGlitchTextMesh = new THREE.Mesh(newRedactedGlitchGeometry, redactedGlitchMaterial);
                    redactedGlitchTextMesh.position.copy(textInitialPosClone); // Use the offset position
                    redactedGlitchTextMesh.userData.initialPosition = config.initialPosition.clone(); // Store original in userData
                    redactedGlitchTextMesh.userData.initialLayer = config.initialLayer;
                    redactedGlitchTextMesh.visible = effectControls.redactedGlitch; // Respect current effect control
                    scene.add(redactedGlitchTextMesh);
                    initializeRedactedGlitchPhraseData(); // Re-initialize redaction patterns
                }
                break;
        }
    });

    // Reset camera to initial global position and look-at
    camera.position.copy(initialGlobalCameraPos);
    controls.target.copy(initialGlobalCameraLookAt);
    camera.lookAt(controls.target);
    controls.update(); // Update controls after manual camera change

    // Stop any active camera animations or Y-rotation
    effectControls.cameraAnimation = false;
    effectControls.yRotation = false;
    cameraAnimationActive = false;
    controls.enabled = true; // Re-enable orbit controls
    // Update UI buttons for camera animation and Y-rotation
    updateUIButtonState('yRotation', false);
    updateUIButtonState('cameraAnimation', false);

    // Also disable redacted effects as they are tied to eye positions
    effectControls.redacted = false;
    effectControls.redactedGlitch = false;
    effectControls.anon = false; // Turn off anon effect on reset
    effectControls.hacker = false; // Turn off hacker effect on reset
    effectControls.surveillance = false; // Turn off surveillance effect on reset
    effectControls.greed = false; // Turn off greed effect on reset
    updateUIButtonState('redacted', false);
    updateUIButtonState('redactedGlitch', false);
    updateUIButtonState('anon', false);
    updateUIButtonState('hacker', false);
    updateUIButtonState('surveillance', false);
    updateUIButtonState('greed', false);

    // If threshold was forced on by redacted, turn it off if no other effect is using it.
    if (!effectControls.redacted && !effectControls.redactedGlitch && !effectControls.anon && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
        effectControls.threshold = false;
        thresholdPass.enabled = false;
        updateUIButtonState('threshold', false);
    }

    lastActivityTime = performance.now(); // Reset activity timer on reset
    yRotationStartTime = 0; // Reset Y-rotation auto-start timer on reset
    
    // Final step: update material colors to reflect the non-effect state (slightly darker)
    updateFaceMaterialColors();
}

function turnOffAllEffects() {
    // Deactivate all post-processing passes
    greyscalePass.enabled = false;
    thresholdPass.enabled = false;
    darkPass.enabled = false;
    pixelationPass.enabled = false;
    glitchPass.enabled = false;
    matrixPass.enabled = false;
    asciiPass.enabled = false;
    xrayPass.enabled = false;
    heatmapPass.enabled = false;
    bloodPass.enabled = false;
    cctvFeedPass.enabled = false;

    // Reset all effect control booleans to false
    for (const prop in effectControls) {
        if (effectControls.hasOwnProperty(prop)) {
            effectControls[prop] = false;
        }
    }

    // Update UI buttons to reflect inactive state
    updateUIButtonState('greyscale', false);
    updateUIButtonState('threshold', false);
    updateUIButtonState('shadow', false); // Updated from 'dark'
    updateUIButtonState('pixelation', false);
    updateUIButtonState('glitch', false);
    updateUIButtonState('matrix', false);
    updateUIButtonState('ascii', false);
    updateUIButtonState('xray', false);
    updateUIButtonState('heatmap', false);
    updateUIButtonState('blood', false);
    updateUIButtonState('cctvFeed', false);
    updateUIButtonState('yRotation', false);
    updateUIButtonState('cameraAnimation', false);
    updateUIButtonState('redacted', false);
    updateUIButtonState('redactedGlitch', false);
    updateUIButtonState('anon', false);
    updateUIButtonState('biometricMarquee', false);
    updateUIButtonState('og', false);
    updateUIButtonState('bloodText', false);
    updateUIButtonState('hacker', false); // Update hacker button state
    updateUIButtonState('surveillance', false); // Update surveillance button state
    updateUIButtonState('greed', false); // Update greed button state

    // Specific effect cleanups
    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false;
    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false;
    if (marqueeTextMesh) marqueeTextMesh.visible = false;
    if (biometricMarqueeTextMesh) biometricMarqueeTextMesh.visible = false;
    if (bloodTextMesh) bloodTextMesh.visible = false;
    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false;

    cameraAnimationActive = false;
    controls.enabled = true; // Re-enable orbit controls
    cameraAnimationState = 'idle';
    assetsVisitedCount = 0;

    lastActivityTime = performance.now(); // Reset activity timer
    yRotationStartTime = 0; // Reset Y-rotation auto-start timer
    
    // Update material colors to reflect the non-effect state (slightly darker)
    updateFaceMaterialColors();
}

// Cache for canvas contexts to read texture alpha values efficiently
const textureAlphaCanvasCache = new Map();

function getAlphaAtUV(texture, uv) {
    if (!texture || !texture.image || !uv) return 0;

    // Use cached canvas context if available
    let canvas, context;
    if (textureAlphaCanvasCache.has(texture.id)) {
        ({ canvas, context } = textureAlphaCanvasCache.get(texture.id));
    } else {
        canvas = document.createElement('canvas');
        context = canvas.getContext('2d');
        canvas.width = texture.image.width;
        canvas.height = texture.image.height;
        context.drawImage(texture.image, 0, 0);
        textureAlphaCanvasCache.set(texture.id, { canvas, context });
    }

    const x = Math.floor(uv.x * canvas.width);
    const y = Math.floor((1 - uv.y) * canvas.height); // Y-axis needs to be inverted for canvas

    // Ensure coordinates are within bounds
    if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
        return 0;
    }

    const pixelData = context.getImageData(x, y, 1, 1).data;
    return pixelData[3] / 255; // Alpha channel
}

function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 10; // Zoomed out to see the full canvas
    camera.userData.yRotationAngle = 0; // Initialize angle for Y-axis camera rotation

    renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x1e1e1e); // Dark gray background
    renderer.outputColorSpace = THREE.SRGBColorSpace; // Set renderer color space
    document.body.appendChild(renderer.domElement);

    renderer.sortObjects = true; // Enable object sorting for correct transparency rendering

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 20;
    controls.maxPolarAngle = Math.PI / 2;
    controls.addEventListener('change', () => {
        lastActivityTime = performance.now();
        stopCameraAnimationAndReset(); // Stop animation on camera control interaction
    });

    // Store initial global camera position and look-at target
    initialGlobalCameraPos.copy(camera.position);
    initialGlobalCameraLookAt.copy(controls.target);

    // Post-processing setup
    composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    greyscalePass = new ShaderPass(GreyScaleShader);
    composer.addPass(greyscalePass);
    greyscalePass.enabled = effectControls.greyscale;

    thresholdPass = new ShaderPass(ThresholdShader);
    thresholdPass.uniforms['threshold'].value = effectControls.thresholdValue;
    composer.addPass(thresholdPass);
    thresholdPass.enabled = effectControls.threshold;

    darkPass = new ShaderPass(DarkShader);
    darkPass.uniforms['threshold'].value = effectControls.thresholdValue;
    composer.addPass(darkPass);
    darkPass.enabled = effectControls.shadow;

    pixelationPass = new ShaderPass(PixelationShader);
    pixelationPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    pixelationPass.uniforms['pixelSize'].value = effectControls.pixelSize;
    composer.addPass(pixelationPass);
    pixelationPass.enabled = effectControls.pixelation;

    glitchPass = new GlitchPass();
    composer.addPass(glitchPass);
    glitchPass.enabled = effectControls.glitch;

    matrixPass = new ShaderPass(MatrixShader);
    composer.addPass(matrixPass);
    matrixPass.enabled = effectControls.matrix;

    asciiPass = new ShaderPass(ASCIIShader);
    asciiPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    asciiPass.uniforms['pixelSize'].value = effectControls.pixelSize;
    composer.addPass(asciiPass);
    asciiPass.enabled = false;

    xrayPass = new ShaderPass(XRayShader);
    composer.addPass(xrayPass);
    xrayPass.enabled = effectControls.xray;

    heatmapPass = new ShaderPass(HeatmapShader);
    composer.addPass(heatmapPass);
    heatmapPass.enabled = effectControls.heatmap;

    bloodPass = new ShaderPass(BloodShader);
    composer.addPass(bloodPass);
    bloodPass.enabled = effectControls.blood;

    cctvFeedPass = new ShaderPass(CCTVFeedShader);
    cctvFeedPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    cctvFeedPass.uniforms['time'].value = 0.0;
    composer.addPass(cctvFeedPass);
    cctvFeedPass.enabled = effectControls.cctvFeed;

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    const textureLoader = new THREE.TextureLoader();

    // Base scale factor to make images viewable at a reasonable size
    const baseScale = 0.005;

    // Helper function to configure loaded textures
    const configureTexture = (texture) => {
        texture.colorSpace = THREE.SRGBColorSpace;
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;
        texture.generateMipmaps = false;
        texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
    };
    
    // --- Initialize Logo Materials (Crucial Fix for Blinking) ---
    // Load the texture once to create the materials
    textureLoader.load(URL_SAM_ALTMAN, (texture) => {
        configureTexture(texture);
        
        // Material 1: Base State (Black logos on dark background)
        // We set color to 0xffffff, which is multiplied by the black texture, resulting in black.
        logoBaseMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            side: THREE.DoubleSide,
            alphaTest: 0.1,
            color: new THREE.Color(0xffffff) // Multiplies the black texture to appear black
        });
        
        // Material 2: Flash State (Inverted, visible white logos)
        logoFlashMaterial = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            side: THREE.DoubleSide,
            alphaTest: 0.1,
            color: new THREE.Color(0xffffff), // Pure white color
            blending: THREE.AdditiveBlending // Additive blending makes it glow/invert strongly
        });
        
        // Now proceed with adding the grid meshes using the base material
        addSamAltmanGrid(texture);
    });
    // -----------------------------------------------------------

    // Add the new image in same position as forehead, but 1 level higher
    const foreheadCodeInitialPosition = new THREE.Vector3(0, (0.5 + 2.6) * 1.10, (2 - 1) * depthStep);
    foreheadCodeInitialPosition.y += Y_OFFSET_DOWN; // Apply Y-Offset
    textureLoader.load(URL_FOREHEAD_CODE, (texture) => {
        configureTexture(texture); // Configure texture
        // Use slight gray as base color when no effects are active
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5, color: new THREE.Color(0xcccccc) });
        const scaleFactor = 1.2;
        const planeWidth = texture.image.width * baseScale * scaleFactor;
        const planeHeight = texture.image.height * baseScale * scaleFactor;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const foreheadCode = new THREE.Mesh(geometry, material);
        foreheadCode.position.copy(foreheadCodeInitialPosition);
        foreheadCode.userData.currentLayer = 3;
        foreheadCode.userData.initialPosition = foreheadCodeInitialPosition.clone();
        foreheadCode.userData.initialLayer = 3;
        foreheadCode.userData.id = 'foreheadCode';
        foreheadCode.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store the initial calculated scale
        scene.add(foreheadCode);
        draggableObjects.push(foreheadCode);
        cameraAnimationTargets.push(foreheadCode);

        // Store original, un-offset position in config
        const originalPosition = foreheadCodeInitialPosition.clone();
        originalPosition.y -= Y_OFFSET_DOWN; 

        initialAssetConfigs.push({
            id: 'foreheadCode',
            type: 'image',
            url: URL_FOREHEAD_CODE,
            initialPosition: originalPosition,
            initialLayer: 3,
            initialScale: { width: planeWidth, height: planeHeight }, // Store the initial calculated scale
            removed: false
        });
    });

    // Load and add the right eye image
    const rightEyeInitialPosition = new THREE.Vector3(-1.8 * .7 * 1, (0.175 * 1.15 * 1.20 * 3) + 2.0 - 1.2, (7 - 1) * depthStep);
    rightEyeInitialPosition.y += Y_OFFSET_DOWN; // Apply Y-Offset
    textureLoader.load(URL_RIGHT_EYE, (texture) => {
        configureTexture(texture); // Configure texture
        // Use slight gray as base color when no effects are active
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5, color: new THREE.Color(0xcccccc) });
        const planeWidth = texture.image.width * baseScale * 0.6; // Reduced by 20%
        const planeHeight = texture.image.height * baseScale * 0.6; // Reduced by 20%
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        rightEyeMesh = new THREE.Mesh(geometry, material);
        rightEyeMesh.position.copy(rightEyeInitialPosition);
        rightEyeMesh.userData.currentLayer = 7;
        rightEyeMesh.userData.initialPosition = rightEyeInitialPosition.clone();
        rightEyeMesh.userData.initialLayer = 7;
        rightEyeMesh.userData.id = 'rightEye'; // Added ID
        rightEyeMesh.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(rightEyeMesh);
        draggableObjects.push(rightEyeMesh);
        cameraAnimationTargets.push(rightEyeMesh);

        // Create and add the redaction rectangle for the right eye
        const redactionWidth = planeWidth * 1.2;
        const redactionHeight = planeHeight * 0.4;
        const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
        const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        rightEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
        // Position it at the same X, Y as the eye, but 1.5 levels in front
        rightEyeRedactionRect.position.set(
            rightEyeMesh.position.x,
            rightEyeMesh.position.y,
            rightEyeMesh.position.z + (1.5 * depthStep)
        );
        rightEyeRedactionRect.visible = false;
        scene.add(rightEyeRedactionRect);

        // Store original, un-offset position in config
        const originalPosition = rightEyeInitialPosition.clone();
        originalPosition.y -= Y_OFFSET_DOWN;

        initialAssetConfigs.push({
            id: 'rightEye',
            type: 'image',
            url: URL_RIGHT_EYE,
            initialPosition: originalPosition,
            initialLayer: 7,
            initialScale: { width: planeWidth, height: planeHeight }, // Store the initial calculated scale
            removed: false // Add removed flag
        });
    });

    // Load and add the mouth image
    const mouthInitialPosition = new THREE.Vector3(0, -2.0, (9 - 1) * depthStep);
    mouthInitialPosition.y += Y_OFFSET_DOWN; // Apply Y-Offset
    textureLoader.load(URL_MOUTH, (texture) => {
        configureTexture(texture); // Configure texture
        // Use slight gray as base color when no effects are active
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5, color: new THREE.Color(0xcccccc) });
        const planeWidth = texture.image.width * baseScale;
        const planeHeight = texture.image.height * baseScale;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const mouth = new THREE.Mesh(geometry, material);
        mouth.position.copy(mouthInitialPosition);
        mouth.userData.currentLayer = 9;
        mouth.userData.initialPosition = mouthInitialPosition.clone();
        mouth.userData.initialLayer = 9;
        mouth.userData.id = 'mouth'; // Added ID
        mouth.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(mouth);
        draggableObjects.push(mouth);
        cameraAnimationTargets.push(mouth);

        // Store original, un-offset position in config
        const originalPosition = mouthInitialPosition.clone();
        originalPosition.y -= Y_OFFSET_DOWN;

        initialAssetConfigs.push({
            id: 'mouth',
            type: 'image',
            url: URL_MOUTH,
            initialPosition: originalPosition, // Store the cloned position
            initialLayer: 9,
            initialScale: { width: planeWidth, height: planeHeight }, // Store the initial calculated scale
            removed: false // Add removed flag
        });
    });

    // Add the new image above the mouth
    const newMouthImageInitialPosition = new THREE.Vector3(0, -2.0, (10 - 1) * depthStep);
    newMouthImageInitialPosition.y += Y_OFFSET_DOWN; // Apply Y-Offset
    textureLoader.load(URL_NEW_MOUTH_IMAGE, (texture) => {
        configureTexture(texture); // Configure texture
        const material = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            side: THREE.DoubleSide,
            alphaTest: 0.5,
            blending: THREE.MultiplyBlending // Added blending effect
        });
        const planeWidth = texture.image.width * baseScale;
        const planeHeight = texture.image.height * baseScale;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const newMouthImage = new THREE.Mesh(geometry, material);
        newMouthImage.position.copy(newMouthImageInitialPosition);
        newMouthImage.userData.currentLayer = 10;
        newMouthImage.userData.initialPosition = newMouthImageInitialPosition.clone();
        newMouthImage.userData.initialLayer = 10;
        newMouthImage.userData.id = 'newMouthImage';
        newMouthImage.userData.initialScale = { width: planeWidth, height: planeHeight };
        scene.add(newMouthImage);
        draggableObjects.push(newMouthImage);
        cameraAnimationTargets.push(newMouthImage);

        // Store original, un-offset position in config
        const originalPosition = newMouthImageInitialPosition.clone();
        originalPosition.y -= Y_OFFSET_DOWN;

        initialAssetConfigs.push({
            id: 'newMouthImage',
            type: 'image',
            url: URL_NEW_MOUTH_IMAGE,
            initialPosition: originalPosition,
            initialLayer: 10,
            initialScale: { width: planeWidth, height: planeHeight }, // Store the initial calculated scale
            removed: false
        });
    });

    // Load and add the ear image
    const earNewLayer = 3;
    const earNewZ = (earNewLayer - 1) * depthStep;
    const distance_from_camera_ear = camera.position.z - earNewZ;
    const world_height_at_ear_z = 2 * distance_from_camera_ear * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
    const world_width_at_ear_z = world_height_at_ear_z * camera.aspect;
    const pixelToUnitFactorX_ear = world_width_at_ear_z / window.innerWidth;
    const moveLeftUnits = 2 * pixelToUnitFactorX_ear;
    const earInitialPosition = new THREE.Vector3(-2.75 - moveLeftUnits, 1.25, earNewZ);
    earInitialPosition.y += Y_OFFSET_DOWN; // Apply Y-Offset
    const earInitialRotation = new THREE.Euler(0, THREE.MathUtils.degToRad(-45), 0);
    textureLoader.load(URL_EAR, (texture) => {
        configureTexture(texture); // Configure texture
        // Use slight gray as base color when no effects are active
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5, color: new THREE.Color(0xcccccc) });
        const planeWidth = texture.image.width * baseScale;
        const planeHeight = texture.image.height * baseScale;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const ear = new THREE.Mesh(geometry, material);

        ear.position.copy(earInitialPosition);
        ear.rotation.copy(earInitialRotation); // Apply initial rotation
        ear.userData.currentLayer = earNewLayer;
        ear.userData.initialPosition = earInitialPosition.clone();
        ear.userData.initialLayer = earNewLayer;
        ear.userData.id = 'ear'; // Added ID
        ear.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(ear);
        draggableObjects.push(ear);
        cameraAnimationTargets.push(ear);

        // Store original, un-offset position in config
        const originalPosition = earInitialPosition.clone();
        originalPosition.y -= Y_OFFSET_DOWN;

        initialAssetConfigs.push({
            id: 'ear',
            type: 'image',
            url: URL_EAR,
            initialPosition: originalPosition,
            initialRotation: earInitialRotation.clone(),
            initialScale: { width: planeWidth, height: planeHeight }, // Store the initial calculated scale
            removed: false // Add removed flag
        });
    });

    // Load and add the left eye image
    const leftEyeInitialPosition = new THREE.Vector3(0.84 * 1.2 * 1.2, (0.175 * 1.15 * 1.20 * 3) + 2.0 - 1.3, (9 - 1) * depthStep);
    leftEyeInitialPosition.y += Y_OFFSET_DOWN; // Apply Y-Offset
    textureLoader.load(URL_LEFT_EYE, (texture) => {
        configureTexture(texture); // Configure texture
        // Use slight gray as base color when no effects are active
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5, color: new THREE.Color(0xcccccc) });
        const planeWidth = texture.image.width * baseScale; // 100% size, original file size (scaled by baseScale)
        const planeHeight = texture.image.height * baseScale; // 100% size, original file size (scaled by baseScale)
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        leftEyeMesh = new THREE.Mesh(geometry, material);
        leftEyeMesh.position.copy(leftEyeInitialPosition);
        leftEyeMesh.userData.currentLayer = 9;
        leftEyeMesh.userData.initialPosition = leftEyeInitialPosition.clone();
        leftEyeMesh.userData.initialLayer = 9;
        leftEyeMesh.userData.id = 'leftEye'; // Added ID
        leftEyeMesh.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(leftEyeMesh);
        draggableObjects.push(leftEyeMesh);
        cameraAnimationTargets.push(leftEyeMesh);

        // Create and add the redaction rectangle for the left eye
        const redactionWidth = planeWidth * 1.2;
        const redactionHeight = planeHeight * 0.42; // Corrected definition here
        const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
        const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
        leftEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
        // Position it at the same X, Y as the eye, but 1.5 levels in front
        leftEyeRedactionRect.position.set(
            leftEyeMesh.position.x,
            leftEyeMesh.position.y,
            leftEyeMesh.position.z + (1.5 * depthStep)
        );
        leftEyeRedactionRect.visible = false;
        scene.add(leftEyeRedactionRect);

        // Store original, un-offset position in config
        const originalPosition = leftEyeInitialPosition.clone();
        originalPosition.y -= Y_OFFSET_DOWN;

        initialAssetConfigs.push({
            id: 'leftEye',
            type: 'image',
            url: URL_LEFT_EYE,
            initialPosition: originalPosition,
            initialLayer: 9,
            initialScale: { width: planeWidth, height: planeHeight }, // Store the initial calculated scale
            removed: false // Add removed flag
        });
    });

    // Load and add the nose image
    const noseInitialPosition = new THREE.Vector3(0, 0.4, (11 - 1) * depthStep);
    noseInitialPosition.y += Y_OFFSET_DOWN; // Apply Y-Offset
    textureLoader.load(URL_NOSE, (texture) => {
        configureTexture(texture); // Configure texture
        // Use slight gray as base color when no effects are active
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5, color: new THREE.Color(0xcccccc) });
        const scaleFactor = 0.93;
        const planeWidth = texture.image.width * baseScale * scaleFactor;
        const planeHeight = texture.image.height * baseScale * scaleFactor;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const nose = new THREE.Mesh(geometry, material);
        nose.position.copy(noseInitialPosition);
        nose.userData.currentLayer = 11;
        nose.userData.initialPosition = noseInitialPosition.clone();
        nose.userData.initialLayer = 11;
        nose.userData.id = 'nose'; // Added ID
        nose.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(nose);
        draggableObjects.push(nose);
        cameraAnimationTargets.push(nose);

        // Store original, un-offset position in config
        const originalPosition = noseInitialPosition.clone();
        originalPosition.y -= Y_OFFSET_DOWN;

        initialAssetConfigs.push({
            id: 'nose',
            type: 'image',
            url: URL_NOSE,
            initialPosition: originalPosition,
            initialLayer: 11,
            initialScale: { width: planeWidth, height: planeHeight }, // Store the initial calculated scale
            removed: false // Add removed flag
        });
    });

    // Load and add the hair image
    const hairInitialPosition = new THREE.Vector3(0, 3.1 * 1.10, (4 - 1) * depthStep);
    hairInitialPosition.y += Y_OFFSET_DOWN; // Apply Y-Offset
    const hairInitialRotation = new THREE.Euler(0, 0, 0); // DECLARATION ADDED TO FIX ERROR
    textureLoader.load(URL_HAIR, (texture) => {
        configureTexture(texture); // Configure texture
        const material = new THREE.MeshBasicMaterial({
            map: texture,
            transparent: true,
            side: THREE.DoubleSide,
            alphaTest: 0.5,
            color: new THREE.Color(0x808080) // Set color to 50% grey to make it darker (Base state)
        });
        const scaleFactor = 1.55;
        const planeWidth = texture.image.width * baseScale * scaleFactor;
        const planeHeight = texture.image.height * baseScale * scaleFactor;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const hair = new THREE.Mesh(geometry, material);
        hair.position.copy(hairInitialPosition);
        hair.rotation.copy(hairInitialRotation); // Apply initial rotation
        hair.userData.currentLayer = 4;
        hair.userData.initialPosition = hairInitialPosition.clone();
        hair.userData.initialLayer = 4;
        hair.userData.id = 'hair'; // Added ID
        hair.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(hair);
        draggableObjects.push(hair);
        cameraAnimationTargets.push(hair);

        // Store original, un-offset position in config
        const originalPosition = hairInitialPosition.clone();
        originalPosition.y -= Y_OFFSET_DOWN;

        initialAssetConfigs.push({
            id: 'hair',
            type: 'image',
            url: URL_HAIR,
            initialPosition: originalPosition,
            initialLayer: 4,
            initialScale: { width: planeWidth, height: planeHeight }, // Store the initial calculated scale
            removed: false // Add removed flag
        });
    });


            // Load and add the signature image
            const signatureNewLayer = 2 - 2; // 2 levels behind where rocket was (rocket was layer 2) -> layer 0
            const signatureNewZ = (signatureNewLayer - 1) * depthStep; // (0 - 1) * 0.2 = -0.2
            const signatureNewX = -2.0; // Moved to the right from -2.5
            const signatureNewY = -4.7; // Same Y as where fiatWorthless was
            const signatureInitialPosition = new THREE.Vector3(signatureNewX, signatureNewY, signatureNewZ);
            signatureInitialPosition.y += Y_OFFSET_DOWN; // Apply Y-Offset

            textureLoader.load(URL_SIGNATURE, (signatureTexture) => {
                configureTexture(signatureTexture); // Configure texture
                const signatureMaterial = new THREE.MeshBasicMaterial({ map: signatureTexture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                const signatureAspectRatio = signatureTexture.image.width / signatureTexture.image.height;
                const signatureHeight = 1.0;
                const signatureWidth = signatureHeight * signatureAspectRatio;
                const signatureGeometry = new THREE.PlaneGeometry(signatureWidth, signatureHeight);
                const signature = new THREE.Mesh(signatureGeometry, signatureMaterial);

                signature.position.copy(signatureInitialPosition);

                signature.userData.currentLayer = signatureNewLayer;
                signature.userData.id = 'signature'; // Added ID
                signature.userData.initialScale = { width: signatureWidth, height: signatureHeight }; // Store initial scale
                scene.add(signature);
                // Note: signature is NOT added to draggableObjects, making it static and locked.

                // Store original, un-offset position in config
                const originalPosition = signatureInitialPosition.clone();
                originalPosition.y -= Y_OFFSET_DOWN;

                initialAssetConfigs.push({
                    id: 'signature',
                    type: 'image',
                    url: URL_SIGNATURE,
                    initialPosition: originalPosition,
                    initialLayer: signatureNewLayer,
                    initialScale: { width: signatureWidth, height: signatureHeight }, // Store the initial calculated scale
                    removed: false // Add removed flag
                });
            });

    // Load and add the Altman Quote image
    const altmanQuoteInitialPosition = new THREE.Vector3(2.5, -0.45, (9 - 1) * depthStep); // Left side, centered Y, layer 6
    altmanQuoteInitialPosition.y += Y_OFFSET_DOWN; // Apply Y-Offset
    const altmanQuoteInitialRotation = new THREE.Euler(0, THREE.MathUtils.degToRad(30), 0); // Angled 20 degrees around Y
    textureLoader.load(URL_ALTMAN_QUOTE, (texture) => {
        configureTexture(texture); // Configure texture
        // Use slight gray as base color when no effects are active
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5, color: new THREE.Color(0xcccccc) });
        const planeWidth = texture.image.width * baseScale * .8; // Slightly larger
        const planeHeight = texture.image.height * baseScale * .8; // Slightly larger
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const altmanQuote = new THREE.Mesh(geometry, material);
        altmanQuote.position.copy(altmanQuoteInitialPosition);
        altmanQuote.rotation.copy(altmanQuoteInitialRotation);
        altmanQuote.userData.currentLayer = 6;
        altmanQuote.userData.initialPosition = altmanQuoteInitialPosition.clone();
        altmanQuote.userData.initialRotation = altmanQuoteInitialRotation.clone();
        altmanQuote.userData.initialLayer = 6;
        altmanQuote.userData.id = 'altmanQuote';
        altmanQuote.userData.initialScale = { width: planeWidth, height: planeHeight };
        scene.add(altmanQuote);
        draggableObjects.push(altmanQuote);
        cameraAnimationTargets.push(altmanQuote);

        // Store original, un-offset position in config
        const originalPosition = altmanQuoteInitialPosition.clone();
        originalPosition.y -= Y_OFFSET_DOWN;

        initialAssetConfigs.push({
            id: 'altmanQuote',
            type: 'image',
            url: URL_ALTMAN_QUOTE,
            initialPosition: originalPosition,
            initialRotation: altmanQuoteInitialRotation.clone(),
            initialLayer: 6,
            initialScale: { width: planeWidth, height: planeHeight },
            removed: false
        });
    });


    // Initialize the Marquee Text (for XRAY effect)
    marqueeTexture = createMarqueeTexture();
    const marqueeMaterial = new THREE.MeshBasicMaterial({ map: marqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    // The plane size should be relative to the background or screen to fill it
    const marqueePlaneWidth = 20;
    const marqueePlaneHeight = marqueePlaneWidth / (marqueeTexture.image.width / marqueeTexture.image.height);
    const marqueeGeometry = new THREE.PlaneGeometry(marqueePlaneWidth, marqueePlaneHeight);
    const marqueeTextMeshInitialPosition = new THREE.Vector3(0, 0, -3 * depthStep);
    marqueeTextMeshInitialPosition.y += Y_OFFSET_DOWN; // Apply Y-Offset

    marqueeTextMesh = new THREE.Mesh(marqueeGeometry, marqueeMaterial);
    // Position far back in the background, but in front of the actual background image
    marqueeTextMesh.position.copy(marqueeTextMeshInitialPosition);
    marqueeTextMesh.visible = false;
    marqueeTextMesh.userData.initialPosition = marqueeTextMeshInitialPosition.clone();
    marqueeTextMesh.userData.initialLayer = -3;
    marqueeTextMesh.userData.id = 'marqueeTextMesh'; // Added ID
    scene.add(marqueeTextMesh);

    // Store original, un-offset position in config
    const originalMarqueePosition = marqueeTextMeshInitialPosition.clone();
    originalMarqueePosition.y -= Y_OFFSET_DOWN;

    initialAssetConfigs.push({
        id: 'marqueeTextMesh',
        type: 'textMesh',
        initialPosition: originalMarqueePosition,
        initialLayer: -3,
        geometry: marqueeGeometry.clone(),
        material: marqueeMaterial.clone(),
        removed: false // Add removed flag
    });

    // Initialize the new Biometric Marquee Text
    biometricMarqueeTexture = createBiometricMarqueeTexture();
    const biometricMarqueeMaterial = new THREE.MeshBasicMaterial({ map: biometricMarqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    const biometricMarqueePlaneWidth = 20; // Same width as main marquee for consistency
    const biometricMarqueePlaneHeight = biometricMarqueePlaneWidth / (biometricMarqueeTexture.image.width / biometricMarqueeTexture.image.height);
    const biometricMarqueeGeometry = new THREE.PlaneGeometry(biometricMarqueePlaneWidth, biometricMarqueePlaneHeight);
    const biometricMarqueeZ = (5 - 1) * depthStep;
    const distance_from_camera_biometric = camera.position.z - biometricMarqueeZ;
    const world_height_biometric = 2 * distance_from_camera_biometric * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
    const pixelToUnitFactorX_biometric = (world_height_biometric * camera.aspect) / window.innerWidth;
    const moveRightUnits_biometric = 30 * pixelToUnitFactorX_biometric;
    const biometricMarqueeTextMeshInitialPosition = new THREE.Vector3(moveRightUnits_biometric, 0, biometricMarqueeZ);
    biometricMarqueeTextMeshInitialPosition.y += Y_OFFSET_DOWN; // Apply Y-Offset

    biometricMarqueeTextMesh = new THREE.Mesh(biometricMarqueeGeometry, biometricMarqueeMaterial);
    biometricMarqueeTextMesh.position.copy(biometricMarqueeTextMeshInitialPosition);
    biometricMarqueeTextMesh.visible = false; // Initially hidden
    biometricMarqueeTextMesh.userData.initialPosition = biometricMarqueeTextMeshInitialPosition.clone();
    biometricMarqueeTextMesh.userData.initialLayer = 5;
    biometricMarqueeTextMesh.userData.id = 'biometricMarqueeTextMesh'; // Added ID
    scene.add(biometricMarqueeTextMesh);

    // Store original, un-offset position in config
    const originalBiometricPosition = biometricMarqueeTextMeshInitialPosition.clone();
    originalBiometricPosition.y -= Y_OFFSET_DOWN;

    initialAssetConfigs.push({
        id: 'biometricMarqueeTextMesh',
        type: 'textMesh',
        initialPosition: originalBiometricPosition,
        initialLayer: 5,
        geometry: biometricMarqueeGeometry.clone(),
        material: biometricMarqueeMaterial.clone(),
        removed: false // Add removed flag
    });

    // Initialize the new Blood Text
    bloodTexture = createBloodTextTexture();
    const bloodTextMaterial = new THREE.MeshBasicMaterial({ map: bloodTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    const bloodTextPlaneWidth = 20; // Similar width to other marquees
    const bloodTextPlaneHeight = bloodTextPlaneWidth / (bloodTexture.image.width / bloodTexture.image.height);
    const bloodTextGeometry = new THREE.PlaneGeometry(bloodTextPlaneWidth, bloodTextPlaneHeight);
    const bloodTextMeshInitialPosition = new THREE.Vector3(0, 30, (8 - 1) * depthStep);
    bloodTextMeshInitialPosition.y += Y_OFFSET_DOWN; // Apply Y-Offset

    bloodTextMesh = new THREE.Mesh(bloodTextGeometry, bloodTextMaterial);
    // Position on Level 8 (moved back from Level 12 by 4 levels)
    bloodTextMesh.position.copy(bloodTextMeshInitialPosition);
    bloodTextMesh.visible = false; // Initially hidden
    bloodTextMesh.userData.initialPosition = bloodTextMeshInitialPosition.clone();
    bloodTextMesh.userData.initialLayer = 8;
    bloodTextMesh.userData.id = 'bloodTextMesh'; // Added ID
    scene.add(bloodTextMesh);

    // Store original, un-offset position in config
    const originalBloodPosition = bloodTextMeshInitialPosition.clone();
    originalBloodPosition.y -= Y_OFFSET_DOWN;

    initialAssetConfigs.push({
        id: 'bloodTextMesh',
        type: 'textMesh',
        initialPosition: originalBloodPosition,
        initialLayer: 8,
        geometry: bloodTextGeometry.clone(),
        material: bloodTextMaterial.clone(),
        removed: false // Add removed flag
    });

    // Initialize the new Redacted Glitch Text
    redactedGlitchTexture = createRedactedGlitchTexture();
    const redactedGlitchMaterial = new THREE.MeshBasicMaterial({ map: redactedGlitchTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    const redactedGlitchPlaneWidth = 15; // Width for the text block
    const redactedGlitchPlaneHeight = redactedGlitchPlaneWidth / (redactedGlitchTexture.image.width / redactedGlitchTexture.image.height);
    const redactedGlitchGeometry = new THREE.PlaneGeometry(redactedGlitchPlaneWidth, redactedGlitchPlaneHeight);
    const redactedGlitchTextZ = (1 - 8) * depthStep;
    const distance_from_camera_redacted = camera.position.z - redactedGlitchTextZ;
    const world_height_redacted = 2 * distance_from_camera_redacted * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
    const pixelToUnitFactorX_redacted = (world_height_redacted * camera.aspect) / window.innerWidth;
    const moveRightUnits_redacted = 40 * pixelToUnitFactorX_redacted;
    const redactedGlitchTextMeshInitialPosition = new THREE.Vector3(-5 + moveRightUnits_redacted, 0, redactedGlitchTextZ);
    redactedGlitchTextMeshInitialPosition.y += Y_OFFSET_DOWN; // Apply Y-Offset

    redactedGlitchTextMesh = new THREE.Mesh(redactedGlitchGeometry, redactedGlitchMaterial);
    redactedGlitchTextMesh.position.copy(redactedGlitchTextMeshInitialPosition);
    redactedGlitchTextMesh.visible = false; // Initially hidden
    redactedGlitchTextMesh.userData.initialPosition = redactedGlitchTextMeshInitialPosition.clone();
    redactedGlitchTextMesh.userData.initialLayer = 1;
    redactedGlitchTextMesh.userData.id = 'redactedGlitchTextMesh'; // Added ID
    scene.add(redactedGlitchTextMesh);

    // Store original, un-offset position in config
    const originalRedactedPosition = redactedGlitchTextMeshInitialPosition.clone();
    originalRedactedPosition.y -= Y_OFFSET_DOWN;

    initialAssetConfigs.push({
        id: 'redactedGlitchTextMesh',
        type: 'textMesh',
        initialPosition: originalRedactedPosition,
        initialLayer: 1,
        geometry: redactedGlitchGeometry.clone(),
        material: redactedGlitchMaterial.clone(),
        removed: false // Add removed flag
    });

    initializeRedactedGlitchPhraseData(); // Initialize the redaction patterns

    // Helper function to add the Sam Altman grid (Called after materials are initialized)
    function addSamAltmanGrid(texture) {
        const gridRows = 6;
        const gridCols = 6;
        const gridZ = (0 - 4) * depthStep; // Layer 0 means z-position will be negative

        // Calculate the visible width and height at gridZ
        const distanceToGrid = camera.position.z - gridZ;
        const vFOV = THREE.MathUtils.degToRad(camera.fov);
        const worldHeight = 2 * Math.tan(vFOV / 2) * distanceToGrid;
        const worldWidth = worldHeight * camera.aspect;

        // Adjust these values to center the grid and provide padding
        const totalGridWidth = worldWidth * 0.9; // 90% of visible width
        const totalGridHeight = worldHeight * 0.9; // 90% of visible height

        const startX = -totalGridWidth / 2;
        const startY = totalGridHeight / 2;

        const cellWidth = totalGridWidth / gridCols;
        const cellHeight = totalGridHeight / gridRows;

        const imageAspectRatio = texture.image.width / texture.image.height;
        const planeHeight = cellHeight * 0.9; // Use 90% of cell height for padding
        const planeWidth = planeHeight * imageAspectRatio;

        // Grid 1 (Front)
        for (let row = 0; row < gridRows; row++) {
            for (let col = 0; col < gridCols; col++) {
                const x = startX + (col * cellWidth) + (cellWidth / 2);
                const y = startY - (row * cellHeight) - (cellHeight / 2);
                const samAltmanGridInitialPosition = new THREE.Vector3(x, y, gridZ);

                // Start with the base material
                const material = logoBaseMaterial.clone();
                const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                const samAltmanMesh = new THREE.Mesh(geometry, material);
                samAltmanMesh.position.copy(samAltmanGridInitialPosition);
                samAltmanMesh.userData.currentLayer = 0;
                samAltmanMesh.userData.initialPosition = samAltmanGridInitialPosition.clone(); // Store the original calculated position
                samAltmanMesh.userData.initialLayer = 0;
                samAltmanMesh.userData.id = `samAltmanGrid_${row}_${col}`;
                samAltmanMesh.userData.initialScale = { width: planeWidth, height: planeHeight };
                
                // NEW BLINKING LOGIC INITIALIZATION
                const now = performance.now();
                samAltmanMesh.userData.isBlinking = false; 
                samAltmanMesh.userData.nextBlinkTime = now + (Math.random() * 4000); 
                samAltmanMesh.userData.blinkDuration = 100 + Math.random() * 400; 
                samAltmanMesh.userData.blinkInterval = 1000 + Math.random() * 4000; 
                samAltmanMesh.userData.baseMaterial = material; // Store reference to the base material
                samAltmanMesh.userData.flashMaterial = logoFlashMaterial; // Store reference to the flash material
                samAltmanMesh.material = material; // Ensure it starts with base material

                scene.add(samAltmanMesh);
                draggableObjects.push(samAltmanMesh);
                cameraAnimationTargets.push(samAltmanMesh);

                initialAssetConfigs.push({
                    id: samAltmanMesh.userData.id,
                    type: 'image',
                    url: URL_SAM_ALTMAN,
                    initialPosition: samAltmanGridInitialPosition.clone(),
                    initialLayer: 0,
                    initialScale: { width: planeWidth, height: planeHeight }, 
                    removed: false,
                });
            }
        }

        // Grid 2 (Back)
        const gridZBack = (0 - 1 - 120) * depthStep; 
        const distanceToGridBack = camera.position.z - gridZBack;
        const worldHeightBack = 2 * Math.tan(vFOV / 2) * distanceToGridBack;
        const worldWidthBack = worldHeightBack * camera.aspect;
        const totalGridWidthBack = worldWidthBack * 0.9;
        const totalGridHeightBack = worldHeightBack * 0.9;
        const startXBack = -totalGridWidthBack / 2;
        const startYBack = totalGridHeightBack / 2;
        const cellWidthBack = totalGridWidthBack / gridCols;
        const cellHeightBack = totalGridHeightBack / gridRows;
        const planeHeightBack = cellHeightBack * 0.9; 
        const planeWidthBack = planeHeightBack * imageAspectRatio;

        for (let row = 0; row < gridRows; row++) {
            for (let col = 0; col < gridCols; col++) {
                const x = startXBack + (col * cellWidthBack) + (cellWidthBack / 2);
                const y = startYBack - (row * cellHeightBack) - (cellHeightBack / 2);
                const samAltmanGridBackInitialPosition = new THREE.Vector3(x, y, gridZBack);

                const material = logoBaseMaterial.clone();
                const geometry = new THREE.PlaneGeometry(planeWidthBack, planeHeightBack);
                const samAltmanMeshBack = new THREE.Mesh(geometry, material);
                samAltmanMeshBack.position.copy(samAltmanGridBackInitialPosition);
                samAltmanMeshBack.userData.currentLayer = -10; 
                samAltmanMeshBack.userData.initialPosition = samAltmanGridBackInitialPosition.clone();
                samAltmanMeshBack.userData.initialLayer = -10;
                samAltmanMeshBack.userData.id = `samAltmanGridBack_${row}_${col}`;
                samAltmanMeshBack.userData.initialScale = { width: planeWidthBack, height: planeHeightBack };
                
                const now = performance.now();
                samAltmanMeshBack.userData.isBlinking = false;
                samAltmanMeshBack.userData.nextBlinkTime = now + (Math.random() * 4000); 
                samAltmanMeshBack.userData.blinkDuration = 100 + Math.random() * 400; 
                samAltmanMeshBack.userData.blinkInterval = 1000 + Math.random() * 4000; 
                samAltmanMeshBack.userData.baseMaterial = material; 
                samAltmanMeshBack.userData.flashMaterial = logoFlashMaterial; 
                samAltmanMeshBack.material = material; 

                scene.add(samAltmanMeshBack);
                draggableObjects.push(samAltmanMeshBack);
                cameraAnimationTargets.push(samAltmanMeshBack);

                initialAssetConfigs.push({
                    id: samAltmanMeshBack.userData.id,
                    type: 'image',
                    url: URL_SAM_ALTMAN,
                    initialPosition: samAltmanGridBackInitialPosition.clone(),
                    initialLayer: -10,
                    initialScale: { width: planeWidthBack, height: planeHeightBack }, 
                    removed: false,
                });
            }
        }

        // Grid 3 (Far Back)
        const gridZFarBack = (0 - 1 - 420) * depthStep; 
        const distanceToGridFarBack = camera.position.z - gridZFarBack;
        const worldHeightFarBack = 2 * Math.tan(vFOV / 2) * distanceToGridFarBack;
        const worldWidthFarBack = worldHeightFarBack * camera.aspect;
        const totalGridWidthFarBack = worldWidthFarBack * 0.9;
        const totalGridHeightFarBack = worldHeightFarBack * 0.9;
        const startXFarBack = -totalGridWidthFarBack / 2;
        const startYFarBack = totalGridHeightFarBack / 2;
        const cellWidthFarBack = totalGridWidthFarBack / gridCols;
        const cellHeightFarBack = totalGridHeightFarBack / gridRows;
        const planeHeightFarBack = cellHeightFarBack * 0.9; 
        const planeWidthFarBack = planeHeightFarBack * imageAspectRatio;

        for (let row = 0; row < gridRows; row++) {
            for (let col = 0; col < gridCols; col++) {
                const x = startXFarBack + (col * cellWidthFarBack) + (cellWidthFarBack / 2);
                const y = startYFarBack - (row * cellHeightFarBack) - (cellHeightFarBack / 2);
                const samAltmanGridFarBackInitialPosition = new THREE.Vector3(x, y, gridZFarBack);

                const material = logoBaseMaterial.clone();
                const geometry = new THREE.PlaneGeometry(planeWidthFarBack, planeHeightFarBack);
                const samAltmanMeshFarBack = new THREE.Mesh(geometry, material);
                samAltmanMeshFarBack.position.copy(samAltmanGridFarBackInitialPosition);
                samAltmanMeshFarBack.userData.currentLayer = -240; 
                samAltmanMeshFarBack.userData.initialPosition = samAltmanGridFarBackInitialPosition.clone();
                samAltmanMeshFarBack.userData.initialLayer = -240;
                samAltmanMeshFarBack.userData.id = `samAltmanGridFarBack_${row}_${col}`;
                samAltmanMeshFarBack.userData.initialScale = { width: planeWidthFarBack, height: planeHeightFarBack };
                
                const now = performance.now();
                samAltmanMeshFarBack.userData.isBlinking = false;
                samAltmanMeshFarBack.userData.nextBlinkTime = now + (Math.random() * 4000); 
                samAltmanMeshFarBack.userData.blinkDuration = 100 + Math.random() * 400; 
                samAltmanMeshFarBack.userData.blinkInterval = 1000 + Math.random() * 4000; 
                samAltmanMeshFarBack.userData.baseMaterial = material; 
                samAltmanMeshFarBack.userData.flashMaterial = logoFlashMaterial; 
                samAltmanMeshFarBack.material = material; 

                scene.add(samAltmanMeshFarBack);
                draggableObjects.push(samAltmanMeshFarBack);
                cameraAnimationTargets.push(samAltmanMeshFarBack);

                initialAssetConfigs.push({
                    id: samAltmanMeshFarBack.userData.id,
                    type: 'image',
                    url: URL_SAM_ALTMAN,
                    initialPosition: samAltmanGridFarBackInitialPosition.clone(),
                    initialLayer: -240,
                    initialScale: { width: planeWidthFarBack, height: planeHeightFarBack }, 
                    removed: false,
                });
            }
        }
    }

    // Initial call to set the base colors (slightly darker)
    updateFaceMaterialColors();


    window.addEventListener('resize', onWindowResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
    renderer.domElement.addEventListener('click', onClick);

    // Helper function to add a toggle button for an effect
    const addButtonToggle = (parentContainer, label, property, pass) => {
        const button = document.createElement('button');
        button.textContent = label.toUpperCase();
        button.style.cssText = `
            background-color: black;
            color: white;
            padding: 4px;
            margin: 0;
            border: 0.5px solid ${effectControls[property] ? '#4CAF50' : 'white'};
            border-radius: 0;
            cursor: pointer;
            font-family: monospace;
            font-size: 7px;
            outline: none;
            box-sizing: border-box;
        `;
        button.onmouseover = () => {
            if (effectControls[property]) {
                button.style.borderColor = '#66CC66'; // Brighter green for active hover
            } else {
                button.style.borderColor = '#777';
            }
        };
        button.onmouseout = () => {
            if (effectControls[property]) {
                button.style.borderColor = '#4CAF50'; // Green for active
            } else {
                button.style.borderColor = 'white'; // White for inactive
            }
        };

        button.onclick = (event) => {
            // Prevent event from bubbling up to document and triggering other handlers
            event.stopPropagation();

            let targetProperty = property; // Default to the button's own property

            // If HACKER is clicked, toggle the 'og' effect and keep hacker state in sync for UI update
            if (property === 'hacker') {
                effectControls.og = !effectControls.og;
                effectControls.hacker = effectControls.og;
                targetProperty = 'og'; // Process as if 'og' was clicked
            }

            // If this effect is being turned on, turn off conflicting effects
            if (!effectControls[targetProperty]) { // If turning the effect ON (or the underlying 'og' effect for 'hacker')

                // Turn off 'Anon' if any other effect is explicitly turned on
                if (effectControls.anon && targetProperty !== 'anon') {
                    effectControls.anon = false;
                    thresholdPass.enabled = false;
                    bloodPass.enabled = false;
                    glitchPass.enabled = false;
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false;
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false;
                    updateUIButtonState('anon', false);
                }

                // Turn off conflicting visual effects
                if (targetProperty === 'cctvFeed') {
                    if (effectControls.heatmap) { effectControls.heatmap = false; heatmapPass.enabled = false; updateUIButtonState('heatmap', false); }
                    if (effectControls.blood) { effectControls.blood = false; bloodPass.enabled = false; updateUIButtonState('blood', false); } // Turn off blood when CCTV is on
                    if (effectControls.bloodText) { effectControls.bloodText = false; bloodTextMesh.visible = false; updateUIButtonState('bloodText', false); } // Turn off blood text
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; glitchPass.enabled = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); updateUIButtonState('glitch', false); } // Turn off redacted glitch
                } else if (targetProperty === 'heatmap') {
                    if (effectControls.cctvFeed) { effectControls.cctvFeed = false; cctvFeedPass.enabled = false; updateUIButtonState('cctvFeed', false); }
                    if (effectControls.blood) { effectControls.blood = false; bloodPass.enabled = false; updateUIButtonState('blood', false); } // Turn off blood when Heatmap is on
                    if (effectControls.bloodText) { effectControls.bloodText = false; bloodTextMesh.visible = false; updateUIButtonState('bloodText', false); } // Turn off blood text
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; glitchPass.enabled = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); updateUIButtonState('glitch', false); } // Turn off redacted glitch
                } else if (targetProperty === 'blood' || targetProperty === 'bloodText') { // If Blood or Blood Text is turned on
                    if (effectControls.heatmap) { effectControls.heatmap = false; heatmapPass.enabled = false; updateUIButtonState('heatmap', false); }
                    if (effectControls.cctvFeed) { effectControls.cctvFeed = false; cctvFeedPass.enabled = false; updateUIButtonState('cctvFeed', false); }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; glitchPass.enabled = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); updateUIButtonState('glitch', false); } // Turn off redacted glitch
                } else if (targetProperty === 'redactedGlitch') {
                    if (effectControls.redacted) { effectControls.redacted = false; updateUIButtonState('redacted', false); } // Turn off simple redacted
                    if (effectControls.glitch) { effectControls.glitch = false; glitchPass.enabled = false; updateUIButtonState('glitch', false); } // Turn off general glitch
                    if (effectControls.xray) { effectControls.xray = false; xrayPass.enabled = false; updateUIButtonState('xray', false); } // Turn off xray
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.cctvFeed) { effectControls.cctvFeed = false; cctvFeedPass.enabled = false; updateUIButtonState('cctvFeed', false); } // Turn off CCTV
                    if (effectControls.heatmap) { effectControls.heatmap = false; heatmapPass.enabled = false; updateUIButtonState('heatmap', false); } // Turn off Heatmap
                    if (effectControls.blood) { effectControls.blood = false; bloodPass.enabled = false; updateUIButtonState('blood', false); } // Turn off Blood
                    if (effectControls.bloodText) { effectControls.bloodText = false; bloodTextMesh.visible = false; updateUIButtonState('bloodText', false); } // Turn off Blood Text
                    if (effectControls.biometricMarquee) { effectControls.biometricMarquee = false; biometricMarqueeTextMesh.visible = false; updateUIButtonState('biometricMarquee', false); } // Turn off Biometric
                    if (effectControls.marqueeText) { effectControls.marqueeText = false; marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false); } // Turn off Marquee
                    if (effectControls.matrix) { effectControls.matrix = false; matrixPass.enabled = false; updateUIButtonState('matrix', false); } // Turn off Matrix
                    if (effectControls.pixelation) { effectControls.pixelation = false; pixelationPass.enabled = false; updateUIButtonState('pixelation', false); } // Turn off Pixelation
                    if (effectControls.ascii) { effectControls.ascii = false; asciiPass.enabled = false; updateUIButtonState('ascii', false); } // Turn off Greyscale
                } else if (targetProperty === 'redacted') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; glitchPass.enabled = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); updateUIButtonState('glitch', false); } // Turn off redacted glitch
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'glitch') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'xray') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; glitchPass.enabled = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); updateUIButtonState('glitch', false); } // Turn off redacted glitch
                    // If XRAY is turned on, ensure biometric marquee is turned off
                    if (effectControls.biometricMarquee) {
                        effectControls.biometricMarquee = false;
                        biometricMarqueeTextMesh.visible = false;
                        updateUIButtonState('biometricMarquee', false);
                    }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'biometricMarquee') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; glitchPass.enabled = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); updateUIButtonState('glitch', false); } // Turn off redacted glitch
                    // If biometric marquee is turned on, ensure XRAY is turned off
                    if (effectControls.xray) {
                        effectControls.xray = false;
                        xrayPass.enabled = false;
                        marqueeTextMesh.visible = false; // Also hide main marquee if XRAY is off
                        updateUIButtonState('xray', false);
                    }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'threshold') {
                    if (effectControls.shadow) { effectControls.shadow = false; darkPass.enabled = false; updateUIButtonState('shadow', false); } // Updated to effectControls.shadow
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'shadow') {
                    if (effectControls.threshold) { effectControls.threshold = false; thresholdPass.enabled = false; updateUIButtonState('threshold', false); }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                }

                // Turn off all other non-combined visual effects if 'Anon' is being turned ON
                if (targetProperty === 'anon') {
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) && key !== 'anon' && key !== 'redacted' && key !== 'redactedGlitch' && key !== 'threshold' && key !== 'blood' && key !== 'glitch' && key !== 'marqueeText' && key !== 'biometricMarquee' && key !== 'yRotation' && key !== 'cameraAnimation' && key !== 'og' && key !== 'bloodText' && key !== 'hacker' && key !== 'surveillance' && key !== 'greed') { // Added greed
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Ensure redacted and redactedGlitch are off
                    effectControls.redacted = false; updateUIButtonState('redacted', false);
                    effectControls.redactedGlitch = false; glitchPass.enabled = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); updateUIButtonState('glitch', false);

                    // Turn off both marquees and blood text
                    effectControls.marqueeText = false; marqueeTextMesh.visible = false;
                    effectControls.biometricMarquee = false; biometricMarqueeTextMesh.visible = false;
                    effectControls.bloodText = false; bloodTextMesh.visible = false;
                    updateUIButtonState('marqueeText', false);
                    updateUIButtonState('biometricMarquee', false);
                    updateUIButtonState('bloodText', false);

                    // Turn off OG and Hacker and Surveillance and Greed if they're on
                    if (effectControls.og) {
                        effectControls.og = false;
                        asciiPass.enabled = false;
                        heatmapPass.enabled = false;
                        biometricMarqueeTextMesh.visible = false;
                        updateUIButtonState('og', false);
                    }
                    if (effectControls.hacker) {
                        effectControls.hacker = false;
                        updateUIButtonState('hacker', false);
                    }
                    if (effectControls.surveillance) {
                        effectControls.surveillance = false;
                        updateUIButtonState('surveillance', false);
                    }
                    if (effectControls.greed) {
                        effectControls.greed = false;
                        updateUIButtonState('greed', false);
                    }
                }

                // Handle turning on 'OG' effect (now also triggered by 'HACKER')
                if (targetProperty === 'og') {
                    // Turn off all other visual effects, excluding camera/y-rotation/feargreedindex
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) && key !== 'og' && key !== 'hacker' && key !== 'yRotation' && key !== 'cameraAnimation' && key !== 'bloodText' && key !== 'surveillance' && key !== 'greed') { // Added greed
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Specific cleanups for effects that don't have a pass or have special visibility
                    if (marqueeTextMesh) marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false);
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false; updateUIButtonState('redacted', false);
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false; updateUIButtonState('redactedGlitch', false);
                    if (bloodTextMesh) bloodTextMesh.visible = false; updateUIButtonState('bloodText', false);
                    if (biometricMarqueeTextMesh) biometricMarqueeTextMesh.visible = false; updateUIButtonState('biometricMarquee', false); // Ensure biometric is off if OG is turning on
                    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); // Ensure redacted glitch text is off

                    // Turn off surveillance if OG is turned on
                    if (effectControls.surveillance) {
                        effectControls.surveillance = false;
                        updateUIButtonState('surveillance', false);
                    }
                    // Turn off greed if OG is turned on
                    if (effectControls.greed) {
                        effectControls.greed = false;
                        updateUIButtonState('greed', false);
                    }
                }

                // Handle turning on 'SURVEILLANCE' effect
                if (targetProperty === 'surveillance') {
                    // Turn off all other visual effects, excluding camera/y-rotation/feargreedindex
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) &&
                            key !== 'surveillance' &&
                            key !== 'heatmap' &&
                            key !== 'biometricMarquee' &&
                            key !== 'glitch' && // Added glitch to exclusion list for turning off
                            key !== 'yRotation' &&
                            key !== 'cameraAnimation' &&
                            key !== 'greed' // Exclude greed from being turned off by surveillance
                        ) {
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Specific cleanups for effects that don't have a pass or have special visibility
                    if (marqueeTextMesh) marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false);
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false; updateUIButtonState('redacted', false);
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false; updateUIButtonState('redactedGlitch', false);
                    if (bloodTextMesh) bloodTextMesh.visible = false; updateUIButtonState('bloodText', false);
                    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false; // Ensure redacted glitch text is off

                    // Ensure Anon, OG, Hacker are off
                    if (effectControls.anon) {
                        effectControls.anon = false;
                        updateUIButtonState('anon', false);
                    }
                    if (effectControls.og) {
                        effectControls.og = false;
                        updateUIButtonState('og', false);
                    }
                    if (effectControls.hacker) {
                        effectControls.hacker = false;
                        updateUIButtonState('hacker', false);
                    }
                }

                // Handle turning on 'GREED' effect
                if (targetProperty === 'greed') {
                    // Turn off all other visual effects, excluding camera/y-rotation/feargreedindex
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) &&
                            key !== 'greed' &&
                            key !== 'blood' &&
                            key !== 'bloodText' &&
                            key !== 'yRotation' &&
                            key !== 'cameraAnimation'
                        ) {
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Specific cleanups for effects that don't have a pass or have special visibility
                    if (marqueeTextMesh) marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false);
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false; updateUIButtonState('redacted', false);
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false; updateUIButtonState('redactedGlitch', false);
                    if (biometricMarqueeTextMesh) biometricMarqueeTextMesh.visible = false; updateUIButtonState('biometricMarquee', false);
                    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false; // Ensure redacted glitch text is off

                    // Ensure Anon, OG, Hacker, Surveillance, CCTV, Heatmap are off
                    if (effectControls.anon) {
                        effectControls.anon = false;
                        updateUIButtonState('anon', false);
                    }
                    if (effectControls.og) {
                        effectControls.og = false;
                        updateUIButtonState('og', false);
                    }
                    if (effectControls.hacker) {
                        effectControls.hacker = false;
                        updateUIButtonState('hacker', false);
                    }
                    if (effectControls.surveillance) {
                        effectControls.surveillance = false;
                        updateUIButtonState('surveillance', false);
                    }
                    if (effectControls.cctvFeed) {
                        effectControls.cctvFeed = false;
                        updateUIButtonState('cctvFeed', false);
                    }
                    if (effectControls.heatmap) {
                        effectControls.heatmap = false;
                        updateUIButtonState('heatmap', false);
                    }
                }

            } else if (targetProperty === 'shadow') { // If turning SHADOW OFF, also turn off Glitch if it was enabled by SHADOW
                if (effectControls.glitch) { // Check if glitch is currently active
                    // Only turn off glitch if it's not being used by another effect like 'Anon' or 'Redacted Glitch' or 'OG' or 'HACKER' or 'Surveillance' or 'Greed'
                    if (!effectControls.anon && !effectControls.redactedGlitch && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.glitch = false;
                        glitchPass.enabled = false;
                        updateUIButtonState('glitch', false);
                    }
                }
            }

            // Toggle the effect control state if it wasn't already toggled by 'hacker' logic
            if (property !== 'hacker') {
                effectControls[property] = !effectControls[property];
            }

            if (targetProperty === 'shadow') {
                darkPass.enabled = effectControls.shadow;
                // If SHADOW is active, also activate Glitch
                if (effectControls.shadow) {
                    effectControls.glitch = true;
                    glitchPass.enabled = true;
                } else { // If SHADOW is being turned off
                    // Only turn off glitch if it's not being used by another effect like 'Anon' or 'Redacted Glitch' or 'OG' or 'HACKER' or 'Surveillance' or 'Greed'
                    if (!effectControls.anon && !effectControls.redactedGlitch && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.glitch = false;
                        glitchPass.enabled = false;
                    }
                }
                updateUIButtonState('shadow', effectControls.shadow);
                updateUIButtonState('glitch', effectControls.glitch);
            } else if (targetProperty === 'og') {
                asciiPass.enabled = effectControls.og;
                heatmapPass.enabled = effectControls.og;
                biometricMarqueeTextMesh.visible = effectControls.og;
                updateUIButtonState('ascii', effectControls.og);
                updateUIButtonState('heatmap', effectControls.og);
                updateUIButtonState('biometricMarquee', effectControls.og);
                updateUIButtonState('og', effectControls.og);
                updateUIButtonState('hacker', effectControls.og); // Update HACKER button state
            } else if (targetProperty === 'bloodText') {
                // When bloodText is turned on, also ensure blood effect is on
                if (effectControls.bloodText) {
                    effectControls.blood = true;
                    bloodPass.enabled = true;
                    updateUIButtonState('blood', true);
                    // On initial enable, set bloodScrollOffset to ensure the text starts higher
                    if (bloodTextMesh && bloodTextMesh.material.map) {
                        bloodScrollOffset = bloodTextMesh.material.map.image.height; // Start at the bottom of the canvas
                        shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]);
                    }
                }
                bloodTextMesh.visible = effectControls.bloodText;
                updateUIButtonState('bloodText', effectControls.bloodText);
            } else if (targetProperty === 'surveillance') {
                // When SURVEILLANCE is turned on/off, toggle heatmap, biometric marquee, AND glitch
                effectControls.heatmap = effectControls.surveillance;
                heatmapPass.enabled = effectControls.surveillance;
                updateUIButtonState('heatmap', effectControls.surveillance);

                effectControls.biometricMarquee = effectControls.surveillance;
                biometricMarqueeTextMesh.visible = effectControls.surveillance;
                updateUIButtonState('biometricMarquee', effectControls.surveillance);

                effectControls.glitch = effectControls.surveillance; // Add glitch control
                glitchPass.enabled = effectControls.surveillance; // Enable/disable glitch pass
                updateUIButtonState('glitch', effectControls.surveillance); // Update glitch button state

                // Update the button for surveillance itself
                updateUIButtonState('surveillance', effectControls.surveillance);

            } else if (targetProperty === 'greed') {
                // When GREED is turned on/off, toggle blood and bloodText
                effectControls.blood = effectControls.greed;
                bloodPass.enabled = effectControls.greed;
                updateUIButtonState('blood', effectControls.greed);

                effectControls.bloodText = effectControls.greed;
                bloodTextMesh.visible = effectControls.greed;
                updateUIButtonState('bloodText', effectControls.greed);

                // If turning on, ensure text starts from bottom and reshuffle
                if (effectControls.greed) {
                    if (bloodTextMesh && bloodTextMesh.material.map) {
                        bloodScrollOffset = bloodTextMesh.material.map.image.height; // Start at the bottom of the canvas
                        shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]);
                    }
                }

                // Update the button for greed itself
                updateUIButtonState('greed', effectControls.greed);

            } else if (targetProperty === 'redactedGlitch') { // Handle Redacted Glitch effect toggle
                if (rightEyeRedactionRect) rightEyeRedactionRect.visible = effectControls.redactedGlitch;
                if (leftEyeRedactionRect) leftEyeRedactionRect.visible = effectControls.redactedGlitch;
                glitchPass.enabled = effectControls.redactedGlitch; // Re-added glitch pass activation
                effectControls.glitch = effectControls.redactedGlitch; // Sync glitch control state
                redactedGlitchTextMesh.visible = effectControls.redactedGlitch;

                // When redactedGlitch is active, force threshold effect on
                if (effectControls.redactedGlitch) {
                    effectControls.threshold = true;
                    thresholdPass.enabled = true;
                    updateUIButtonState('threshold', true);
                    // Ensure shadow is off if threshold is forced on
                    if (effectControls.shadow) {
                        effectControls.shadow = false;
                        darkPass.enabled = false;
                        updateUIButtonState('shadow', false);
                        // Glitch is already being turned on by redactedGlitch, so no need to turn off if it was from shadow
                    }
                }
                else { // If turning off redactedGlitch
                    // Only turn off threshold and glitch if no other effect is forcing them on
                    if (!effectControls.redacted && !effectControls.anon && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.threshold = false;
                        thresholdPass.enabled = false;
                        updateUIButtonState('threshold', false);
                    }
                    // Only turn off glitch if no other effect is forcing it on
                    if (!effectControls.anon && !effectControls.shadow && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.glitch = false;
                        glitchPass.enabled = false;
                    }
                }
                updateUIButtonState('redactedGlitch', effectControls.redactedGlitch);
                updateUIButtonState('glitch', effectControls.glitch); // Sync glitch button

            } else if (pass) {
                pass.enabled = effectControls[targetProperty];
                updateUIButtonState(targetProperty, effectControls[targetProperty]);
            }

            // Update marquee text visibility based on XRAY only
            const shouldMarqueeBeVisible = effectControls.xray;
            if (effectControls.marqueeText !== shouldMarqueeBeVisible) {
                effectControls.marqueeText = shouldMarqueeBeVisible;
                marqueeTextMesh.visible = shouldMarqueeBeVisible;
            }

            // Toggle biometric marquee visibility (if not controlled by surveillance/OG/HACKER/GREED)
            if (targetProperty === 'biometricMarquee' && !effectControls.surveillance && !effectControls.og && !effectControls.hacker && !effectControls.greed) {
                biometricMarqueeTextMesh.visible = effectControls.biometricMarquee;
            }

            // Handle redacted effect toggle
            if (targetProperty === 'redacted') {
                if (rightEyeRedactionRect) rightEyeRedactionRect.visible = effectControls.redacted;
                if (leftEyeRedactionRect) leftEyeRedactionRect.visible = effectControls.redacted;
                // When redacted is active, force threshold effect on
                if (effectControls.redacted) {
                    effectControls.threshold = true;
                    thresholdPass.enabled = true;
                    updateUIButtonState('threshold', true);
                    // Ensure shadow is off if threshold is forced on
                    if (effectControls.shadow) {
                        effectControls.shadow = false;
                        darkPass.enabled = false;
                        updateUIButtonState('shadow', false);
                        // Also turn off glitch if it was enabled by shadow and not by other effects
                        if (!effectControls.anon && !effectControls.redactedGlitch && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                            effectControls.glitch = false;
                            glitchPass.enabled = false;
                            updateUIButtonState('glitch', false);
                        }
                    }
                } else {
                    if (!effectControls.redactedGlitch && !effectControls.anon && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.threshold = false;
                        thresholdPass.enabled = false;
                        updateUIButtonState('threshold', false);
                    }
                }
            }

            // Handle Anon effect toggle
            if (targetProperty === 'anon') {
                if (effectControls.anon) {
                    thresholdPass.enabled = true;
                    bloodPass.enabled = true;
                    glitchPass.enabled = true;
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = true;
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = true;

                    // Ensure shadow is off if threshold is forced on by Anon
                    if (effectControls.shadow) {
                        effectControls.shadow = false;
                        darkPass.enabled = false;
                        updateUIButtonState('shadow', false);
                        // Glitch is already being turned on by Anon, so no need to turn off if it was from shadow
                    }
                }
                else {
                    thresholdPass.enabled = false;
                    bloodPass.enabled = false;
                    glitchPass.enabled = false;
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false;
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false;
                }
                // Update threshold, blood, glitch buttons to reflect Anon's state
                updateUIButtonState('threshold', effectControls.anon);
                updateUIButtonState('blood', effectControls.anon);
                updateUIButtonState('glitch', effectControls.anon);
            }

            // Handle camera animation toggle
            if (property === 'cameraAnimation') {
                cameraAnimationActive = effectControls.cameraAnimation;
                controls.enabled = !cameraAnimationActive;
                if (cameraAnimationActive) {
                    // Ensure Y-rotation is off if camera animation is activated
                    if (effectControls.yRotation) {
                        effectControls.yRotation = false;
                        updateUIButtonState('yRotation', false);
                    }
                    // Capture current camera state as the *initial* global start point for the loop
                    initialGlobalCameraPos.copy(camera.position);
                    initialGlobalCameraLookAt.copy(controls.target);
                    // Set loop start to global start for the first exploration
                    cameraPreviousPos.copy(initialGlobalCameraPos);
                    cameraPreviousLookAt.copy(initialGlobalCameraLookAt);
                    assetsVisitedCount = 0;
                    startCameraAnimation(performance.now());
                } else {
                    // Reset camera to default or current OrbitControls view when animation stops
                    camera.position.copy(initialGlobalCameraPos);
                    controls.target.copy(initialGlobalCameraLookAt);
                    camera.lookAt(controls.target);
                    cameraAnimationState = 'idle';
                    assetsVisitedCount = 0;
                    // Re-enable controls if Y-rotation is not active
                    if (!effectControls.yRotation) {
                        controls.enabled = true;
                    }
                }
                yRotationStartTime = 0; // Reset Y-rotation auto-start timer if camera anim is manually toggled
            }

            // Handle Y-axis rotation toggle
            if (property === 'yRotation') {
                if (effectControls.yRotation) {
                    // When Y-rotation starts, disable OrbitControls and camera animation
                    controls.enabled = false;
                    cameraAnimationActive = false;
                    updateUIButtonState('cameraAnimation', false);
                    // Store initial camera position for the bounce animation
                    yBounceInitialCameraX = camera.position.x;
                    yBounceInitialCameraY = camera.position.y;
                    yBounceInitialCameraZ = camera.position.z;
                    yRotationStartTime = performance.now(); // Record start time for Y-rotation
                } else {
                    // When Y-rotation stops, re-enable OrbitControls if no other camera animation is active
                    if (!cameraAnimationActive) {
                        controls.enabled = true;
                    }
                    // Optionally reset camera to its original position before bounce
                    camera.position.set(yBounceInitialCameraX, yBounceInitialCameraY, yBounceInitialCameraZ);
                    controls.target.set(0, 0, (1 - 1) * depthStep);
                    camera.lookAt(controls.target);
                    yRotationStartTime = 0; // Reset Y-rotation auto-start timer if Y-rotation is manually toggled off
                }
                lastActivityTime = performance.now();
            }
            
            // --- Crucial: Update face material colors after any effect state change ---
            updateFaceMaterialColors();
        };
        button.setAttribute('data-effect', property);
        parentContainer.appendChild(button);
    };

    // Helper to get pass by name
    const getPassByName = (name) => {
        switch (name) {
            case 'greyscale': return greyscalePass;
            case 'threshold': return thresholdPass;
            case 'shadow': return darkPass;
            case 'pixelation': return pixelationPass;
            case 'glitch': return glitchPass;
            case 'matrix': return matrixPass;
            case 'ascii': return asciiPass;
            case 'xray': return xrayPass;
            case 'heatmap': return heatmapPass;
            case 'blood': return bloodPass;
            case 'cctvFeed': return cctvFeedPass;
            default: return null;
        }
    };

    // Define buttons to be added to both UIs
    const buttonsConfig = [
        { label: '3D', property: 'yRotation', pass: null },
        { label: 'FLY', property: 'cameraAnimation', pass: null },
        { label: 'SHADOW', property: 'shadow', pass: darkPass },
        { label: 'ASCII', property: 'ascii', pass: asciiPass },
        { label: 'HEATMAP', property: 'heatmap', pass: heatmapPass },
        { label: 'BLOOD', property: 'blood', pass: bloodPass },
        { label: 'REDACTED', property: 'redactedGlitch', pass: null },
        { label: 'ANON', property: 'anon', pass: null },
        { label: 'BIOMETRIC', property: 'biometricMarquee', pass: null },
        { label: 'OG', property: 'og', pass: null },
        { label: 'BLOOD TEXT', property: 'bloodText', pass: null },
        { label: 'DATA SCRAPER', property: 'hacker', pass: null },
        { label: 'BIO-CODER', property: 'surveillance', pass: null },
        { label: 'HIDDEN HAND', property: 'greed', pass: null },
        { label: 'Greyscale', property: 'greyscale', pass: greyscalePass },
        { label: 'Threshold', property: 'threshold', pass: thresholdPass },
        { label: 'Pixelation', property: 'pixelation', pass: pixelationPass },
        { label: 'Glitch', property: 'glitch', pass: glitchPass },
        { label: 'Matrix', property: 'matrix', pass: matrixPass },
        { label: 'XRAY', property: 'xray', pass: xrayPass },
        { label: 'CCTV FEED', property: 'cctvFeed', pass: cctvFeedPass },

    ];

    // Create and append the left UI container
    leftUiContainer = document.createElement('div'); // Assign to global variable
    leftUiContainer.id = 'left-ui-container';
    leftUiContainer.style.position = 'absolute';
    leftUiContainer.style.top = '-190px'; // Start mostly hidden, revealing only the arrow
    leftUiContainer.style.left = '10px';
    leftUiContainer.style.backgroundColor = 'rgba(0, 0, 0, 0)';
    leftUiContainer.style.color = 'white';
    leftUiContainer.style.padding = '10px'; /* Reduced padding for more compact layout */
    leftUiContainer.style.borderRadius = '5px';
    leftUiContainer.style.fontFamily = 'monospace';
    leftUiContainer.style.zIndex = '100';
    leftUiContainer.style.display = 'flex';
    leftUiContainer.style.flexDirection = 'column'; /* Changed to column for vertical layout */
    leftUiContainer.style.flexWrap = 'nowrap'; /* Not needed for single column */
    leftUiContainer.style.gap = '5px'; /* Adjusted gap for vertical layout */
    leftUiContainer.style.transition = 'top 0.5s ease-in-out'; // Smooth transition for top property
    document.body.appendChild(leftUiContainer);

    // Create and append the right UI container
    const rightUiContainer = document.createElement('div');
    rightUiContainer.id = 'right-ui-container';
    rightUiContainer.style.position = 'absolute';
    rightUiContainer.style.top = '10px';
    rightUiContainer.style.right = '10px';
    rightUiContainer.style.backgroundColor = 'rgba(0, 0, 0, 0)';
    rightUiContainer.style.color = 'white';
    rightUiContainer.style.padding = '10px';
    rightUiContainer.style.borderRadius = '5px';
    rightUiContainer.style.fontFamily = 'monospace';
    rightUiContainer.style.zIndex = '100';
    rightUiContainer.style.display = 'none'; // Hide the right UI container
    rightUiContainer.style.flexDirection = 'column';
    rightUiContainer.style.gap = '5px';
    document.body.appendChild(rightUiContainer);

    // Define the desired order of buttons for the left UI
    const leftUiOrder = [
        'yRotation', // 3D
        'cameraAnimation', // FLY
        'surveillance', // NEW SURVEILLANCE BUTTON
        'greed', // NEW GREED BUTTON (now ULTERIOR MOVTIVES)
        'hacker', // HACKER moved to position 5
        'shadow',
        'redactedGlitch'
    ];

    // Map property names to their full config objects for easy lookup
    const buttonConfigMap = new Map(buttonsConfig.map(config => [config.property, config]));

    // Add buttons to the left UI container in the specified order
    leftUiOrder.forEach(propertyName => {
        const config = buttonConfigMap.get(propertyName);
        if (config) {
            addButtonToggle(leftUiContainer, config.label, config.property, config.pass);
        }
    });

    // Add all buttons to the right UI container
    buttonsConfig.forEach(config => {
        if (!leftUiOrder.includes(config.property)) { // Only add if not already in left UI
            addButtonToggle(rightUiContainer, config.label, config.property, config.pass);
        }
    });

    // Add the RESET button to both UI containers
    const createResetButton = () => {
        const button = document.createElement('button');
        button.textContent = 'RESET';
        button.style.cssText = `
            background-color: black; /* Changed from #CC0000 to black */
            color: white;
            padding: 4px;
            margin-top: 10px;
            border: 0.5px solid rgba(0, 0, 0, 0.8);
            border-radius: 0;
            cursor: pointer;
            font-family: monospace;
            font-size: 7px;
            outline: none;
            white-space: nowrap;
            box-sizing: border-box;
        `;
        button.onmouseover = () => { button.style.borderColor = 'rgba(0, 0, 0, 1.0)'; };
        button.onmouseout = () => { button.style.borderColor = 'rgba(0, 0, 0, 0.8)'; };
        button.onclick = (event) => { event.stopPropagation(); resetPiecesToOriginalPositions(); };
        return button;
    };
    leftUiContainer.appendChild(createResetButton());
    rightUiContainer.appendChild(createResetButton());

    // Create and append the TRASH button to the left UI container
    const createTrashButton = () => {
        const button = document.createElement('button');
        button.id = 'trash-button'; // Unique ID for easy targeting
        button.innerHTML = 'TRASH'; // Text with trashcan icon
        button.style.cssText = `
            background-color: black; /* Changed from #CC0000 to black */
            color: white;
            padding: 4px;
            margin-top: 10px;
            border: none;
            border-radius: 0;
            cursor: pointer;
            font-family: monospace;
            font-size: 7px;
            outline: none;
            white-space: nowrap;
            box-sizing: border-box;
        `;
        button.onmouseover = () => { }; /* Removed border change on hover */
        button.onmouseout = () => { }; /* Removed border change on mouseout */
        // The actual removal logic will be in onPointerUp, triggered by dropping onto this button
        return button;
    };
    trashButtonElement = createTrashButton(); // Store reference to the button element
    leftUiContainer.appendChild(trashButtonElement);

    // Create and append the EXPORT button below TRASH
    const createExportButton = () => {
        const button = document.createElement('button');
        button.id = 'export-toggle';
        button.innerHTML = 'RCS';
        button.style.cssText = `
            display: none !important;
        `;
        return button;
    };
    exportButtonElement = createExportButton();
    exportButtonElement.style.display = 'none';
    leftUiContainer.appendChild(exportButtonElement);

    // Add the thin black rectangle with a down-facing arrow below the TRASH button
    arrowContainer = document.createElement('div'); // Assign to global variable
    arrowContainer.id = 'arrow-container'; // Add ID for better targeting
    arrowContainer.style.cssText = `
        position: absolute; /* Position relative to the viewport */
        top: 0px; /* Initially at the top, peeking out */
        left: 20px;
        background-color: black;
        width: 60px; /* Fixed width for the arrow tab */
        height: 15px; /* Height of the arrow tab */
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        z-index: 101; /* Higher z-index than leftUiContainer to be clickable */
        border-bottom-left-radius: 5px; /* Rounded corners for the tab */
        border-bottom-right-radius: 5px;
        transition: top 0.5s ease-in-out; /* Smooth transition for top property */
        box-sizing: border-box; /* Include padding and border in the element's total width and height */
    `;
    const arrowSpan = document.createElement('span');
    arrowSpan.style.cssText = `
        color: white;
        font-size: 10px; /* Larger arrow */
    `;
    arrowSpan.innerHTML = '&#x25BC;'; // Down-facing triangle
    arrowContainer.appendChild(arrowSpan);
    document.body.appendChild(arrowContainer); // Append to body, not leftUiContainer

    // Add click listener for the arrow container to toggle left UI visibility
    arrowContainer.onclick = (event) => {
        event.stopPropagation(); // Prevent clicks from interacting with 3D scene
        if (leftUiContainer.style.top === '10px') {
            leftUiContainer.style.top = '-190px'; // Hide it, revealing only the arrow
            trashButtonElement.style.display = 'none'; // Hide TRASH button
            exportButtonElement.style.display = 'none'; // Hide EXPORT button
            arrowContainer.style.top = '0px'; // Keep arrow at the top
            arrowSpan.innerHTML = '&#x25BC;'; // Change to down arrow
        } else {
            leftUiContainer.style.top = '10px'; // Show it
            trashButtonElement.style.display = 'block'; // Show TRASH button
            arrowContainer.style.top = `${leftUiContainer.offsetHeight + 10}px`; // Move arrow below the UI
            arrowSpan.innerHTML = '&#x25B2'; // Change to up arrow
        }
    };

    // Initial state setup for TRASH button and arrowContainer
    // When the page loads, the left UI is hidden, so the trash button should be hidden.
    trashButtonElement.style.display = 'none';

    window.addEventListener('resize', onWindowResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
    renderer.domElement.addEventListener('click', onClick);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    if (composer) {
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    if (pixelationPass) {
        pixelationPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    }
    if (asciiPass) {
        asciiPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    }
    if (cctvFeedPass) {
        cctvFeedPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    }

    // Adjust arrow container position on resize if UI is open
    if (leftUiContainer.style.top === '10px') {
        arrowContainer.style.top = `${leftUiContainer.offsetHeight + 10}px`;
    }

    lastActivityTime = performance.now();
    stopCameraAnimationAndReset();
}

function onPointerDown(event) {
    lastActivityTime = performance.now();
    // stopCameraAnimationAndReset(); // Removed: Only stop FLY camera on explicit click
    isDragging = false;
    pointerDownPosition.set(event.clientX, event.clientY);

    // Check if the click is on a UI element
    if (event.target.closest('#left-ui-container') || event.target.closest('#right-ui-container') || event.target.closest('#arrow-container')) {
        selectedObject = null;
        controls.enabled = true;
        return;
    }

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(draggableObjects, true); // Intersect with all descendants

    // Filter intersects to only consider those with alpha > 0.1
    for (const intersect of intersects) {
        const object = intersect.object;
        const material = object.material;

        // Ensure the material has a map property before trying to access its alpha
        if (material && material.map && material.transparent) {
            const uv = intersect.uv;
            const alpha = getAlphaAtUV(material.map, uv);

            if (alpha > 0.1) { // Alpha threshold for drag detection
                selectedObject = object;
                controls.enabled = false;
                initialObjectZ = selectedObject.position.z;
                offset.copy(intersect.point).sub(selectedObject.position);
                break; // Found a draggable opaque part, stop searching
            }
        } else if (material instanceof THREE.ShaderMaterial && material.alphaTest !== undefined && material.alphaTest > 0) {
            // For ShaderMaterial with alphaTest, treat as always opaque if intersect occurs
            selectedObject = object;
            controls.enabled = false;
            initialObjectZ = selectedObject.position.z;
            offset.copy(intersect.point).sub(selectedObject.position);
            break; // Found a draggable opaque part, stop searching
        } else if (material && !material.transparent) {
            // For opaque materials, any intersect means it's draggable
            selectedObject = object;
            controls.enabled = false;
            initialObjectZ = selectedObject.position.z;
            offset.copy(intersect.point).sub(selectedObject.position);
            break; // Found a draggable opaque part, stop searching
        }
    }
}

function onPointerMove(event) {
    lastActivityTime = performance.now();
    // stopCameraAnimationAndReset(); // Removed: Only stop FLY camera on explicit click
    if (selectedObject) {
        // Check if the pointer has moved beyond the drag threshold
        const currentPointerPosition = new THREE.Vector2(event.clientX, event.clientY);
        if (currentPointerPosition.distanceTo(pointerDownPosition) > DRAG_THRESHOLD) {
            isDragging = true;
        }

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // Create a plane that is parallel to the camera's view plane
        // and passes through the object's initial Z-position.
        const plane = new THREE.Plane();
        plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), new THREE.Vector3(0, 0, initialObjectZ));

        const intersection = new THREE.Vector3();
        if (raycaster.ray.intersectPlane(plane, intersection)) {
            // Update X and Y, but keep the original Z-position
            selectedObject.position.x = intersection.x - offset.x;
            selectedObject.position.y = intersection.y - offset.y;
            selectedObject.position.z = initialObjectZ;

            // Update redaction rectangle positions if the selected object is an eye
            if (selectedObject === rightEyeMesh) {
                if (rightEyeRedactionRect) {
                    rightEyeRedactionRect.position.x = selectedObject.position.x;
                    rightEyeRedactionRect.position.y = selectedObject.position.y;
                }
            } else if (selectedObject === leftEyeMesh) {
                if (leftEyeRedactionRect) {
                    leftEyeRedactionRect.position.x = selectedObject.position.x;
                    leftEyeRedactionRect.position.y = selectedObject.position.y;
                }
            }
        }
    }
}

function onPointerUp(event) {
    lastActivityTime = performance.now();
    // stopCameraAnimationAndReset(); // Removed: Only stop FLY camera on explicit click

    if (isDragging && selectedObject) {
        // Check if the pointer was released over the TRASH button
        if (trashButtonElement) {
            const rect = trashButtonElement.getBoundingClientRect();

            // Define a larger target area for the trash button
            const expandedRect = {
                left: rect.left - 20, // 20 pixels extra padding on left
                right: rect.right + 20, // 20 pixels extra padding on right
                top: rect.top - 20, // 20 pixels extra padding on top
                bottom: rect.bottom + 20 // 20 pixels extra padding on bottom
            };

            if (event.clientX >= expandedRect.left && event.clientX <= expandedRect.right &&
                event.clientY >= expandedRect.top && event.clientY <= expandedRect.bottom) {

                // Mark the object as removed in the initialAssetConfigs for later reloading
                const configIndex = initialAssetConfigs.findIndex(config => config.id === selectedObject.userData.id);
                if (configIndex !== -1) {
                    initialAssetConfigs[configIndex].removed = true;
                }

                // Object was dropped onto the trash button, remove it
                scene.remove(selectedObject);
                // Remove from draggableObjects array
                draggableObjects = draggableObjects.filter(obj => obj !== selectedObject);
                // Remove from cameraAnimationTargets array
                cameraAnimationTargets = cameraAnimationTargets.filter(obj => obj !== selectedObject);

                // Dispose of geometry and material to free up memory
                if (selectedObject.geometry) selectedObject.geometry.dispose();
                if (selectedObject.material) {
                    if (Array.isArray(selectedObject.material)) {
                        object.material.forEach(m => m.dispose());
                    } else {
                        selectedObject.material.dispose();
                    }
                }

                // Special handling for specific removed objects (set global refs to null)
                if (selectedObject.userData.id === 'rightEye') {
                    if (rightEyeRedactionRect) { scene.remove(rightEyeRedactionRect); rightEyeRedactionRect.geometry.dispose(); rightEyeRedactionRect.material.dispose(); }
                    rightEyeMesh = null;
                    rightEyeRedactionRect = null;
                }
                if (selectedObject.userData.id === 'leftEye') {
                    if (leftEyeRedactionRect) { scene.remove(leftEyeRedactionRect); leftEyeRedactionRect.geometry.dispose(); leftEyeRedactionRect.material.dispose(); }
                    leftEyeMesh = null;
                    leftEyeRedactionRect = null;
                }
                console.log("Object removed:", selectedObject.name || selectedObject.uuid);
            }
        }
    }

    selectedObject = null;
    // Re-enable controls only if camera animation AND yRotation are not active
    if (!cameraAnimationActive && !effectControls.yRotation) {
        controls.enabled = true;
    }
    // isDragging is reset by onPointerDown for the next interaction
}

function onClick(event) {
    lastActivityTime = performance.now();
    // Use performance.now() to get current time for button interactions
    const currentTime = performance.now();
    // stopCameraAnimationAndReset(); // Moved: Only stop FLY camera on explicit click if not dragging and not on UI
    // Only process click if no dragging occurred and not clicking on UI
    if (isDragging || event.target.closest('#left-ui-container') || event.target.closest('#right-ui-container') || event.target.closest('#arrow-container')) {
        return;
    }

    stopCameraAnimationAndReset(); // Only stop FLY camera on explicit click if not dragging and not on UI

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(draggableObjects, true); // Intersect with all descendants

    // Filter intersects to only consider those with alpha > 0.1
    let clickedObject = null;
    for (const intersect of intersects) {
        const object = intersect.object;
        const material = object.material;

        // Special handling for ShaderMaterial with alphaTest, as getAlphaAtUV is for MeshBasicMaterial
        if (material instanceof THREE.ShaderMaterial && material.alphaTest !== undefined && material.alphaTest > 0) {
            clickedObject = object;
            break;
        } else if (material && material.map && material.transparent) {
            const uv = intersect.uv;
            const alpha = getAlphaAtUV(material.map, uv);

            if (alpha > 0.1) { // Alpha threshold for click detection
                clickedObject = object;
                break; // Found a clickable opaque part, stop searching
            }
        }
        else if (material && !material.transparent) {
            // For opaque materials, any intersect means it's clickable
            clickedObject = object;
            break; // Found a clickable opaque part, stop searching
        }
    }

    if (clickedObject) {

        // Skip depth cycling for non-draggable elements or those with special handling
        if (clickedObject === backgroundMesh || clickedObject === rightEyeRedactionRect || clickedObject === leftEyeRedactionRect || clickedObject === marqueeTextMesh || clickedObject === biometricMarqueeTextMesh || clickedObject === bloodTextMesh || clickedObject === redactedGlitchTextMesh) { // Added redactedGlitchTextMesh
            return;
        }

        // Cycle through depth levels
        let currentLayer = clickedObject.userData.currentLayer || 1;
        currentLayer--; // Move backward one level
        if (currentLayer < 1) { // If it goes below 1
            currentLayer = totalDepthLayers; // Wrap around to the highest layer
        }
        clickedObject.userData.currentLayer = currentLayer;
        clickedObject.position.z = (currentLayer - 1) * depthStep;

        // Update redaction rectangle Z position if the clicked object is an eye
        if (clickedObject === rightEyeMesh) {
            if (rightEyeRedactionRect) {
                rightEyeRedactionRect.position.z = clickedObject.position.z + (1.5 * depthStep);
            }
        }
        else if (clickedObject === leftEyeMesh) {
            if (leftEyeRedactionRect) {
                leftEyeRedactionRect.position.z = clickedObject.position.z + (1.5 * depthStep);
            }
        }

        console.log(`Object moved to layer: ${currentLayer}, Z-position: ${clickedObject.position.z}`);
    }
}

// Ease-in-out function
function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function startCameraAnimation(currentTime) {
    if (!cameraAnimationActive || cameraAnimationTargets.length === 0) return;

    // Store current camera state as the start for the next animation segment
    cameraPreviousPos.copy(camera.position);
    cameraPreviousLookAt.copy(controls.target);
    cameraAnimationStartTime = currentTime;

    let duration = 0;
    if (cameraAnimationState === 'exploring') {
        duration = cameraExplorationDuration;
    }
    else if (cameraAnimationState === 'returningToGlobalStart') {
        duration = cameraReturnDuration;
    }

    // Filter out 'samAltmanGrid' images from potential targets
    const validTargets = cameraAnimationTargets.filter(obj => !obj.userData.id.startsWith('samAltmanGrid'));

    if (validTargets.length === 0) {
        console.warn("No valid camera animation targets found (excluding 'samAltmanGrid' images).");
        cameraAnimationActive = false;
        effectControls.cameraAnimation = false;
        updateUIButtonState('cameraAnimation', false);
        controls.enabled = true;
        return;
    }

    if (cameraAnimationState === 'returningToGlobalStart' || assetsVisitedCount >= ASSETS_PER_GLOBAL_RETURN) {
        cameraAnimationState = 'exploring';
        assetsVisitedCount = 0;

        // Pick a random target for the next exploration from validTargets
        let newTarget;
        do {
            newTarget = validTargets[Math.floor(Math.random() * validTargets.length)];
        } while (newTarget === cameraTargetObject && validTargets.length > 1);
        cameraTargetObject = newTarget;

        // Calculate end position and lookAt based on the target object
        const targetPos = cameraTargetObject.position;
        const targetBounds = new THREE.Box3().setFromObject(cameraTargetObject);
        const center = targetBounds.getCenter(new THREE.Vector3());
        const size = targetBounds.getSize(new THREE.Vector3());

        const fovRad = THREE.MathUtils.degToRad(camera.fov);
        const baseDistance = Math.max(size.x, size.y) / (2 * Math.tan(fovRad / 2));

        const minZOffset = baseDistance * 0.8;
        const maxZOffset = baseDistance * 1.5;
        const randomZOffset = minZOffset + (Math.random() * (maxZOffset - minZOffset));

        const lateralOffsetRange = baseDistance * 0.5;
        const randomOffsetX = (Math.random() - 0.5) * lateralOffsetRange;
        const randomOffsetY = (Math.random() - 0.5) * lateralOffsetRange;

        cameraCurrentTargetPos.set(
            center.x + randomOffsetX,
            center.y + randomOffsetY,
            targetPos.z + randomZOffset
        );

        cameraCurrentTargetLookAt.copy(center);

        cameraCurrentTargetPos.z = THREE.MathUtils.clamp(cameraCurrentTargetPos.z, -5, 15);

    } else { // Continue exploring
        cameraAnimationState = 'exploring';
        assetsVisitedCount++;

        // Pick a random target, ensuring it's not the same as the previous one if possible
        let newTarget;
        do {
            newTarget = validTargets[Math.floor(Math.random() * validTargets.length)];
        } while (newTarget === cameraTargetObject && validTargets.length > 1);
        cameraTargetObject = newTarget;

        // Calculate end position and lookAt based on the target object
        const targetPos = cameraTargetObject.position;
        const targetBounds = new THREE.Box3().setFromObject(cameraTargetObject);
        const center = targetBounds.getCenter(new THREE.Vector3());
        const size = targetBounds.getSize(new THREE.Vector3());

        // Determine a suitable base distance to frame the object based on its size and camera FOV
        const fovRad = THREE.MathUtils.degToRad(camera.fov);
        const baseDistance = Math.max(size.x, size.y) / (2 * Math.tan(fovRad / 2));

        // Introduce randomness to the Z-distance from the target object
        const minZOffset = baseDistance * 0.8;
        const maxZOffset = baseDistance * 1.5;
        const randomZOffset = minZOffset + (Math.random() * (maxZOffset - minZOffset));

        // Set a random offset around the target object for camera position in X and Y
        const lateralOffsetRange = baseDistance * 0.5;
        const randomOffsetX = (Math.random() - 0.5) * lateralOffsetRange;
        const randomOffsetY = (Math.random() - 0.5) * lateralOffsetRange;

        cameraCurrentTargetPos.set(
            center.x + randomOffsetX,
            center.y + randomOffsetY,
            targetPos.z + randomZOffset
        );

        cameraCurrentTargetLookAt.copy(center);

        // Clamp cameraCurrentTargetPos.z to be within reasonable bounds for the scene
        cameraCurrentTargetPos.z = THREE.MathUtils.clamp(cameraCurrentTargetPos.z, -5, 15);
    }
}

function updateCameraAnimation(currentTime) {
    if (cameraAnimationState === 'idle' || !cameraAnimationActive) return;

    const elapsed = currentTime - cameraAnimationStartTime;

    let duration = 0;
    if (cameraAnimationState === 'exploring') {
        duration = cameraExplorationDuration;
    }
    else if (cameraAnimationState === 'returningToGlobalStart') {
        duration = cameraReturnDuration;
    }

    let t = Math.min(1, elapsed / duration);
    t = easeInOutCubic(t);

    camera.position.lerpVectors(cameraPreviousPos, cameraCurrentTargetPos, t);
    controls.target.lerpVectors(cameraPreviousLookAt, cameraCurrentTargetLookAt, t);

    if (elapsed >= duration) {
        // If returning to global start, then after completion, start a new exploration cycle
        if (cameraAnimationState === 'returningToGlobalStart') {
            cameraAnimationState = 'exploring';
            assetsVisitedCount = 0;
        }
        startCameraAnimation(currentTime);
    }
    camera.lookAt(controls.target);
}

function animate(currentTime) {
    requestAnimationFrame(animate);

    // Apply Y-rotation if explicitly enabled
    if (effectControls.yRotation) {
        // Ensure camera animation is turned off if Y-rotation is active
        if (cameraAnimationActive) {
            cameraAnimationActive = false;
            updateUIButtonState('cameraAnimation', false);
        }
        controls.enabled = false;
        const convergencePoint = new THREE.Vector3(0, 0, (1 - 1) * depthStep);
        camera.position.x = yBounceInitialCameraX + yBounceRangeX * Math.sin(currentTime * yBounceSpeed);
        camera.position.y = yBounceInitialCameraY;
        camera.position.z = yBounceInitialCameraZ;
        camera.lookAt(convergencePoint);
    }

    // Apply Camera Animation if explicitly enabled
    if (cameraAnimationActive) {
        // Ensure Y-rotation is turned off if camera animation is active
        if (effectControls.yRotation) {
            effectControls.yRotation = false;
            updateUIButtonState('yRotation', false);
        }
        controls.enabled = false;
        updateCameraAnimation(currentTime);
    } else if (!effectControls.yRotation) {
        controls.update();
    }

    // Update marquee text scrolling
    if (effectControls.xray) { // Marquee text is now only tied to XRAY effect
        marqueeScrollOffset -= MARQUEE_SCROLL_SPEED;
        // Reset offset when one full set of lines has scrolled off
        if (marqueeScrollOffset <= -MARQUEE_LINE_HEIGHT * MARQUEE_TOTAL_LINES) {
            marqueeScrollOffset = 0;
        }
        updateMarqueeTexture();
    }

    // Update biometric marquee text scrolling
    if (effectControls.biometricMarquee || effectControls.og || effectControls.hacker || effectControls.surveillance || effectControls.greed) { // Update if either biometric or OG or HACKER or SURVEILLANCE or GREED is active
        biometricMarqueeScrollOffset -= BIOMETRIC_MARQUEE_SCROLL_SPEED;
        if (biometricMarqueeScrollOffset <= -BIOMETRIC_MARQUEE_LINE_HEIGHT * BIOMETRIC_MARQUEE_TOTAL_LINES) {
            biometricMarqueeScrollOffset = 0;
        }
        updateBiometricMarqueeTexture(currentTime);
    }

    // Update blood text scrolling
    if (effectControls.bloodText) {
        bloodScrollOffset -= BLOOD_TEXT_SCROLL_SPEED;
        const singleSetHeight = BLOOD_TEXT_LINE_HEIGHT * BLOOD_TEXT_TOTAL_LINES;

        // When the first set of phrases has scrolled completely off the top of the canvas,
        // wrap it around to the bottom, effectively creating a continuous loop.
        if (bloodScrollOffset <= -singleSetHeight) {
            bloodScrollOffset += singleSetHeight * 3; // Move it to the bottom of the second set
            shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]); // Reshuffle phrases on loop
        }

        updateBloodTextTexture();
    }

    // Update redacted glitch text scrolling
    if (effectControls.redactedGlitch) {
        redactedGlitchScrollOffset -= REDACTED_GLITCH_SCROLL_SPEED;
        const singleSetHeight = REDACTED_GLITCH_LINE_HEIGHT * REDACTED_GLITCH_TOTAL_LINES;
        if (redactedGlitchScrollOffset <= -singleSetHeight) {
            redactedGlitchScrollOffset = 0;
            // Re-initialize redaction patterns when the text loops
            initializeRedactedGlitchPhraseData();
        }
        updateRedactedGlitchTexture();
    }

    // Update Sam Altman grid image blinking - FIXED LOGIC (Swapping materials for guaranteed visual inversion)
    draggableObjects.forEach(object => {
        if (object.userData.id && (object.userData.id.startsWith('samAltmanGrid') || object.userData.id.startsWith('samAltmanGridBack') || object.userData.id.startsWith('samAltmanGridFarBack'))) {
            const now = performance.now();
            
            // Only proceed if the next state change time has been reached
            if (now >= object.userData.nextBlinkTime) {
                if (object.userData.isBlinking) {
                    // Current state is BLINKING (Flash Material): Switch to OFF (Base Material)
                    object.material = object.userData.baseMaterial;
                    object.userData.isBlinking = false;
                    // Schedule next change (START of blink) after a random interval
                    object.userData.nextBlinkTime = now + object.userData.blinkInterval; 
                } else {
                    // Current state is OFF (Base Material): Switch to BLINKING (Flash Material)
                    object.material = object.userData.flashMaterial;
                    object.userData.isBlinking = true;
                    // Schedule next change (END of blink) after a random duration
                    object.userData.nextBlinkTime = now + object.userData.blinkDuration;
                }
            }
        }
    });

    composer.render();
}

init();
animate();

// Expose for dae hooks
setTimeout(function () {
    window.animate = typeof animate == "function" ? animate : () => { };
    window.camera = typeof camera != "undefined" ? camera : undefined;
    window.renderer = typeof renderer != "undefined" ? renderer : undefined;
    window.scene = typeof scene != "undefined" ? scene : undefined;
    window.composer = typeof composer != "undefined" ? composer : undefined;
}, 1000)

    // Expose for dae hooks
    setTimeout(function() {
      window.animate = typeof animate == "function" ? animate : () => {};
      window.camera = typeof camera != "undefined" ? camera : undefined;
      window.renderer = typeof renderer != "undefined" ? renderer : undefined;
      window.scene = typeof scene != "undefined" ? scene : undefined;
      window.composer = typeof composer != "undefined" ? composer : undefined;
    }, 1000)
  </script>

  <!-- ─── EXPORT PANEL HTML ─── -->
  <button id="submit-overlord-btn">SUBMIT</button>

  <div id="export-panel">
    <div class="panel-title">EXPORT</div>

    <div class="export-row" style="display:none;">
      <label>Format</label>
      <select id="export-format">
        <option value="png">PNG</option>
      </select>
    </div>

    <!-- Video duration row (hidden — PNG only) -->
    <div class="export-row" id="duration-row" style="display:none;">
      <label>Duration (sec)</label>
      <input type="number" id="export-duration" value="5" min="1" max="60" step="1">
    </div>

    <button class="export-btn" id="export-start-btn">EXPORT</button>
    <div class="status-line" id="export-status"></div>
  </div>

  <!-- ─── POST TO X MODAL ─── -->
  <div id="post-modal">
    <div id="post-modal-content">
      <h2>Share your overlord</h2>
      <p style="margin: 0 0 20px 0; font-size: 12px; color: #aaa;">Attach your downloaded file before posting</p>
      <button id="post-modal-btn">POST TO X</button>

      <div style="margin: 20px 0; color: #666; font-size: 11px; text-align: center;">
        ── OR ──
      </div>

      <div style="margin: 0 0 15px 0;">
        <label style="display: block; font-family: monospace; font-size: 10px; color: #aaa; margin-bottom: 6px; letter-spacing: 1px;">X ACCOUNT</label>
        <input id="x-account-input" type="text" placeholder="@yourhandle" style="
          width: 100%;
          box-sizing: border-box;
          background: #111;
          border: 1px solid #333;
          color: #fff;
          padding: 10px 12px;
          font-family: monospace;
          font-size: 13px;
          outline: none;
        " />
      </div>

      <button id="judgment-btn" style="
        background: #000;
        color: #fff;
        border: 2px solid #fff;
        padding: 12px 30px;
        font-family: monospace;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        letter-spacing: 1px;
        transition: background 0.2s;
        width: 100%;
      ">SUBMIT TO JUDGMENT PROTOCOL</button>

      <p style="margin: 15px 0 0 0; font-size: 10px; color: #888; line-height: 1.4;">
        Submit your capture for collector review.<br>
        Top submissions will be minted as official subseries.
      </p>
    </div>
  </div>

  <!-- ─── EXPORT ENGINE ─── -->
  <script>
  (function(){
    function setupExport() {
    // ── Detect if embedded in iframe ──
    const isEmbedded = (window.self !== window.top);

    // ── DOM refs ──
    const toggle    = document.getElementById('export-toggle');
    if (!toggle) { setTimeout(setupExport, 50); return; } // wait for init() to create it

    // If embedded, hide RCS button and SUBMIT TO THE OVERLORD button, then exit
    if (isEmbedded) {
      toggle.style.display = 'none';
      const modal = document.getElementById('post-modal');
      if (modal) modal.style.display = 'none';
      const submitOverlordBtn = document.getElementById('submit-overlord-btn');
      if (submitOverlordBtn) submitOverlordBtn.style.display = 'none';
      return;
    }

    const panel     = document.getElementById('export-panel');
    const fmtSel    = document.getElementById('export-format');
    const durInput  = document.getElementById('export-duration');
    const startBtn  = document.getElementById('export-start-btn');
    const status    = document.getElementById('export-status');
    const durRow    = document.getElementById('duration-row');
    const modal     = document.getElementById('post-modal');
    const modalBtn  = document.getElementById('post-modal-btn');

    // ── Show POST TO X modal ──
    function showPostModal() {
      modal.classList.add('open');
      // Close export panel
      panel.classList.remove('open');
    }

    // Wire modal button to open Twitter compose page with pre-filled text
    modalBtn.onclick = () => {
      const text = encodeURIComponent('Know your overlord. #KnowYourOverlord\nTech Epochalypse by @Coldie');
      window.open(`https://x.com/intent/post?text=${text}`, '_blank');
      // Close modal
      modal.classList.remove('open');
    };

    // Wire judgment protocol button to open Airtable form
    const judgmentBtn = document.getElementById('judgment-btn');
    judgmentBtn.onclick = () => {
      const xAccount = document.getElementById('x-account-input').value.trim();
      let url = 'https://airtable.com/app28BSDaZwDpDw4m/pagUJlx4mF1vkSgO4/form';
      if (xAccount) {
        url += '?prefill_X+Account=' + encodeURIComponent(xAccount);
      }
      window.open(url, '_blank');
      // Close modal
      modal.classList.remove('open');
    };

    // Close modal on background click
    modal.onclick = (e) => {
      if (e.target === modal) modal.classList.remove('open');
    };

    // ── Toggle panel ──
    toggle.onclick = (e) => {
      e.stopPropagation();
      if (panel.classList.contains('open')) {
        panel.classList.remove('open');
      } else {
        // Position panel directly below the EXPORT button
        const rect = toggle.getBoundingClientRect();
        panel.style.top = (rect.bottom + 4) + 'px';
        panel.style.left = rect.left + 'px';
        panel.classList.add('open');
      }
    };
    document.addEventListener('click', (e) => {
      if (!panel.contains(e.target) && e.target !== toggle) panel.classList.remove('open');
    });

    // ── SUBMIT YOURSELF button — capture PNG then show post modal ──
    const submitOverlordBtn = document.getElementById('submit-overlord-btn');
    submitOverlordBtn.onclick = (e) => {
      e.stopPropagation();
      exportPNG();
    };

    // ── Format is PNG-only, duration row stays hidden ──
    fmtSel.onchange = () => {
      durRow.style.display = 'none';
    };

    // ── Helpers ──
    function setStatus(msg, cls) {
      status.textContent = msg;
      status.className = 'status-line' + (cls ? ' ' + cls : '');
    }
    function lockUI(on) {
      startBtn.disabled = on;
      fmtSel.disabled   = on;
      durInput.disabled  = on;
    }
    function triggerDownload(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a   = document.createElement('a');
      a.href    = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }
    // Wait for window.renderer to be available (exposed after 1 s by the app)
    function getRenderer() {
      return new Promise((resolve) => {
        const check = () => {
          if (window.renderer && window.renderer.domElement) resolve(window.renderer);
          else setTimeout(check, 100);
        };
        check();
      });
    }

    // ── Gallery API endpoint (update after deploying your Cloudflare Worker) ──
    const GALLERY_API = window.GALLERY_API_URL || '';

    // ── Save to community gallery via Cloudflare R2 ──
    function saveToGallery(canvas) {
      if (!GALLERY_API) {
        console.warn('Gallery API not configured — set window.GALLERY_API_URL');
        return;
      }
      try {
        const thumbCanvas = document.createElement('canvas');
        const MAX = 1200;
        const scale = Math.min(MAX / canvas.width, MAX / canvas.height, 1);
        thumbCanvas.width = Math.round(canvas.width * scale);
        thumbCanvas.height = Math.round(canvas.height * scale);
        const ctx = thumbCanvas.getContext('2d');
        ctx.drawImage(canvas, 0, 0, thumbCanvas.width, thumbCanvas.height);

        thumbCanvas.toBlob(async (blob) => {
          if (!blob) return;
          const form = new FormData();
          form.append('image', blob, 'export.jpg');
          form.append('overlord', 'sam-altman');
          try {
            const res = await fetch(GALLERY_API + '/upload', { method: 'POST', body: form });
            if (!res.ok) console.warn('Gallery upload response:', res.status);
          } catch (e) {
            console.warn('Gallery upload failed:', e);
          }
        }, 'image/jpeg', 0.85);
      } catch (e) {
        console.warn('Gallery save failed:', e);
      }
    }

    // ── PNG export ──
    async function exportPNG() {
      setStatus('Capturing…', 'active');
      lockUI(true);
      const r = await getRenderer();
      // Force a fresh render so the buffer has the current frame
      if (window.composer) {
        window.composer.render();
      } else if (window.scene && window.camera) {
        r.render(window.scene, window.camera);
      }
      r.domElement.toBlob((blob) => {
        if (blob) {
          triggerDownload(blob, 'sam-altman-coldie.png');
          saveToGallery(r.domElement);
          setStatus('PNG saved ✓ — added to gallery', 'active');
          showPostModal();
        } else {
          setStatus('Capture failed', 'error');
        }
        lockUI(false);
      }, 'image/png');
    }
    // ── Video (MP4) export ──────────────────────────────────────────
    async function exportVideo() {
      const duration = parseInt(durInput.value) * 1000; // ms

      const r = await getRenderer();
      const canvas = r.domElement;
      const stream = canvas.captureStream(30);

      const candidates = [
        'video/mp4;codecs=avc1.42E01E',
        'video/mp4;codecs=avc1.640028',
        'video/mp4',
        'video/webm;codecs=vp9',
        'video/webm;codecs=vp8',
        'video/webm'
      ];
      let usedMime = '';
      for (const m of candidates) {
        if (MediaRecorder.isTypeSupported(m)) { usedMime = m; break; }
      }
      if (!usedMime) { setStatus('No supported codec found', 'error'); return; }

      const nativeMp4 = usedMime.startsWith('video/mp4');

      const chunks = [];
      const mr = new MediaRecorder(stream, { mimeType: usedMime, videoBitsPerSecond: 2500000 });

      lockUI(true);
      startBtn.classList.add('recording');
      setStatus(`Recording… ${duration/1000}s`, 'active');

      mr.ondataavailable = (e) => { if (e.data.size) chunks.push(e.data); };
      mr.onstop = async () => {
        startBtn.classList.remove('recording');
        const raw = new Blob(chunks, { type: usedMime });

        if (nativeMp4) {
          triggerDownload(raw, 'sam-altman-coldie.mp4');
          setStatus('MP4 saved ✓', 'active');
          lockUI(false);
          return;
        }

        setStatus('Muxing WebM → MP4…', 'active');
        try {
          const buf = await raw.arrayBuffer();
          const mp4 = webmToMp4(new Uint8Array(buf), canvas.width, canvas.height);
          triggerDownload(new Blob([mp4], { type: 'video/mp4' }), 'sam-altman-coldie.mp4');
          setStatus('MP4 saved ✓', 'active');
        } catch (err) {
          console.error('Mux failed, falling back to .webm', err);
          triggerDownload(raw, 'sam-altman-coldie.webm');
          setStatus('Saved as .webm (mux failed)', 'error');
        }
        lockUI(false);
      };

      mr.start();
      setTimeout(() => mr.stop(), duration);
    }

    // ── Minimal WebM→MP4 re-muxer ──
    function webmToMp4(webmBytes, width, height) {
      function tag(s) { return [s.charCodeAt(0),s.charCodeAt(1),s.charCodeAt(2),s.charCodeAt(3)]; }
      function u32(v) { return [(v>>>24)&0xff,(v>>>16)&0xff,(v>>>8)&0xff,v&0xff]; }
      function u16(v) { return [(v>>>8)&0xff,v&0xff]; }
      function concat(...arrs) {
        const t = arrs.reduce((a,b)=>a+b.length,0);
        const r = new Uint8Array(t); let o=0;
        for (const a of arrs) { r.set(a,o); o+=a.length; }
        return r;
      }
      function box(type, payload) {
        const s = 8 + payload.length;
        return new Uint8Array([...u32(s),...tag(type),...payload]);
      }
      function fullBox(type, version, flags, payload) {
        return box(type, new Uint8Array([version,(flags>>16)&0xff,(flags>>8)&0xff,flags&0xff,...payload]));
      }

      const payload = webmBytes;

      const ftyp = box('ftyp', new Uint8Array([
        ...tag('isom'),...u32(0x200),...tag('isom'),...tag('iso2'),...tag('mp41')
      ]));

      const mvhd = fullBox('mvhd',0,0,new Uint8Array([
        ...u32(0),...u32(0),...u32(1000),...u32(0),
        0,1,0,0, 0x01,0x00, 0,0,
        ...new Uint8Array(8),
        0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x40,0,0,0,
        ...new Uint8Array(24),
        ...u32(2)
      ]));

      const tkhd = fullBox('tkhd',0,3,new Uint8Array([
        ...u32(0),...u32(0),...u32(1),...u32(0),...u32(0),
        ...new Uint8Array(8),
        0,0, 0,0,
        0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0x40,0,0,0,
        ...u16(width),0,0,...u16(height),0,0
      ]));

      const mdhd = fullBox('mdhd',0,0,new Uint8Array([
        ...u32(0),...u32(0),...u32(30000),...u32(0),
        0x55,0xC4, 0,0
      ]));
      const hdlr = fullBox('hdlr',0,0,new Uint8Array([
        ...u32(0),...tag('vide'),...new Uint8Array(12),0
      ]));
      const vmhd = fullBox('vmhd',0,1,new Uint8Array(8));
      const dinf = box('dinf', fullBox('dref',0,0,new Uint8Array([...u32(1),...Array.from(fullBox('url ',0,1,new Uint8Array(0)))])));
      const stts = fullBox('stts',0,0,new Uint8Array([...u32(0)]));
      const stsc = fullBox('stsc',0,0,new Uint8Array([...u32(0)]));
      const stsz = fullBox('stsz',0,0,new Uint8Array([...u32(0),...u32(0)]));
      const stco = fullBox('stco',0,0,new Uint8Array([...u32(0)]));
      const stbl = box('stbl', concat(
        fullBox('stsd',0,0,new Uint8Array([...u32(1),
          ...Array.from(box('mp4v', new Uint8Array([
            ...new Uint8Array(6), ...u16(1),
            ...new Uint8Array(16),
            ...u16(width),...u16(height),
            0,0x48,0,0, 0,0x48,0,0,
            ...new Uint8Array(4), ...u16(1),
            ...new Uint8Array(32),
            0,0x18, 0xff,0xff
          ])))])),
        stts, stsc, stsz, stco
      ));

      const mdia = box('mdia', concat(mdhd, hdlr, box('minf', concat(vmhd, dinf, stbl))));
      const trak = box('trak', concat(tkhd, mdia));

      const trex = fullBox('trex',0,0,new Uint8Array([...u32(1),...u32(1),...u32(0),...u32(0),...u32(0)]));
      const mvex = box('mvex', trex);

      const moov = box('moov', concat(mvhd, trak, mvex));

      const mdatSize = 8 + payload.length;
      const mdat = new Uint8Array([...u32(mdatSize), ...tag('mdat'), ...payload]);

      return concat(ftyp, moov, mdat);
    }

    // ── Main dispatcher ──
    startBtn.onclick = () => {
      const f = fmtSel.value;
      if      (f === 'png') exportPNG();
      else if (f === 'mp4') exportVideo();
    };
    } // end setupExport
    setupExport();
  })();
  </script>

</body></html>