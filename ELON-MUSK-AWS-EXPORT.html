<!doctype html>
<html lang="en"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.176.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.176.0/examples/jsm/",
        "mediabunny": "https://cdn.jsdelivr.net/npm/mediabunny@1.25.8/+esm"
      }
    }
  </script>
  <style>
    body {
      margin: 0;
      display: flex;
      width: 100vw;
      height: 100vh;
      justify-content: center;
      align-items: center;
      overflow: auto;
      background: transparent;
    }

    main {
      height: 100%;
      display: flex;
      overflow: auto;
      justify-content: center;
      align-items: center;
    }
    
    canvas {
      cursor: grab;
    }

    /* ─── EXPORT PANEL ─── */
    #export-panel {
      position: absolute;
      left: 10px;
      z-index: 199;
      background: rgba(0,0,0,0.88);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 4px;
      padding: 12px 14px;
      font-family: monospace;
      color: #ccc;
      font-size: 10px;
      width: 200px;
      display: none;
      flex-direction: column;
      gap: 8px;
      box-shadow: 0 4px 24px rgba(0,0,0,0.5);
    }
    #export-panel.open { display: flex; }

    #export-panel .panel-title {
      color: #fff;
      font-size: 11px;
      letter-spacing: 1.5px;
      border-bottom: 1px solid rgba(255,255,255,0.15);
      padding-bottom: 6px;
      margin-bottom: 2px;
    }

    #export-panel .export-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    #export-panel .export-row label {
      flex: 1;
      color: #aaa;
      font-size: 10px;
      letter-spacing: 0.5px;
    }
    #export-panel .export-row select,
    #export-panel .export-row input[type="number"] {
      background: #111;
      color: #ddd;
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 2px;
      padding: 3px 5px;
      font-family: monospace;
      font-size: 10px;
      width: 58px;
      outline: none;
    }
    #export-panel .export-row select:focus,
    #export-panel .export-row input[type="number"]:focus {
      border-color: rgba(255,255,255,0.5);
    }

    #export-panel .export-btn {
      background: #000;
      color: #fff;
      border: 1px solid rgba(255,255,255,0.3);
      border-radius: 2px;
      padding: 5px 0;
      font-family: monospace;
      font-size: 10px;
      letter-spacing: 1px;
      cursor: pointer;
      text-align: center;
      transition: border-color 0.2s, background 0.2s;
    }
    #export-panel .export-btn:hover { border-color: #fff; background: #1a1a1a; }
    #export-panel .export-btn:disabled { opacity: 0.35; cursor: not-allowed; }

    #export-panel .export-btn.recording {
      border-color: #e33;
      animation: rec-pulse 1s infinite;
    }
    @keyframes rec-pulse {
      0%,100% { border-color: #e33; }
      50%      { border-color: #f88; }
    }

    #export-panel .status-line {
      color: #666;
      font-size: 9px;
      text-align: center;
      min-height: 11px;
      letter-spacing: 0.5px;
    }
    #export-panel .status-line.active { color: #4c4; }
    #export-panel .status-line.error   { color: #e66; }

    /* ─── POST TO X MODAL ─── */
    #post-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0,0,0,0.85);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 300;
    }
    #post-modal.open { display: flex; }

    #post-modal-content {
      background: #000;
      border: 2px solid #fff;
      padding: 30px 40px;
      text-align: center;
      font-family: monospace;
      color: #fff;
    }

    #post-modal h2 {
      margin: 0 0 20px 0;
      font-size: 24px;
      letter-spacing: 2px;
      font-weight: bold;
    }

    #post-modal-btn {
      background: #1DA1F2;
      color: #fff;
      border: none;
      padding: 12px 30px;
      font-family: monospace;
      font-size: 14px;
      font-weight: bold;
      cursor: pointer;
      letter-spacing: 1px;
      transition: background 0.2s;
    }
    #post-modal-btn:hover { background: #1a8cd8; }
  </style>
  <title>ELON-MUSK-AWS-MASTER | Made on juno.transient.xyz</title>
</head>
<body>
  
    
  <script type="module">
    import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { GlitchPass } from 'three/addons/postprocessing/GlitchPass.js';

let camera, scene, renderer, controls, composer;
let raycaster, mouse;
let draggableObjects = [];
let selectedObject = null;
let offset = new THREE.Vector3();
let initialObjectZ = 0; // Store the initial Z-position of the selected object

const depthStep = 0.2; // Defines the depth separation between levels
const totalDepthLayers = 15; // Total number of depth layers available
const subLayerOffset = 0.05; // Smaller offset for visual separation within a layer (0.25 levels * depthStep = 0.25 * 0.2 = 0.05)
const zeroParallaxDepth = (5 - 1) * depthStep; // Z-position for level 5

let isDragging = false; // Flag to indicate if a drag operation is in progress
let pointerDownPosition = new THREE.Vector2(); // To store the initial pointer down position
const DRAG_THRESHOLD = 5; // Pixels threshold to consider a move as a drag

let backgroundMesh = null; // To store the background mesh for positioning calculations

// Camera animation variables
let cameraAnimationActive = false;
let cameraAnimationTargets = [];
let selectedTargetIndex = 0; // Index of the currently selected target
let currentCameraTarget = null;
let cameraAnimationState = 'idle'; // 'idle', 'exploring', 'returningToGlobalStart'
let cameraAnimationStartTime = 0;
const cameraExplorationDuration = 2500; // 5 seconds for exploring (moving to target) - halved
const cameraReturnDuration = 1250; // 2.5 seconds for returning to start - halved
let cameraPreviousPos = new THREE.Vector3();
let cameraPreviousLookAt = new THREE.Vector3();
let cameraCurrentTargetPos = new THREE.Vector3();
let cameraCurrentTargetLookAt = new THREE.Vector3();
let cameraTargetObject = null;

// New camera animation variables for global return
let initialGlobalCameraPos = new THREE.Vector3();
let initialGlobalCameraLookAt = new THREE.Vector3();
let assetsVisitedCount = 0;
const ASSETS_PER_GLOBAL_RETURN = 6;

// Y-axis bounce animation variables
let yBounceInitialCameraX = 0;
let yBounceInitialCameraY = 0;
let yBounceInitialCameraZ = 0;
const yBounceRangeX = 2.0; // 20% of a reasonable scene width (e.g., 10 units wide scene)
const yBounceSpeed = 0.001; // Speed of the bounce

let yRotationStartTime = 0; // New: To track when Y-rotation started
const Y_ROTATION_DURATION_BEFORE_CAM_ANIM = 10000; // 10 seconds

// Redaction rectangles
let rightEyeRedactionRect = null;
let leftEyeRedactionRect = null;
let rightEyeMesh = null; // Globally declare right eye mesh
let leftEyeMesh = null; // Globally declare left eye mesh

// Marquee text variables
let marqueeTextMesh;
let marqueeTexture;
let marqueeScrollOffset = 0;
const MARQUEE_LINE_HEIGHT = 180; // Pixels per line, increased by 200%
const MARQUEE_TOTAL_LINES = 10; // Number of lines to display
const MARQUEE_SCROLL_SPEED = 16.0; // Pixels per frame (Increased by 4x from 4.0)
const MARQUEE_PHRASES = [
    "SECURITY BREACH DETECTED",
    "UNAUTHORIZED ACCESS PROHIBITED",
    "SENSITIVE DATA EXPOSED",
    "CLASSIFIED INFORMATION AT RISK",
    "DATA COLLECTION IN PROGRESS",
    "WARNING: PROSECUTION FOR MISUSE",
    "COMPROMISED SYSTEM ALERT",
    "INTELLIGENCE GATHERING ACTIVE",
    "MONITORING ALL COMMUNICATIONS",
    "EVIDENCE LOGGING INITIATED",
    "ACCESS DENIED - LEVEL 5 REQUIRED",
    "BIOMETRIC SCAN INITIATED",
    "ENCRYPTED CHANNEL ESTABLISHED",
    "ANOMALY DETECTED",
    "USE LEVERAGE",
    "REDACTED FOR YOUR PROTECTION",
    "SYSTEM INTEGRITY COMPROMISED",
    "NETWORK INTRUSION DETECTED",
    "DIGITAL FOOTPRINT TRACED",
    "PRIVACY VIOLATION IMMINENT",
    "DATA EXFILTRATION WARNING",
    "LIQUIDATE AT ALL COSTS",
    "SURVEILLANCE ACTIVE",
    "NON-COMPLIANCE PENALTIES APPLY",
    "INFORMATION HARVESTING IN PROGRESS",
    "CONFIDENTIALITY BREACH",
    "ALERT: MALWARE DETECTED",
    "INITIATING PROTOCOL SIGMA",
    "ACCESS LOGS REVIEWED",
    "TRACEABILITY ENABLED",
    "WARNING: PII EXPOSURE"
];

// New biometric marquee variables
let biometricMarqueeTextMesh;
let biometricMarqueeTexture;
let biometricMarqueeScrollOffset = 0;
const BIOMETRIC_MARQUEE_LINE_HEIGHT = 100; // Smaller font size for biometric data
const BIOMETRIC_MARQUEE_TOTAL_LINES = 15; // More lines for biometric data
const BIOMETRIC_MARQUEE_SCROLL_SPEED = 4.0; // Slower than main marquee (changed from 8.0 to 4.0)
const BIOMETRIC_PHRASES = [
    "HEART RATE: 72 BPM",
    "BLOOD PRESSURE: 120/80 mmHg",
    "TEMPERATURE: 98.6 F (37.0 C)",
    "DNA SEQUENCE: ATGCAGTACTGCA...",
    "RETINAL SCAN: POSITIVE MATCH",
    "VOICE PRINT: IDENTIFIED",
    "NEURAL ACTIVITY: ELEVATED",
    "BRAINWAVES: ALPHA DOMINANT",
    "SKELETAL DENSITY: NORMAL",
    "ORGAN FUNCTION: OPTIMAL",
    "ELECTROLYTES: BALANCED",
    "METABOLIC RATE: AVERAGE",
    "GENETIC MARKERS: PRESENT",
    "IMMUNE RESPONSE: ACTIVE",
    "CELLULAR REGENERATION: HIGH",
    "NEUROTRANSMITTER LEVELS: STABLE",
    "ENDOCRINE SYSTEM: FUNCTIONAL",
    "RESPIRATORY RATE: 16 BREATHS/MIN",
    "PULSE OXIMETRY: 98% SpO2",
    "GLUCOSE LEVELS: 90 mg/dL",
    "ADRENAL OUTPUT: NORMAL",
    "CIRCADIAN RHYTHM: REGULAR",
    "COGNITIVE PROCESSING: RAPID",
    "EMOTIONAL STATE: NEUTRAL",
    "SLEEP CYCLE: REM STAGE ACTIVE",
    "MUSCLE TENSION: LOW",
    "HORMONE PROFILE: STABLE",
    "TOXIN LEVELS: UNDETECTED",
    "ALLERGEN RESPONSE: NEGATIVE"
];

const DIAGNOSTIC_CAPTIONS = [
    "DATA STREAM: STABLE",
    "ANALYSIS: COMPLETE",
    "STATUS: NORMALIZED",
    "TREND: OPTIMAL",
    "PREDICTION: LOW RISK",
    "ALERT: NONE",
    "READOUT: POSITIVE",
    "DIAGNOSIS: CLEAR",
    "VALIDATION: SUCCESS",
    "INTEGRITY: HIGH",
    "ACCESS: GRANTED",
    "PROCESSING: REAL-TIME",
    "CONNECTION: SECURE",
    "SYSTEM: ONLINE",
    "MODE: ACTIVE"
];

let biometricAnimationState = {
    graphData: [],
    sinePhase: 0,
    heartbeatPhase: 0,
    heartbeatPulse: false,
    lastHeartbeatTime: 0
};

// New Blood Text variables
let bloodTextMesh;
let bloodTexture;
let bloodScrollOffset = 0;
const BLOOD_TEXT_FONT_SIZE = 120; // Reduced from 180 for mobile performance
const BLOOD_TEXT_LINE_HEIGHT = BLOOD_TEXT_FONT_SIZE * 1.2; // Line height for spacing
const BLOOD_TEXT_TOTAL_LINES = 15; // Reduced from 22 for mobile performance
const BLOOD_TEXT_SCROLL_SPEED = 3.0; // Increased from 7.0 for snappier mobile feel
let shuffledBloodPhrases = []; // To store the shuffled phrases
const BLOOD_TEXT_PHRASES = [
      "BIAS REINFORCEMENT",
    "DARK ECONOMY",
    "REALITY DISTORTION",
    "EXPLOIT VULNERABILITIES",
    "FEED MANIPULATION",
    "AI SHOCKWAVE",
    "DESIRE TO CONFORM",
    "CONFUSION PERSUASION",
    "DATA PHOTONS",
    "PSYCHOLOGICAL OPERATIONS",
    "GEO-STALKING",
    "DATA MINING",
    "DOPAMINE LOOP",
    "MAGNETIC CONTROL",
    "VULNERABILITY TRACKING",
    "ENGAGEMENT TRAPS",
    "EXPLOIT HUMAN FLAW",
    "PRIVACY EROSION",
    "ALWAYS-ON LISTENING",
    "PREDICTIVE BEHAVIOR",
    "AMPLIFIED INFLUENCE",
    "LOCATION TRACKING",
    "ECHO CHAMBERING",
    "FEED INSTANT GRATITUDE",
    "LICK THE BOOT",
    "CRY AND BOW",
    "ILLUSION OF CONTROL",
    "COGNATIVE BIAS",
];

// Redacted Glitch Text variables
let redactedGlitchTextMesh;
let redactedGlitchTexture;
let redactedGlitchScrollOffset = 0;
const REDACTED_GLITCH_FONT_SIZE = 24;
const REDACTED_GLITCH_LINE_HEIGHT = REDACTED_GLITCH_FONT_SIZE * 1.5;
const REDACTED_GLITCH_TOTAL_LINES = 30;
const REDACTED_GLITCH_SCROLL_SPEED = 2.0;
const REDACTED_GLITCH_PHRASES = [
    "PERSONAL IDENTIFIER ACQUIRED",
    "LOCATION TRACKING INITIATED",
    "COMMUNICATION LOGS UPLOADED",
    "BEHAVIORAL PROFILE GENERATED",
    "BIO-METRIC DATA EXTRACTED",
    "FINANCIAL RECORDS ANALYZED",
    "NETWORK ACTIVITY MONITORED",
    "DIGITAL FOOTPRINT TRACED",
    "SENTIMENT ANALYSIS COMPLETE",
    "ACCESS CREDENTIALS COMPROMISED",
    "THREAT ASSESSMENT LEVEL CLASSIFIED",
    "TARGET IDENTIFIED: UNKNOWN",
    "DATA EXFILTRATION PROTOCOL ACTIVE",
    "SURVEILLANCE FEED ACTIVE",
    "USER ACTIVITY RECORDED",
    "PRIVACY SETTINGS OVERRIDDEN",
    "CONNECTION LOGS STORED",
    "SEARCH HISTORY ARCHIVED",
    "PURCHASE PATTERNS LOGGED",
    "EMOTIONAL RESPONSE CAPTURED",
    "NEURAL ACTIVITY MAPPED",
    "GENETIC PREDISPOSITIONS FLAGGED",
    "VULNERABILITY ASSESSMENT COMPLETE",
    "OPERATIONAL STATUS REPORTED",
    "DIRECTIVE ISSUED: INITIATE",
    "STATUS: COMPROMISED",
    "ACTION: REQUIRED",
    "WARNING: ACCESS REVOKED",
    "CONFIDENTIALITY: BREACHED",
    "PROTOCOL: EXECUTED"
];

// New data structure to store redacted words for each phrase
let redactedGlitchPhraseData = []; // Array of objects {text: string, redactedWordIndices: number[], redactionApplied: boolean}

// Define all layer URLs at the top of the script
const URL_BACKGROUND = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/K-Dallas-Region-BG.jpg';
const URL_FOREHEAD = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/Musk-_0000s_0010_forehead.png';
const URL_MOUTH = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/Musk-_0000s_0008_mouth.png';
const URL_LEFT_EYE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/Musk-_0000s_0009_Eye-L.png';
const URL_X_LOGO_SWAP = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/X_Logo.png';
const URL_NOSE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/Musk-_0000s_0003_nose-2.png';
const URL_HAIR = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/Musk-_0000s_0001_hair.png';
const URL_BLUE_BILL = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/Musk-_0000s_0018_K-bluebill.png';
const URL_DOGECOIN_ORIGINAL = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/grok.gif';
const URL_TESLA_SWAP = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/tesla.png';
    const URL_SIGNATURE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/coldie-sig.gif';
const URL_ROCKET = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/Musk-_0000s_0016_rocket.png';
const URL_RIGHT_EYE = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/Musk-_0000s_0007_Eye-R.png'; 
const URL_SPACEX_ORIGINAL = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/Musk-_0000s_0000_SpaceX.png';
const URL_EAR = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/Musk-_0000s_0002_ear.png';
const URL_FIAT_WORTHLESS = 'https://decentral-eyes.s3.us-west-2.amazonaws.com/tech-epoch/musk/Musk-_0000s_0005_Fiat-is-worthless-so-yes.png';

// Define the initial X position for the rocket (was missing)
const ROCKET_INITIAL_X = -2.0;

function initializeRedactedGlitchPhraseData() {
    redactedGlitchPhraseData = REDACTED_GLITCH_PHRASES.map(phrase => {
        const words = phrase.split(/(\s+)/).filter(word => word.length > 0); // Split by spaces, keeping spaces
        const numWords = words.filter(word => !/\s+/.test(word)).length; // Count actual words

        const wordIndicesToRedact = [];
        if (numWords > 0 && Math.random() < 0.6) { // 60% chance to redact a line
            const numWordsToRedact = Math.floor(Math.random() * Math.min(3, numWords)) + 1; // Redact 1 to 3 words

            // Find actual word indices
            const actualWordIndices = [];
            for (let i = 0; i < words.length; i++) {
                if (!/\s+/.test(words[i])) {
                    actualWordIndices.push(i);
                }
            }

            if (actualWordIndices.length > 0) {
                const startIndex = Math.floor(Math.random() * Math.max(1, actualWordIndices.length - numWordsToRedact + 1));
                for (let i = 0; i < numWordsToRedact; i++) {
                    if (startIndex + i < actualWordIndices.length) {
                        wordIndicesToRedact.push(actualWordIndices[startIndex + i]);
                    }
                }
            }
        }
        return { text: phrase, redactedWordIndices: wordIndicesToRedact };
    });
}

// Shader definitions
const GreyscaleContrastShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'contrast': { value: 1.5 } // Default contrast value
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float contrast;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to greyscale
            // Apply contrast to the greyscale value
            luma = ((luma - 0.5) * contrast) + 0.5;
            // Output greyscale with contrast
            gl_FragColor = vec4(luma, luma, luma, texel.a);
        }
    `
};

const GreyScaleShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            gl_FragColor = vec4(luma, luma, luma, texel.a);
        }
    `
};

const ThresholdShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'threshold': { value: 0.5 }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float threshold;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            // Standard threshold: Dark becomes black (0.0), bright becomes white (1.0)
            gl_FragColor = vec4(vec3(step(threshold, luma)), texel.a); 
        }
    `
};

const DarkShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'threshold': { value: 0.5 },
        'brightnessMultiplier': { value: 0.031 } // New uniform for brightness control
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float threshold;
        uniform float brightnessMultiplier;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            // Only keep bright pixels, then turn them into very dark gray (brightnessMultiplier)
            // Anything below threshold is 0.0 (pure black)
            gl_FragColor = vec4(vec3(step(threshold, luma) * brightnessMultiplier), texel.a);
        }
    `
};

const PixelationShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'resolution': { value: new THREE.Vector2() },
        'pixelSize': { value: 8.0 }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform float pixelSize;
        varying vec2 vUv;
        void main() {
            vec2 uv = vUv;
            vec2 pixelatedUV = floor(uv * resolution / pixelSize) * pixelSize / resolution;
            gl_FragColor = texture2D(tDiffuse, pixelatedUV);
        }
    `
};

const MatrixShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to greyscale
            
            // Simple binary look: quantize to black or green
            vec3 finalColor = mix(vec3(0.0), vec3(0.0, 1.0, 0.0), step(0.5, luma));
            
            // Add a subtle grid/dither to suggest binary elements
            float grid = mod(floor(vUv.x * 100.0) + floor(vUv.y * 100.0), 2.0);
            finalColor = mix(finalColor * 0.8, finalColor, grid);

            gl_FragColor = vec4(finalColor, texel.a);
        }
    `
};

const ASCIIShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'resolution': { value: new THREE.Vector2() },
        'pixelSize': { value: 8.0 }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform float pixelSize;
        varying vec2 vUv;
        void main() {
            vec2 uv = vUv;
            vec2 pixelatedUV = floor(uv * resolution / pixelSize) * pixelSize / resolution;
            vec4 texel = texture2D(tDiffuse, pixelatedUV);
            
            // Convert to luminance
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114));
            
            // Quantize luminance to simulate character density
            // Use a few steps to represent different 'characters'
            float step1 = step(0.25, luma); // Darkest areas
            float step2 = step(0.50, luma); // Mid areas
            float step3 = step(0.75, luma); // Brightest areas
            
            vec3 finalColor;
            if (step3 == 1.0) {
                finalColor = vec3(0.0, 1.0, 0.0); // Brightest green
            } else if (step2 == 1.0) {
                finalColor = vec3(0.0, 0.7, 0.0); // Medium green
            } else if (step1 == 1.0) {
                finalColor = vec3(0.0, 0.4, 0.0); // Dark green
            } else {
                finalColor = vec3(0.0);
            }
            
            gl_FragColor = vec4(finalColor, texel.a);
        }
    `
};

const XRayShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Grayscale
            float invertedLuma = 1.0 - luma; // Invert grayscale
            vec3 xrayColor = vec3(0.0, 0.7, 1.0) * invertedLuma; // Apply a blue/cyan tint
            gl_FragColor = vec4(xrayColor, texel.a);
        }
    `
};

const HeatmapShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float threshold;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to luminance

            vec3 color;
            if (luma < 0.2) { // Darkest areas, deep blue
                color = mix(vec3(0.0, 0.0, 0.2), vec3(0.0, 0.0, 0.8), luma / 0.2);
            } else if (luma < 0.4) { // Blue to Cyan
                color = mix(vec3(0.0, 0.0, 0.8), vec3(0.0, 0.8, 0.8), (luma - 0.2) / 0.2);
            } else if (luma < 0.6) { // Cyan to Green
                color = mix(vec3(0.0, 0.8, 0.8), vec3(0.0, 1.0, 0.0), (luma - 0.4) / 0.2);
            } else if (luma < 0.8) { // Green to Yellow
                color = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 1.0, 0.0), (luma - 0.6) / 0.2);
            } else { // Yellow to Red
                color = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), (luma - 0.8) / 0.2);
            }

            gl_FragColor = vec4(color, texel.a);
        }
    `
};

const BloodShader = {
    uniforms: {
        'tDiffuse': { value: null }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        varying vec2 vUv;
        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            float luma = dot(texel.rgb, vec3(0.299, 0.587, 0.114)); // Convert to luminance

            vec3 color;
            if (luma < 0.2) { // Very dark red to black
                color = mix(vec3(0.0, 0.0, 0.0), vec3(0.3, 0.0, 0.0), luma / 0.2);
            } else if (luma < 0.4) { // Deep red to medium red
                color = mix(vec3(0.3, 0.0, 0.0), vec3(0.7, 0.0, 0.0), (luma - 0.2) / 0.2);
            } else if (luma < 0.6) { // Medium red to bright red
                color = mix(vec3(0.7, 0.0, 0.0), vec3(1.0, 0.1, 0.1), (luma - 0.4) / 0.2);
            } else if (luma < 0.8) { // Bright red to orange-red
                color = mix(vec3(1.0, 0.1, 0.1), vec3(1.0, 0.4, 0.0), (luma - 0.6) / 0.2);
            } else { // Orange-red to yellowish-orange
                color = mix(vec3(1.0, 0.4, 0.0), vec3(1.0, 0.7, 0.2), (luma - 0.8) / 0.2);
            }

            gl_FragColor = vec4(color, texel.a);
        }
    `
};

const CCTVFeedShader = {
    uniforms: {
        'tDiffuse': { value: null },
        'time': { value: 0.0 },
        'resolution': { value: new THREE.Vector2() }
    },
    vertexShader: /* glsl */`
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: /* glsl */`
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform vec2 resolution;
        varying vec2 vUv;

        float rand(vec2 co) {
            return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);
        }

        void main() {
            vec2 uv = vUv;
            vec2 pixelatedUV = floor(uv * resolution / 16.0) * 16.0 / resolution; // Blocky effect

            // Glitch effect: random horizontal displacement and color channel split
            float randomVal = rand(floor(uv * 100.0) + fract(time * 0.1));
            float displacement = (randomVal - 0.5) * 0.05 * sin(time * 10.0 + uv.y * 50.0); // Oscillating displacement

            vec4 colorR = texture2D(tDiffuse, pixelatedUV + vec2(displacement, 0.0));
            vec4 colorG = texture2D(tDiffuse, pixelatedUV);
            vec4 colorB = texture2D(tDiffuse, pixelatedUV - vec2(displacement, 0.0));

            vec4 glitchedColor = vec4(colorR.r, colorG.g, colorB.b, 1.0);

            // Convert glitched color to luminance
            float lumaGlitched = dot(glitchedColor.rgb, vec3(0.299, 0.587, 0.114));
            
            // Apply a slight green tint
            vec3 tintedColor = mix(vec3(lumaGlitched), vec3(0.0, 0.5, 0.0), 0.3);

            // Add scanlines
            float scanline = sin(uv.y * resolution.y * 0.5) * 0.05 + 0.95; // Subtle scanlines
            tintedColor *= scanline;

            // Add subtle noise/static
            float noise = rand(uv + time * 0.01) * 0.1; // Small amount of noise
            tintedColor += noise;

            gl_FragColor = vec4(tintedColor, glitchedColor.a);
        }
    `
};

// UI controls state
const effectControls = {
    greyscale: false,
    threshold: false,
    thresholdValue: 0.4, // Decreased by 20% (0.5 * 0.8 = 0.4)
    shadow: false, // Renamed from 'dark' to 'shadow'
    shadowBrightness: 0.033, // New setting for shadow brightness (5% brighter than 0.02)
    pixelation: false,
    pixelSize: 8.0,
    glitch: false,
    matrix: false,
    ascii: false,
    xray: false,
    yRotation: false,
    cameraAnimation: false,
    redacted: false,
    redactedGlitch: false,
    heatmap: false,
    blood: false, // New control for BLOOD effect
    cctvFeed: false,
    marqueeText: false,
    biometricMarquee: false, // New control for biometric marquee
    anon: false, // New control for ANON effect
    og: false, // New control for OG effect
    bloodText: false, // New control for blood text
    hacker: false, // New control for HACKER effect
    surveillance: false, // New control for SURVEILLANCE effect
    greed: false // New control for GREED effect
};

let greyscalePass, thresholdPass, darkPass, pixelationPass, glitchPass, matrixPass, asciiPass, xrayPass, heatmapPass, bloodPass, cctvFeedPass;

let trashButtonElement = null; // Global reference for the trash button UI element
let exportButtonElement = null; // Global reference for the export button UI element
let leftUiContainer = null; // Global reference for the left UI container
let arrowContainer = null; // Global reference for the arrow container

// Array to store initial configurations of assets for reloading
const initialAssetConfigs = [];

let dogecoinRef = null; // To hold the dogecoin mesh for later reference
let dogecoinOriginalTexture = null; // To store the original dogecoin texture
let teslaTexture = null; // To store the Tesla logo texture
let teslaGreyscaleContrastMaterial = null; // New: To store the Tesla greyscale high contrast material

let spacexRef = null; // To hold the spacex mesh for later reference
let spacexOriginalTexture = null; // To store the original spacex texture
let xLogoTexture = null; // To store the X logo texture

// Helper function to update UI button state
const updateUIButtonState = (effectName, isActive) => {
    // Select all buttons with the given data-effect attribute
    const buttons = document.querySelectorAll(`button[data-effect="${effectName}"]`);
    buttons.forEach(button => {
        button.style.borderColor = isActive ? '#4CAF50' : 'white';
    });
};

function createTextTexture(text, fontSize = 60, color = 'white', backgroundColor = 'rgba(0,0,0,0.5)', font = 'monospace') {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    context.font = `${fontSize}px ${font}`;
    const metrics = context.measureText(text);
    const textWidth = metrics.width;
    const textHeight = fontSize * 1.2; // Approximate height including line spacing

    canvas.width = textWidth + 20; // Add some padding
    canvas.height = textHeight + 20;

    context.font = `${fontSize}px ${font}`;
    context.fillStyle = backgroundColor;
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.fillStyle = color;
    context.fillText(text, 10, fontSize + 10); // Position text with padding

    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    return texture;
}

function createMarqueeTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    // Canvas size: large enough to hold multiple repetitions of lines for seamless scrolling
    // Width should be enough for the longest phrase
    let maxWidth = 0;
    context.font = `bold 108px 'Courier New', monospace`; // Increased font size and ASCII style font, now bold
    MARQUEE_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    canvas.width = maxWidth + 50; // Add padding
    canvas.height = MARQUEE_LINE_HEIGHT * (MARQUEE_TOTAL_LINES * 2); // Double the height to allow seamless scrolling

    marqueeTexture = new THREE.CanvasTexture(canvas);
    marqueeTexture.wrapS = THREE.RepeatWrapping;
    marqueeTexture.wrapT = THREE.RepeatWrapping;
    marqueeTexture.needsUpdate = true;
    return marqueeTexture;
}

function updateMarqueeTexture() {
    if (!marqueeTexture) return;

    const canvas = marqueeTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'rgba(0, 0, 0, 0.0)'; // Transparent background
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `bold 108px 'Courier New', monospace`; // Increased font size and ASCII style font, now bold
    context.fillStyle = 'rgba(255, 255, 255, 0.05)'; // Very faint white text
    context.textAlign = 'center';

    // Calculate the total height of one set of lines
    const singleSetHeight = MARQUEE_LINE_HEIGHT * MARQUEE_TOTAL_LINES;

    // Draw lines, repeating them to create a seamless loop
    for (let i = 0; i < MARQUEE_TOTAL_LINES * 2; i++) { // Draw two sets of lines
        const phraseIndex = i % MARQUEE_PHRASES.length;
        const line = MARQUEE_PHRASES[phraseIndex];

        let yPos = (i * MARQUEE_LINE_HEIGHT) + marqueeScrollOffset;

        // Loop the text when it scrolls off the top
        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 2; // Move it to the bottom of the second set
        }

        context.fillText(line, canvas.width / 2, yPos);
    }

    marqueeTexture.needsUpdate = true;
}

function createBiometricMarqueeTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    let maxWidth = 0;
    // Set a fixed width for the canvas to accommodate graphs/waves
    canvas.width = 1200; // Increased width

    context.font = `bold 36px 'Courier New', monospace`; // Smaller font for biometric data (72 / 2 = 36)
    BIOMETRIC_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    // Ensure canvas width is at least maxWidth + padding, but also allow for fixed size
    canvas.width = Math.max(canvas.width, maxWidth + 50);
    canvas.height = BIOMETRIC_MARQUEE_LINE_HEIGHT * (BIOMETRIC_MARQUEE_TOTAL_LINES * 2);

    biometricMarqueeTexture = new THREE.CanvasTexture(canvas);
    biometricMarqueeTexture.wrapS = THREE.RepeatWrapping;
    biometricMarqueeTexture.wrapT = THREE.RepeatWrapping;
    biometricMarqueeTexture.needsUpdate = true;
    return biometricMarqueeTexture;
}

function updateBiometricMarqueeTexture(currentTime) {
    if (!biometricMarqueeTexture) return;

    const canvas = biometricMarqueeTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'rgba(0, 0, 0, 0.0)'; // Transparent background
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `bold 36px 'Courier New', monospace`; // Smaller font for biometric data
    context.textAlign = 'center';

    const singleSetHeight = BIOMETRIC_MARQUEE_LINE_HEIGHT * BIOMETRIC_MARQUEE_TOTAL_LINES;

    // Update biometric animation states (slowed down)
    biometricAnimationState.sinePhase += 0.00125; // Reduced from 0.0025 by 200%
    if (biometricAnimationState.sinePhase > Math.PI * 2) biometricAnimationState.sinePhase -= Math.PI * 2;

    const HEARTBEAT_INTERVAL = 6000; // milliseconds (Increased from 3000 by 200%)
    if (currentTime - biometricAnimationState.lastHeartbeatTime > HEARTBEAT_INTERVAL) {
        biometricAnimationState.heartbeatPulse = true;
        biometricAnimationState.lastHeartbeatTime = currentTime;
    } else {
        biometricAnimationState.heartbeatPulse = false;
    }

    // Generate new graph data periodically or on demand
    if (biometricAnimationState.graphData.length === 0 || Math.random() < 0.01) { // Reduced probability to regenerate graph data
        biometricAnimationState.graphData = [];
        for (let j = 0; j < 20; j++) { // Increased number of data points for more detailed graphs
            biometricAnimationState.graphData.push(Math.random());
        }
    }

    for (let i = 0; i < BIOMETRIC_MARQUEE_TOTAL_LINES * 2; i++) {
        const phraseIndex = i % BIOMETRIC_PHRASES.length;
        const line = BIOMETRIC_PHRASES[phraseIndex];

        let yPos = (i * BIOMETRIC_MARQUEE_LINE_HEIGHT) + biometricMarqueeScrollOffset;

        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 2;
        }

        // Draw the full text first
        context.fillStyle = 'rgba(0, 255, 0, 0.1)'; // Faint green text
        context.fillText(line, canvas.width / 2, yPos);

        // Randomly redact parts of the text
        if (Math.random() < 0.6) { // 60% chance to redact a line
            const words = line.split(' ');
            if (words.length > 1) {
                const wordToRedactIndex = Math.floor(Math.random() * words.length);

                const textBeforeRedaction = words.slice(0, wordToRedactIndex).join(' ');
                const redactedWord = words[wordToRedactIndex];

                // Measure text up to the redacted word to get its starting X position
                const totalTextWidth = context.measureText(line).width;
                const startX = (canvas.width / 2) - (totalTextWidth / 2) + context.measureText(textBeforeRedaction).width;

                // Draw a black rectangle over the selected word
                context.fillStyle = 'black'; // Redaction color
                context.fillRect(startX, yPos - BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.7, context.measureText(redactedWord).width, BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.9);
            }
        }

        // Randomly draw animated biometric data (graphs, sine waves, heartbeat)
        if (Math.random() < 0.4) { // Increased chance to draw an animated element on this line
            const animType = Math.floor(Math.random() * 3); // 0: graph, 1: sine, 2: heartbeat
            const animWidth = 200 * 4; // Increased by 400%
            const animHeight = (BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.8) * 4; // Increased by 400%

            // Randomize X position to space graphs more
            const animX = (canvas.width * 0.05) + (Math.random() * (canvas.width * 0.8 - animWidth));

            // Randomize Y position to place graphs on different levels
            const animY = yPos - (animHeight / 2) + (Math.random() - 0.5) * BIOMETRIC_MARQUEE_LINE_HEIGHT * 1.5;

            context.save();
            context.beginPath();
            context.rect(animX, animY, animWidth, animHeight);
            context.clip(); // Clip drawing to this rectangle

            if (animType === 0) { // Graph
                context.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White color, slightly more opaque
                context.lineWidth = 3; // Thicker lines
                context.moveTo(animX, animY + animHeight); // Start at bottom left
                for (let j = 0; j < biometricAnimationState.graphData.length; j++) {
                    const x = animX + (j / (biometricAnimationState.graphData.length - 1)) * animWidth;
                    const y = animY + animHeight - (biometricAnimationState.graphData[j] * animHeight * (0.8 + 0.2 * Math.sin(currentTime * 0.0005))); // Animated height (speed reduced from 0.001 to 0.0005)
                    context.lineTo(x, y);
                }
                context.stroke();
            } else if (animType === 1) { // Sine Wave
                context.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White color, slightly more opaque
                context.lineWidth = 3; // Thicker lines
                context.moveTo(animX, animY + animHeight / 2 + Math.sin(biometricAnimationState.sinePhase) * animHeight * 0.1); // Initial point with slight offset
                for (let j = 0; j < animWidth; j++) {
                    const x = animX + j;
                    const y = animY + animHeight / 2 + Math.sin((j / animWidth) * Math.PI * 4 + biometricAnimationState.sinePhase) * animHeight * 0.3;
                    context.lineTo(x, y);
                }
                context.stroke();
            } else if (animType === 2) { // Heartbeat
                context.strokeStyle = 'rgba(255, 255, 255, 0.7)'; // White color, slightly more opaque
                context.lineWidth = 3; // Thicker lines
                const hbHeight = animHeight * 0.4;
                const hbCenterY = animY + animHeight / 2;

                context.moveTo(animX, hbCenterY);
                context.lineTo(animX + animWidth * 0.1, hbCenterY);
                context.lineTo(animX + animWidth * 0.2, hbCenterY - hbHeight * 0.8); // Q
                context.lineTo(animX + animWidth * 0.25, hbCenterY + hbHeight); // R
                context.lineTo(animX + animWidth * 0.3, hbCenterY - hbHeight * 0.3); // S
                context.lineTo(animX + animWidth * 0.4, hbCenterY); // End of QRS
                context.lineTo(animX + animWidth * 0.6, hbCenterY);
                context.lineTo(animX + animWidth * 0.7, hbCenterY - hbHeight * 0.2); // T wave peak
                context.lineTo(animX + animWidth * 0.8, hbCenterY);
                context.lineTo(animX + animWidth, hbCenterY);
                context.stroke();

                if (biometricAnimationState.heartbeatPulse) {
                    context.fillStyle = 'rgba(255, 255, 255, 0.2)';
                    context.fillRect(animX, animY, animWidth, animHeight);
                }
            }
            context.restore();
        }

        // Add diagnostic text captions in black boxes
        if (Math.random() < 0.3) { // 30% chance to add a diagnostic caption
            const caption = DIAGNOSTIC_CAPTIONS[Math.floor(Math.random() * DIAGNOSTIC_CAPTIONS.length)];
            context.font = `bold 24px 'Courier New', monospace`; // Smaller font for captions (48 / 2 = 24)
            context.textAlign = 'left';
            const captionWidth = context.measureText(caption).width;
            const captionHeight = 24 * 1.2; // Approximate height

            // Position the caption randomly over the line, ensuring it's within bounds
            const captionX = (canvas.width * 0.1) + (Math.random() * (canvas.width * 0.7 - captionWidth));
            const captionY = yPos - (captionHeight / 2) + (Math.random() - 0.5) * (BIOMETRIC_MARQUEE_LINE_HEIGHT * 0.5);

            // Draw black box
            const padding = 10;
            context.fillStyle = 'black';
            context.fillRect(captionX - padding, captionY - captionHeight * 0.7, captionWidth + padding * 2, captionHeight + padding);

            // Draw white text
            context.fillStyle = 'white';
            context.fillText(caption, captionX, captionY);
        }
    }

    biometricMarqueeTexture.needsUpdate = true;
}

function shuffleArray(array) {
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
    }
    return array;
}

function createBloodTextTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    let maxWidth = 0;
    context.font = `bold ${BLOOD_TEXT_FONT_SIZE}px 'Impact', sans-serif`;
    BLOOD_TEXT_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    canvas.width = maxWidth + 100; // Add padding
    canvas.height = BLOOD_TEXT_LINE_HEIGHT * (BLOOD_TEXT_TOTAL_LINES * 2); // Double height for scrolling

    bloodTexture = new THREE.CanvasTexture(canvas);
    bloodTexture.wrapS = THREE.RepeatWrapping;
    bloodTexture.wrapT = THREE.RepeatWrapping;
    bloodTexture.needsUpdate = true;
    return bloodTexture;
}

function updateBloodTextTexture() {
    if (!bloodTexture) return;

    const canvas = bloodTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    context.fillStyle = 'rgba(0, 0, 0, 0.0)'; // Transparent background
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `bold ${BLOOD_TEXT_FONT_SIZE}px 'Impact', sans-serif`;
    context.fillStyle = 'white'; // White text for contrast
    context.textAlign = 'center';

    const singleSetHeight = BLOOD_TEXT_LINE_HEIGHT * BLOOD_TEXT_TOTAL_LINES;

    // Draw lines, repeating them to create a seamless loop
    for (let i = 0; i < BLOOD_TEXT_TOTAL_LINES * 2; i++) { // Draw two sets of lines
        const phraseIndex = i % shuffledBloodPhrases.length;
        const line = shuffledBloodPhrases[phraseIndex];

        let yPos = (i * BLOOD_TEXT_LINE_HEIGHT) + bloodScrollOffset;

        // When the first set of phrases has scrolled completely off the top of the canvas,
        // wrap it around to the bottom, effectively creating a continuous loop.
        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 3; // Move it to the bottom of the second set
            shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]); // Reshuffle phrases on loop
        }

        context.fillText(line, canvas.width / 2, yPos);
    }

    bloodTexture.needsUpdate = true;
}

function createRedactedGlitchTexture() {
    const canvas = document.createElement('canvas');
    const context = canvas.getContext('2d');

    let maxWidth = 0;
    context.font = `${REDACTED_GLITCH_FONT_SIZE}px 'Courier New', monospace`;
    REDACTED_GLITCH_PHRASES.forEach(phrase => {
        maxWidth = Math.max(maxWidth, context.measureText(phrase).width);
    });

    canvas.width = maxWidth + 50; // Add padding
    canvas.height = REDACTED_GLITCH_LINE_HEIGHT * (REDACTED_GLITCH_TOTAL_LINES * 2); // Double for seamless scrolling

    redactedGlitchTexture = new THREE.CanvasTexture(canvas);
    redactedGlitchTexture.wrapS = THREE.RepeatWrapping;
    redactedGlitchTexture.wrapT = THREE.RepeatWrapping;
    redactedGlitchTexture.needsUpdate = true;
    return redactedGlitchTexture;
}

function updateRedactedGlitchTexture() {
    if (!redactedGlitchTexture) return;

    const canvas = redactedGlitchTexture.image;
    const context = canvas.getContext('2d');

    context.clearRect(0, 0, canvas.width, canvas.height);
    // Change background to orange (#FFAC1C) for REDACTED GLITCH
    context.fillStyle = '#FFAC1C';
    context.fillRect(0, 0, canvas.width, canvas.height);

    context.font = `${REDACTED_GLITCH_FONT_SIZE}px 'Courier New', monospace`;
    context.textAlign = 'left';

    const singleSetHeight = REDACTED_GLITCH_LINE_HEIGHT * REDACTED_GLITCH_TOTAL_LINES;

    for (let i = 0; i < REDACTED_GLITCH_TOTAL_LINES * 2; i++) {
        const phraseDataIndex = i % redactedGlitchPhraseData.length; // Use the new data structure
        const phraseData = redactedGlitchPhraseData[phraseDataIndex];
        const line = phraseData.text;
        const redactedWordIndices = phraseData.redactedWordIndices;

        let yPos = (i * REDACTED_GLITCH_LINE_HEIGHT) + redactedGlitchScrollOffset;

        if (yPos < -singleSetHeight) {
            yPos += singleSetHeight * 2;
        }

        // Draw text in black so it appears black on the orange background.
        context.fillStyle = 'black';
        context.fillText(line, 10, yPos + REDACTED_GLITCH_FONT_SIZE); // Add padding

        // Draw redaction bars (black rectangles on orange background)
        if (redactedWordIndices.length > 0) {
            const words = line.split(/(\s+)/); // Split by one or more spaces, keeping spaces
            let currentX = 10; // Start X for text (accounting for padding)

            for (let j = 0; j < words.length; j++) {
                const word = words[j];
                const wordWidth = context.measureText(word).width;

                if (!/\s+/.test(word) && redactedWordIndices.includes(j)) { // If it's a word and flagged for redaction
                    // Draw a black rectangle over the selected words
                    context.fillStyle = 'black';
                    context.fillRect(currentX, yPos + REDACTED_GLITCH_FONT_SIZE * 0.2, wordWidth, REDACTED_GLITCH_FONT_SIZE * 0.9);

                    // Optionally draw a border around the redacted area to make it more pronounced
                    context.strokeStyle = 'black'; // Black border
                    context.lineWidth = 2;
                    context.strokeRect(currentX, yPos + REDACTED_GLITCH_FONT_SIZE * 0.2, wordWidth, REDACTED_GLITCH_FONT_SIZE * 0.9);
                }
                currentX += wordWidth;
            }
        }
    }

    redactedGlitchTexture.needsUpdate = true;
}

function resetCameraToGlobalStart() {
    // Ensure all camera motion flags are off
    cameraAnimationActive = false;
    effectControls.cameraAnimation = false;
    effectControls.yRotation = false;

    // Reset UI state for camera controls
    updateUIButtonState('cameraAnimation', false);
    updateUIButtonState('yRotation', false);

    // Hard reset camera position and look-at target to initial load values
    camera.position.copy(initialGlobalCameraPos);
    controls.target.copy(initialGlobalCameraLookAt);
    camera.lookAt(controls.target);
    controls.enabled = true; // Re-enable orbit controls
    controls.update(); // Ensure controls are updated after manual camera set

    cameraAnimationState = 'idle';
    assetsVisitedCount = 0;
    yRotationStartTime = 0; // Reset Y-rotation auto-start timer
}

function stopCameraAnimationAndReset() {
    // This function's primary role is to stop active camera motion (FLY or 3D)
    // and re-enable OrbitControls, without forcing a position reset (unless explicitly requested by RESET button).
    
    if (cameraAnimationActive || effectControls.yRotation) {
        cameraAnimationActive = false;
        effectControls.cameraAnimation = false;
        effectControls.yRotation = false;

        updateUIButtonState('cameraAnimation', false);
        updateUIButtonState('yRotation', false);

        // Keep current position, just stop the automatic movement
        controls.enabled = true; 
        controls.update(); 

        cameraAnimationState = 'idle';
        assetsVisitedCount = 0;
    }
    yRotationStartTime = 0; // Reset Y-rotation auto-start timer on interaction
}

function resetPiecesToOriginalPositions() {
    // 1. Turn off all effects FIRST to ensure a clean visual state
    turnOffAllEffects();

    // 2. Remove all current meshes from the scene
    scene.children.slice().forEach(object => {
        if (object.userData && object.userData.id) {
             scene.remove(object);
             if (object.geometry) object.geometry.dispose();
             if (object.material) {
                 if (Array.isArray(object.material)) {
                     object.material.forEach(m => m.dispose());
                 } else {
                     object.material.dispose();
                 }
             }
        }
    });

    draggableObjects = []; // Clear the array
    cameraAnimationTargets = []; // Clear camera animation targets

    // Reset specific global references
    dogecoinRef = null;
    spacexRef = null;
    rightEyeMesh = null;
    leftEyeMesh = null;
    rightEyeRedactionRect = null;
    leftEyeRedactionRect = null;
    backgroundMesh = null; // Also reset background mesh reference
    
    // Remove existing text meshes before re-adding to avoid duplicates and ensure clean state
    if (marqueeTextMesh) { marqueeTextMesh.geometry.dispose(); marqueeTextMesh.material.dispose(); marqueeTextMesh = null; }
    if (biometricMarqueeTextMesh) { biometricMarqueeTextMesh.geometry.dispose(); biometricMarqueeTextMesh.material.dispose(); biometricMarqueeTextMesh = null; }
    if (bloodTextMesh) { bloodTextMesh.geometry.dispose(); bloodTextMesh.material.dispose(); bloodTextMesh = null; }
    if (redactedGlitchTextMesh) { redactedGlitchTextMesh.geometry.dispose(); redactedGlitchTextMesh.material.dispose(); redactedGlitchTextMesh = null; }

    // 3. Reset the "removed" flag for all assets in the config
    initialAssetConfigs.forEach(config => {
        config.removed = false;
    });

    // Re-add all assets from their initial configurations
    const textureLoader = new THREE.TextureLoader();
    textureLoader.setCrossOrigin(''); // Set cross-origin for texture loading

    // Base scale factor to make images viewable at a reasonable size
    const baseScale = 0.005; 

    // Helper function for loading textures with best practices
    const loadTexture = (url, callback) => {
        textureLoader.load(url, (texture) => {
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            callback(texture);
        }, undefined, (error) => {
            console.error('Error loading texture:', url, error);
            // Fallback to placeholder
            const placeholderCanvas = document.createElement('canvas');
            placeholderCanvas.width = 1;
            placeholderCanvas.height = 1;
            const placeholderContext = placeholderCanvas.getContext('2d');
            placeholderContext.fillStyle = 'red';
            placeholderContext.fillRect(0, 0, 1, 1);
            const placeholderTexture = new THREE.CanvasTexture(placeholderCanvas);
            callback(placeholderTexture);
        });
    };
    
    let loadedAssetsCount = 0;
    const totalAssetsToLoad = initialAssetConfigs.length + 3; // +3 for doge original, tesla, x logo

    // Function to handle the complex, dependent loading after core assets are ready
    const handleDependentLoading = () => {
        // Ensure all necessary textures for swapping are loaded before proceeding
        if (!dogecoinOriginalTexture || !teslaTexture || !xLogoTexture) {
            return; // Wait for all textures
        }
        
        // --- 3.1. Load and Position Dogecoin/Tesla (Using FIXED initialPosition) ---
        const dogecoinConfig = initialAssetConfigs.find(c => c.id === 'dogecoin');
        if (dogecoinConfig && !dogecoinConfig.removed) {
            // Re-create the Tesla Greyscale Contrast Material
            teslaGreyscaleContrastMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    tDiffuse: { value: teslaTexture },
                    contrast: { value: GreyscaleContrastShader.uniforms.contrast.value }
                },
                vertexShader: GreyscaleContrastShader.vertexShader,
                fragmentShader: GreyscaleContrastShader.fragmentShader,
                transparent: true,
                alphaTest: 0.5
            });

            // Re-create Dogecoin/Tesla mesh
            const material = teslaGreyscaleContrastMaterial;
            const dogecoinScaleFactor = 0.7;
            const planeWidth = teslaTexture.image.width * baseScale * dogecoinScaleFactor;
            const planeHeight = teslaTexture.image.height * baseScale * dogecoinScaleFactor;
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const dogecoin = new THREE.Mesh(geometry, material);
            
            // Set the position using the FIXED initialPosition stored in the config
            dogecoin.position.copy(dogecoinConfig.initialPosition);

            dogecoin.userData.currentLayer = dogecoinConfig.initialLayer;
            dogecoin.userData.initialPosition = dogecoinConfig.initialPosition.clone();
            dogecoin.userData.initialLayer = dogecoinConfig.initialLayer;
            dogecoin.userData.originalTexture = dogecoinOriginalTexture;
            dogecoin.userData.teslaTexture = teslaTexture;
            dogecoin.userData.id = 'dogecoin';
            dogecoin.userData.initialScale = { width: planeWidth, height: planeHeight };
            scene.add(dogecoin);
            draggableObjects.push(dogecoin);
            cameraAnimationTargets.push(dogecoin);
            dogecoinRef = dogecoin;
        }

        // --- 3.2. Load and Position Fiat Worthless (Using FIXED initialPosition) ---
        const fiatWorthlessConfig = initialAssetConfigs.find(c => c.id === 'fiatWorthless');
        if (fiatWorthlessConfig && !fiatWorthlessConfig.removed) {
            loadTexture(fiatWorthlessConfig.url, (texture) => {
                const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                const aspectRatio = texture.image.width / texture.image.height;
                const fiatWorthlessHeight = 0.3; // Fixed height
                const fiatWorthlessWidth = fiatWorthlessHeight * aspectRatio;
                const geometry = new THREE.PlaneGeometry(fiatWorthlessWidth, fiatWorthlessHeight);
                const fiatWorthless = new THREE.Mesh(geometry, material);

                // Set position using the FIXED initialPosition stored in the config
                fiatWorthless.position.copy(fiatWorthlessConfig.initialPosition);

                fiatWorthless.userData.currentLayer = fiatWorthlessConfig.initialLayer;
                fiatWorthless.userData.initialPosition = fiatWorthlessConfig.initialPosition.clone();
                fiatWorthless.userData.initialLayer = fiatWorthlessConfig.initialLayer;
                fiatWorthless.userData.id = 'fiatWorthless';
                fiatWorthless.userData.initialScale = { width: fiatWorthlessWidth, height: fiatWorthlessHeight };
                scene.add(fiatWorthless);
                draggableObjects.push(fiatWorthless);
                cameraAnimationTargets.push(fiatWorthless);
            });
        }
        
        // --- 3.3. Load and Position Signature (Using FIXED initialPosition) ---
        const signatureConfig = initialAssetConfigs.find(c => c.id === 'signature');
        if (signatureConfig && !signatureConfig.removed) {
            loadTexture(signatureConfig.url, (texture) => {
                const signatureMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                const signatureAspectRatio = texture.image.width / texture.image.height;
                const signatureHeight = 1.0; // Fixed height
                const signatureWidth = signatureHeight * signatureAspectRatio;
                const signatureGeometry = new THREE.PlaneGeometry(signatureWidth, signatureHeight);
                const signature = new THREE.Mesh(signatureGeometry, signatureMaterial);

                // Set position using the FIXED initialPosition stored in the config
                signature.position.copy(signatureConfig.initialPosition);

                signature.userData.currentLayer = signatureConfig.initialLayer;
                signature.userData.id = 'signature';
                signature.userData.initialScale = { width: signatureWidth, height: signatureHeight };
                signature.userData.initialPosition = signatureConfig.initialPosition.clone(); // Ensure initialPosition is stored
                signature.userData.initialLayer = signatureConfig.initialLayer;
                scene.add(signature);
            });
        }
        
        // 4. Reset camera and controls
        resetCameraToGlobalStart(); // Use the dedicated hard reset function

        // 5. Reset background color to default dark gray
        renderer.setClearColor(0x1e1e1e); // Default dark gray
        
        // 6. Force positioning of other dynamic elements like ear and marquee texts
        onWindowResize();
    };

    // Load necessary swap textures first
    loadTexture(URL_DOGECOIN_ORIGINAL, (tex) => { dogecoinOriginalTexture = tex; loadedAssetsCount++; });
    loadTexture(URL_TESLA_SWAP, (tex) => { teslaTexture = tex; loadedAssetsCount++; });
    loadTexture(URL_X_LOGO_SWAP, (tex) => { xLogoTexture = tex; loadedAssetsCount++; });

    // Separate loading loop for all other assets
    initialAssetConfigs.forEach(config => {
        if (config.removed || config.id === 'dogecoin' || config.id === 'fiatWorthless' || config.id === 'signature') {
            return; // Skip assets that are loaded dependently or removed
        }
        
        let material, geometry, mesh;

        switch (config.type) {
            case 'background':
                loadTexture(config.url, (texture) => {
                    material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
                    const aspectRatio = texture.image.width / texture.image.height;
                    const planeHeight = 10 * config.scaleFactor;
                    const planeWidth = planeHeight * aspectRatio;
                    geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
                    backgroundMesh = new THREE.Mesh(geometry, material);
                    backgroundMesh.position.copy(config.initialPosition);
                    backgroundMesh.userData.initialPosition = config.initialPosition.clone();
                    backgroundMesh.userData.initialLayer = config.initialLayer;
                    backgroundMesh.userData.id = config.id;
                    scene.add(backgroundMesh);
                    cameraAnimationTargets.push(backgroundMesh);
                    loadedAssetsCount++;
                });
                break;
            case 'image':
                loadTexture(config.url, (texture) => {
                    let currentMaterial;
                    const initialPlaneWidth = texture.image.width * baseScale * config.scaleFactor;
                    const initialPlaneHeight = texture.image.height * baseScale * config.scaleFactor;

                    if (config.id === 'spacex') {
                        currentMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                        spacexRef = new THREE.Mesh(new THREE.PlaneGeometry(initialPlaneWidth, initialPlaneHeight), currentMaterial);
                        spacexOriginalTexture = texture;
                        spacexRef.userData.originalTexture = spacexOriginalTexture;
                        spacexRef.userData.xLogoTexture = xLogoTexture; // Should be loaded via loadTexture above
                        spacexRef.userData.originalWidth = initialPlaneWidth;
                        spacexRef.userData.originalHeight = initialPlaneHeight;
                        mesh = spacexRef;
                    } else {
                        currentMaterial = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                        geometry = new THREE.PlaneGeometry(initialPlaneWidth, initialPlaneHeight);
                        mesh = new THREE.Mesh(geometry, currentMaterial);
                    }

                    // Set properties common to all image meshes
                    mesh.position.copy(config.initialPosition);
                    mesh.rotation.copy(config.initialRotation ? config.initialRotation : new THREE.Euler());
                    mesh.userData.currentLayer = config.initialLayer;
                    mesh.userData.initialPosition = config.initialPosition.clone();
                    mesh.userData.initialLayer = config.initialLayer;
                    mesh.userData.id = config.id;
                    mesh.userData.initialScale = { width: initialPlaneWidth, height: initialPlaneHeight };

                    scene.add(mesh);
                    draggableObjects.push(mesh);
                    cameraAnimationTargets.push(mesh);

                    // Re-create redaction rectangles for eyes
                    if (config.id === 'rightEye') {
                        rightEyeMesh = mesh;
                        const redactionWidth = initialPlaneWidth * 1.2;
                        const redactionHeight = initialPlaneHeight * 0.4;
                        const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
                        const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                        rightEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
                        rightEyeRedactionRect.position.set(mesh.position.x, mesh.position.y, mesh.position.z + (1.5 * depthStep));
                        rightEyeRedactionRect.visible = false;
                        scene.add(rightEyeRedactionRect);
                    } else if (config.id === 'leftEye') {
                        leftEyeMesh = mesh;
                        const redactionWidth = initialPlaneWidth * 1.2;
                        const redactionHeight = initialPlaneHeight * 0.4; // FIX: Corrected typo from 'redaaactionHeight'
                        const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
                        const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
                        leftEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
                        leftEyeRedactionRect.position.set(mesh.position.x, mesh.position.y, mesh.position.z + (1.5 * depthStep));
                        leftEyeRedactionRect.visible = false;
                        scene.add(leftEyeRedactionRect);
                    }
                    loadedAssetsCount++;
                });
                break;
            case 'textMesh':
                // Re-initialize 3D text meshes (Marquee, Biometric, Blood, Redacted Glitch)
                // Note: Textures are created synchronously here, but meshes are loaded back into the scene
                // The geometry/material cloning ensures unique instances for the new scene
                if (config.id === 'marqueeTextMesh') {
                    marqueeTexture = createMarqueeTexture();
                    const newMarqueeMaterial = new THREE.MeshBasicMaterial({ map: marqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const newMarqueePlaneWidth = 20;
                    const newMarqueePlaneHeight = newMarqueePlaneWidth / (marqueeTexture.image.width / marqueeTexture.image.height);
                    const newMarqueeGeometry = new THREE.PlaneGeometry(newMarqueePlaneWidth, newMarqueePlaneHeight);
                    marqueeTextMesh = new THREE.Mesh(newMarqueeGeometry, newMarqueeMaterial);
                    marqueeTextMesh.position.copy(config.initialPosition);
                    marqueeTextMesh.userData.initialPosition = config.initialPosition.clone();
                    marqueeTextMesh.userData.initialLayer = config.initialLayer;
                    marqueeTextMesh.visible = false; // Always start hidden on reset
                    marqueeTextMesh.userData.id = config.id;
                    scene.add(marqueeTextMesh);
                    loadedAssetsCount++;
                } else if (config.id === 'biometricMarqueeTextMesh') {
                    biometricMarqueeTexture = createBiometricMarqueeTexture();
                    const newBiometricMarqueeMaterial = new THREE.MeshBasicMaterial({ map: biometricMarqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const newBiometricMarqueePlaneWidth = 20;
                    const newBiometricMarqueePlaneHeight = newBiometricMarqueePlaneWidth / (biometricMarqueeTexture.image.width / biometricMarqueeTexture.image.height);
                    const newBiometricMarqueeGeometry = new THREE.PlaneGeometry(newBiometricMarqueePlaneWidth, newBiometricMarqueePlaneHeight);
                    biometricMarqueeTextMesh = new THREE.Mesh(newBiometricMarqueeGeometry, newBiometricMarqueeMaterial);
                    biometricMarqueeTextMesh.position.copy(config.initialPosition);
                    biometricMarqueeTextMesh.userData.initialPosition = config.initialPosition.clone();
                    biometricMarqueeTextMesh.userData.initialLayer = config.initialLayer;
                    biometricMarqueeTextMesh.visible = false;
                    biometricMarqueeTextMesh.userData.id = config.id;
                    scene.add(biometricMarqueeTextMesh);
                    loadedAssetsCount++;
                } else if (config.id === 'bloodTextMesh') {
                    bloodTexture = createBloodTextTexture();
                    const newBloodTextMaterial = new THREE.MeshBasicMaterial({ map: bloodTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const newBloodTextPlaneWidth = 20;
                    const newBloodTextPlaneHeight = newBloodTextPlaneWidth / (bloodTexture.image.width / bloodTexture.image.height);
                    const newBloodTextGeometry = new THREE.PlaneGeometry(newBloodTextPlaneWidth, newBloodTextPlaneHeight);
                    bloodTextMesh = new THREE.Mesh(newBloodTextGeometry, newBloodTextMaterial);
                    bloodTextMesh.position.copy(config.initialPosition);
                    bloodTextMesh.userData.initialPosition = config.initialPosition.clone();
                    bloodTextMesh.userData.initialLayer = config.initialLayer;
                    bloodTextMesh.visible = false;
                    bloodTextMesh.userData.id = config.id;
                    scene.add(bloodTextMesh);
                    loadedAssetsCount++;
                } else if (config.id === 'redactedGlitchTextMesh') {
                    redactedGlitchTexture = createRedactedGlitchTexture();
                    const redactedGlitchMaterial = new THREE.MeshBasicMaterial({ map: redactedGlitchTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
                    const redactedGlitchPlaneWidth = 15;
                    const redactedGlitchPlaneHeight = redactedGlitchPlaneWidth / (redactedGlitchTexture.image.width / redactedGlitchTexture.image.height);
                    const newRedactedGlitchGeometry = new THREE.PlaneGeometry(redactedGlitchPlaneWidth, redactedGlitchPlaneHeight);
                    redactedGlitchTextMesh = new THREE.Mesh(newRedactedGlitchGeometry, redactedGlitchMaterial);
                    redactedGlitchTextMesh.position.copy(config.initialPosition);
                    redactedGlitchTextMesh.userData.initialPosition = config.initialPosition.clone();
                    redactedGlitchTextMesh.userData.initialLayer = config.initialLayer;
                    redactedGlitchTextMesh.visible = false;
                    redactedGlitchTextMesh.userData.id = config.id;
                    scene.add(redactedGlitchTextMesh);
                    initializeRedactedGlitchPhraseData();
                    loadedAssetsCount++;
                }
                break;
        }
    });
    
    // Use a small timeout to ensure dependent textures are loaded before calling handleDependentLoading
    // This is safer than relying on the async loadTexture to complete if the assets are cached.
    setTimeout(handleDependentLoading, 100);
}

function turnOffAllEffects() {
    // Deactivate all post-processing passes
    greyscalePass.enabled = false;
    thresholdPass.enabled = false;
    darkPass.enabled = false;
    pixelationPass.enabled = false;
    glitchPass.enabled = false;
    matrixPass.enabled = false;
    asciiPass.enabled = false;
    xrayPass.enabled = false;
    heatmapPass.enabled = false;
    bloodPass.enabled = false;
    cctvFeedPass.enabled = false;

    // Reset all effect control booleans to false
    for (const prop in effectControls) {
        if (effectControls.hasOwnProperty(prop)) {
            // Do not reset the brightness setting
            if (prop !== 'shadowBrightness') {
                effectControls[prop] = false;
            }
        }
    }

    // Update UI buttons to reflect inactive state
    updateUIButtonState('greyscale', false);
    updateUIButtonState('threshold', false);
    updateUIButtonState('shadow', false); // Updated from 'dark'
    updateUIButtonState('pixelation', false);
    updateUIButtonState('glitch', false);
    updateUIButtonState('matrix', false);
    updateUIButtonState('ascii', false);
    updateUIButtonState('xray', false);
    updateUIButtonState('heatmap', false);
    updateUIButtonState('blood', false);
    updateUIButtonState('cctvFeed', false);
    updateUIButtonState('yRotation', false);
    updateUIButtonState('cameraAnimation', false);
    updateUIButtonState('redacted', false);
    updateUIButtonState('redactedGlitch', false);
    updateUIButtonState('anon', false);
    updateUIButtonState('biometricMarquee', false);
    updateUIButtonState('og', false);
    updateUIButtonState('bloodText', false);
    updateUIButtonState('hacker', false); // Update hacker button state
    updateUIButtonState('surveillance', false); // Update surveillance button state
    updateUIButtonState('greed', false); // Update greed button state

    // Specific effect cleanups
    if (rightEyeRedactionRect) {
        rightEyeRedactionRect.visible = false;
        // Ensure redacted eyes are black when all effects are off
        rightEyeRedactionRect.material.color.setHex(0x000000);
    }
    if (leftEyeRedactionRect) {
        leftEyeRedactionRect.visible = false;
        // Ensure redacted eyes are black when all effects are off
        leftEyeRedactionRect.material.color.setHex(0x000000);
    }
    if (marqueeTextMesh) marqueeTextMesh.visible = false;
    if (biometricMarqueeTextMesh) biometricMarqueeTextMesh.visible = false;
    if (bloodTextMesh) bloodTextMesh.visible = false;
    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false;

    cameraAnimationActive = false;
    controls.enabled = true; // Re-enable orbit controls
    cameraAnimationState = 'idle';
    assetsVisitedCount = 0;

    yRotationStartTime = 0; // Reset Y-rotation auto-start timer
    
    // Reset background to default dark gray
    renderer.setClearColor(0x1e1e1e); // Default dark gray
}

// Cache for canvas contexts to read texture alpha values efficiently
const textureAlphaCanvasCache = new Map();

function getAlphaAtUV(texture, uv) {
    if (!texture || !texture.image || !uv) return 0;

    // Use cached canvas context if available
    let canvas, context;
    if (textureAlphaCanvasCache.has(texture.id)) {
        ({ canvas, context } = textureAlphaCanvasCache.get(texture.id));
    } else {
        canvas = document.createElement('canvas');
        context = canvas.getContext('2d');
        canvas.width = texture.image.width;
        canvas.height = texture.image.height;
        context.drawImage(texture.image, 0, 0);
        textureAlphaCanvasCache.set(texture.id, { canvas, context });
    }

    const x = Math.floor(uv.x * canvas.width);
    const y = Math.floor((1 - uv.y) * canvas.height); // Y-axis needs to be inverted for canvas

    // Ensure coordinates are within bounds
    if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
        return 0;
    }

    const pixelData = context.getImageData(x, y, 1, 1).data;
    return pixelData[3] / 255; // Alpha channel
}

function getBackgroundBounds(z) {
    if (!backgroundMesh) return null;
    
    // Calculate world height and width at the given Z-plane
    const distance_from_camera = camera.position.z - z;
    const world_height = 2 * distance_from_camera * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
    const world_width = world_height * camera.aspect;

    // The background mesh is centered at (0, 0) in world space (ignoring its own depth offset)
    // The background mesh's size is determined by its texture size and scale factor (1.10)
    const bgMeshWidth = backgroundMesh.geometry.parameters.width;
    const bgMeshHeight = backgroundMesh.geometry.parameters.height;
    
    // The background mesh is positioned at backgroundMesh.position.x/y/z.
    const bgX = backgroundMesh.position.x;
    const bgY = backgroundMesh.position.y;
    
    // The bounds of the background image in world coordinates (at its own Z-plane)
    const minX = bgX - bgMeshWidth / 2;
    const maxX = bgX + bgMeshWidth / 2;
    const minY = bgY - bgMeshHeight / 2;
    const maxY = bgY + bgMeshHeight / 2;
    
    return { minX, maxX, minY, maxY, width: bgMeshWidth, height: bgMeshHeight };
}

// Function to calculate Dogecoin/Tesla position (extracted from init/onWindowResize)
const calculateDogecoinAndFiatPosition = (bgMesh, dogeMesh, dogeTexture, fiatMesh, fiatTexture, dogeConfig, fiatConfig) => {
    if (!bgMesh || !dogeMesh || !dogeTexture || !fiatMesh || !fiatTexture) return;

    const bgBounds = getBackgroundBounds(bgMesh.position.z);
    if (!bgBounds) return;

    const dogeWidth = dogeMesh.geometry.parameters.width;
    const dogeHeight = dogeMesh.geometry.parameters.height;

    // Target X: Same as ROCKET_INITIAL_X
    const targetX = ROCKET_INITIAL_X;

    // Target Y: Bottom edge of the background mesh + half the doge height + padding
    const paddingY = 0.5;
    const targetY = bgBounds.minY + dogeHeight / 2 + paddingY;
    
    // Ensure Z remains at dogecoinZ
    const dogecoinZ = (dogeConfig.initialLayer - 1) * depthStep;

    const dogecoinFinalPosition = new THREE.Vector3(targetX, targetY, dogecoinZ);

    dogeMesh.position.copy(dogecoinFinalPosition);
    
    // Update the initial position in config
    dogeConfig.initialPosition.copy(dogecoinFinalPosition);

    // --- Fiat Worthless Position ---
    const fiatWorthlessNewLayer = dogeConfig.initialLayer + 2; 
    const fiatWorthlessNewZ = (fiatWorthlessNewLayer - 1) * depthStep;

    // Position it slightly below and to the right of the dogecoin/tesla logo
    const fiatWorthlessInitialWorldX = dogeMesh.position.x + dogeMesh.geometry.parameters.width * 1.1 + .25; 
    const fiatWorthlessInitialWorldY = dogeMesh.position.y - dogeMesh.geometry.parameters.height * .11 - 0;
    const fiatWorthlessFinalPosition = new THREE.Vector3(fiatWorthlessInitialWorldX, fiatWorthlessInitialWorldY, fiatWorthlessNewZ);

    fiatMesh.position.copy(fiatWorthlessFinalPosition);
    fiatConfig.initialPosition.copy(fiatWorthlessFinalPosition);
};

function init() {
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 10; // Zoomed out to see the full canvas
    camera.userData.yRotationAngle = 0; // Initialize angle for Y-axis camera rotation

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x1e1e1e); // Dark gray background
    renderer.outputColorSpace = THREE.SRGBColorSpace; // THREE.js best practice: set output color space
    document.body.appendChild(renderer.domElement);

    renderer.sortObjects = true; // Enable object sorting for correct transparency rendering

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 20;
    controls.maxPolarAngle = Math.PI / 2;
    controls.addEventListener('change', () => {
        stopCameraAnimationAndReset(); // Stop animation on camera control interaction
    });

    // Store initial global camera position and look-at target
    initialGlobalCameraPos.copy(camera.position);
    initialGlobalCameraLookAt.copy(controls.target);

    // Post-processing setup
    composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));

    greyscalePass = new ShaderPass(GreyScaleShader);
    composer.addPass(greyscalePass);
    greyscalePass.enabled = effectControls.greyscale;

    thresholdPass = new ShaderPass(ThresholdShader);
    thresholdPass.uniforms['threshold'].value = effectControls.thresholdValue;
    composer.addPass(thresholdPass);
    thresholdPass.enabled = effectControls.threshold;

    darkPass = new ShaderPass(DarkShader);
    darkPass.uniforms['threshold'].value = effectControls.thresholdValue;
    darkPass.uniforms['brightnessMultiplier'].value = effectControls.shadowBrightness; // Set initial brightness
    composer.addPass(darkPass);
    darkPass.enabled = effectControls.shadow;

    pixelationPass = new ShaderPass(PixelationShader);
    pixelationPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    pixelationPass.uniforms['pixelSize'].value = effectControls.pixelSize;
    composer.addPass(pixelationPass);
    pixelationPass.enabled = effectControls.pixelation;

    glitchPass = new GlitchPass();
    composer.addPass(glitchPass);
    glitchPass.enabled = effectControls.glitch;

    matrixPass = new ShaderPass(MatrixShader);
    composer.addPass(matrixPass);
    matrixPass.enabled = effectControls.matrix;

    asciiPass = new ShaderPass(ASCIIShader);
    asciiPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    asciiPass.uniforms['pixelSize'].value = effectControls.pixelSize;
    composer.addPass(asciiPass);
    asciiPass.enabled = false;

    xrayPass = new ShaderPass(XRayShader);
    composer.addPass(xrayPass);
    xrayPass.enabled = effectControls.xray;

    heatmapPass = new ShaderPass(HeatmapShader);
    composer.addPass(heatmapPass);
    heatmapPass.enabled = effectControls.heatmap;

    bloodPass = new ShaderPass(BloodShader);
    composer.addPass(bloodPass);
    bloodPass.enabled = effectControls.blood;

    cctvFeedPass = new ShaderPass(CCTVFeedShader);
    cctvFeedPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    cctvFeedPass.uniforms['time'].value = 0.0;
    composer.addPass(cctvFeedPass);
    cctvFeedPass.enabled = effectControls.cctvFeed;

    raycaster = new THREE.Raycaster();
    mouse = new THREE.Vector2();

    const textureLoader = new THREE.TextureLoader();
    textureLoader.setCrossOrigin(''); // FIX: Enable CORS for external texture loading

    // Base scale factor to make images viewable at a reasonable size
    const baseScale = 0.005;

    // Helper function for loading textures with best practices
    const loadTexture = (url, callback) => {
        textureLoader.load(url, (texture) => {
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;
            texture.generateMipmaps = false;
            texture.anisotropy = renderer.capabilities.getMaxAnisotropy();
            callback(texture);
        }, undefined, (error) => {
            console.error('Error loading texture:', url, error);
            // Optionally use a placeholder texture or handle the error gracefully here
            const placeholderCanvas = document.createElement('canvas');
            placeholderCanvas.width = 1;
            placeholderCanvas.height = 1;
            const placeholderContext = placeholderCanvas.getContext('2d');
            placeholderContext.fillStyle = 'red';
            placeholderContext.fillRect(0, 0, 1, 1);
            const placeholderTexture = new THREE.CanvasTexture(placeholderCanvas);
            callback(placeholderTexture);
        });
    };

    // Load and add the background image
    initialAssetConfigs.push({
        id: 'background',
        type: 'background',
        url: URL_BACKGROUND,
        initialPosition: new THREE.Vector3(0, 0, -4 * depthStep),
        initialLayer: -4,
        scaleFactor: 1.10,
        removed: false // Add removed flag
    });
    loadTexture(URL_BACKGROUND, (texture) => {
        const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide });
        const aspectRatio = texture.image.width / texture.image.height;
        const scaleFactor = 1.10;
        const planeHeight = 10 * scaleFactor;
        const planeWidth = planeHeight * aspectRatio;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight); // Fixed: Declare geometry here
        backgroundMesh = new THREE.Mesh(geometry, material);
        backgroundMesh.position.z = -4 * depthStep;
        backgroundMesh.userData.initialPosition = backgroundMesh.position.clone();
        backgroundMesh.userData.initialLayer = -4;
        backgroundMesh.userData.id = 'background'; // Added ID
        scene.add(backgroundMesh);
        cameraAnimationTargets.push(backgroundMesh);
    });

    // Load and add the forehead image
    initialAssetConfigs.push({
        id: 'forehead',
        type: 'image',
        url: URL_FOREHEAD,
        initialPosition: new THREE.Vector3(0, (0.5 + 2.666) * 1.10, (2 - 1) * depthStep),
        initialLayer: 2,
        baseScale: baseScale,
        scaleFactor: 1.15,
        removed: false // Add removed flag
    });
    loadTexture(URL_FOREHEAD, (texture) => {
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const scaleFactor = 1.15;
        const planeWidth = texture.image.width * baseScale * scaleFactor;
        const planeHeight = texture.image.height * baseScale * scaleFactor;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const forehead = new THREE.Mesh(geometry, material);
        forehead.position.set(0, (0.5 + 2.666) * 1.10, (2 - 1) * depthStep);
        forehead.userData.currentLayer = 2;
        forehead.userData.initialPosition = forehead.position.clone();
        forehead.userData.initialLayer = 2;
        forehead.userData.id = 'forehead'; // Added ID
        forehead.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(forehead);
        draggableObjects.push(forehead);
        cameraAnimationTargets.push(forehead);
    });

    // Load and add the right eye image
    initialAssetConfigs.push({
        id: 'rightEye',
        type: 'image',
        url: URL_RIGHT_EYE,
        initialPosition: new THREE.Vector3(-0.84 * 1.2 * 1.2, (0.175 * 1.15 * 1.20 * 3) + 2.0 - 1.0, (7 - 1) * depthStep),
        initialLayer: 7,
        baseScale: baseScale,
        scaleFactor: 1.0,
        removed: false // Add removed flag
    });
    loadTexture(URL_RIGHT_EYE, (texture) => {
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const planeWidth = texture.image.width * baseScale;
        const planeHeight = texture.image.height * baseScale;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        rightEyeMesh = new THREE.Mesh(geometry, material);
        rightEyeMesh.position.set(-0.84 * 1.2 * 1.2, (0.175 * 1.15 * 1.20 * 3) + 2.0 - 1.0, (7 - 1) * depthStep);
        rightEyeMesh.userData.currentLayer = 7;
        rightEyeMesh.userData.initialPosition = rightEyeMesh.position.clone();
        rightEyeMesh.userData.initialLayer = 7;
        rightEyeMesh.userData.id = 'rightEye'; // Added ID
        rightEyeMesh.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(rightEyeMesh);
        draggableObjects.push(rightEyeMesh);
        cameraAnimationTargets.push(rightEyeMesh);

        // Create and add the redaction rectangle for the right eye
        const redactionWidth = planeWidth * 1.2;
        const redactionHeight = planeHeight * 0.4; // Increased height by 15% (0.23 * 1.15)
        // Set initial material color to black (0x000000)
        const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
        const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        rightEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
        // Position it at the same X, Y as the eye, but 1.5 levels in front
        rightEyeRedactionRect.position.set(
            rightEyeMesh.position.x,
            rightEyeMesh.position.y,
            rightEyeMesh.position.z + (1.5 * depthStep)
        );
        rightEyeRedactionRect.visible = false;
        scene.add(rightEyeRedactionRect);
    });

    // Load and add the mouth image
    initialAssetConfigs.push({
        id: 'mouth',
        type: 'image',
        url: URL_MOUTH,
        initialPosition: new THREE.Vector3(0, -1.5, (9 - 1) * depthStep),
        initialLayer: 9,
        baseScale: baseScale,
        scaleFactor: 1.0,
        removed: false // Add removed flag
    });
    loadTexture(URL_MOUTH, (texture) => {
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const planeWidth = texture.image.width * baseScale;
        const planeHeight = texture.image.height * baseScale;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const mouth = new THREE.Mesh(geometry, material);
        mouth.position.set(0, -1.5, (9 - 1) * depthStep);
        mouth.userData.currentLayer = 9;
        mouth.userData.initialPosition = mouth.position.clone();
        mouth.userData.initialLayer = 9;
        mouth.userData.id = 'mouth'; // Added ID
        mouth.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(mouth);
        draggableObjects.push(mouth);
        cameraAnimationTargets.push(mouth);
    });

    // Load and add the ear image
    const earNewLayer = 5;
    const earNewZ = (earNewLayer - 1) * depthStep;
    // We calculate the initial X position based on screen size, but we need to run this calculation
    // inside the texture loader callback *or* inside onWindowResize if the mesh is available.
    // Since init calls onWindowResize, we set a temporary position here and let onWindowResize handle the final responsive positioning.
    const earInitialX = -2.5; // Temporary initial X position before onWindowResize runs
    initialAssetConfigs.push({
        id: 'ear',
        type: 'image',
        url: URL_EAR,
        initialPosition: new THREE.Vector3(earInitialX, 1.5, earNewZ),
        initialRotation: new THREE.Euler(0, THREE.MathUtils.degToRad(-15), 0),
        baseScale: baseScale,
        scaleFactor: 1.0,
        removed: false // Add removed flag
    });
    loadTexture(URL_EAR, (texture) => {
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const planeWidth = texture.image.width * baseScale;
        const planeHeight = texture.image.height * baseScale;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const ear = new THREE.Mesh(geometry, material);

        // Set position using the initial X from config (will be corrected by onWindowResize shortly)
        const earConfig = initialAssetConfigs.find(c => c.id === 'ear');
        ear.position.copy(earConfig.initialPosition);
        ear.rotation.y = THREE.MathUtils.degToRad(-15); // Pivot ear on y axis -15%
        ear.userData.currentLayer = earNewLayer;
        // NOTE: We do NOT set ear.userData.initialPosition here to the temporary value.
        // We let onWindowResize calculate the correct responsive position and set it there.
        // This prevents the "moves slightly" issue on load since the final position is set immediately after the mesh is created (by onWindowResize).
        ear.userData.initialLayer = earNewLayer;
        ear.userData.id = 'ear'; // Added ID
        ear.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(ear);
        draggableObjects.push(ear);
        cameraAnimationTargets.push(ear);
        
        // **CRITICAL FIX:** Force the initial position calculation and storage immediately after the mesh is created.
        // This ensures the ear is placed correctly on load and the responsive position is stored as the initial position.
        updateEarPosition(ear, earConfig);
    });

    // Load and add the left eye image
    initialAssetConfigs.push({
        id: 'leftEye',
        type: 'image',
        url: URL_LEFT_EYE,
        initialPosition: new THREE.Vector3(0.84 * 1.2 * 1.2, (0.175 * 1.15 * 1.20 * 3) + 2.0 - 1.0, (9 - 1) * depthStep),
        initialLayer: 9,
        baseScale: baseScale,
        scaleFactor: 1.0,
        removed: false // Add removed flag
    });
    loadTexture(URL_LEFT_EYE, (texture) => {
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const planeWidth = texture.image.width * baseScale;
        const planeHeight = texture.image.height * baseScale;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        leftEyeMesh = new THREE.Mesh(geometry, material);
        leftEyeMesh.position.set(0.84 * 1.2 * 1.2, (0.175 * 1.15 * 1.20 * 3) + 2.0 - 1.0, (9 - 1) * depthStep);
        leftEyeMesh.userData.currentLayer = 9;
        leftEyeMesh.userData.initialPosition = leftEyeMesh.position.clone();
        leftEyeMesh.userData.initialLayer = 9;
        leftEyeMesh.userData.id = 'leftEye'; // Added ID
        leftEyeMesh.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(leftEyeMesh);
        draggableObjects.push(leftEyeMesh);
        cameraAnimationTargets.push(leftEyeMesh);

        // Create and add the redaction rectangle for the left eye
        const redactionWidth = planeWidth * 1.2;
        const redactionHeight = planeHeight * 0.4; // Increased height by 15% (0.23 * 1.15)
        // Set initial material color to black (0x000000)
        const redactionGeometry = new THREE.PlaneGeometry(redactionWidth, redactionHeight);
        const redactionMaterial = new THREE.MeshBasicMaterial({ color: 0x000000 });
        leftEyeRedactionRect = new THREE.Mesh(redactionGeometry, redactionMaterial);
        // Position it at the same X, Y as the eye, but 1.5 levels in front
        leftEyeRedactionRect.position.set(
            leftEyeMesh.position.x,
            leftEyeMesh.position.y,
            leftEyeMesh.position.z + (1.5 * depthStep)
        );
        leftEyeRedactionRect.visible = false;
        scene.add(leftEyeRedactionRect);
    });

    // Load SpaceX and X textures
    initialAssetConfigs.push({
        id: 'spacex',
        type: 'image',
        url: URL_SPACEX_ORIGINAL,
        originalTextureUrl: URL_SPACEX_ORIGINAL,
        swapTextureUrl: URL_X_LOGO_SWAP,
        initialPosition: new THREE.Vector3(0.5 + 1.0, -0.5, (7 - 1) * depthStep),
        initialLayer: 7,
        baseScale: baseScale,
        scaleFactor: 1.0, // This will be calculated from texture.image.width / height later
        removed: false // Add removed flag
    });
    loadTexture(URL_SPACEX_ORIGINAL, (spacexTex) => {
        spacexOriginalTexture = spacexTex;

        loadTexture(URL_X_LOGO_SWAP, (xTex) => {
            xLogoTexture = xTex;

            const material = new THREE.MeshBasicMaterial({ map: spacexOriginalTexture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
            const planeWidth = spacexOriginalTexture.image.width * baseScale;
            const planeHeight = spacexOriginalTexture.image.height * baseScale;
            const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
            const leftCheek = new THREE.Mesh(geometry, material);
            leftCheek.position.set(0.5 + 1.0, -0.5, (7 - 1) * depthStep);
            leftCheek.userData.currentLayer = 7;
            leftCheek.userData.initialPosition = leftCheek.position.clone();
            leftCheek.userData.initialLayer = 7;
            leftCheek.userData.originalTexture = spacexOriginalTexture; // Store original texture
            leftCheek.userData.xLogoTexture = xLogoTexture; // Store X logo texture
            leftCheek.userData.originalWidth = planeWidth; // Store original width
            leftCheek.userData.originalHeight = planeHeight; // Store original height
            leftCheek.userData.id = 'spacex'; // Added ID
            leftCheek.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
            scene.add(leftCheek);
            draggableObjects.push(leftCheek);
            cameraAnimationTargets.push(leftCheek);

            spacexRef = leftCheek; // Store reference to spacex mesh
        });
    });

    // Load and add the nose image
    initialAssetConfigs.push({
        id: 'nose',
        type: 'image',
        url: URL_NOSE,
        initialPosition: new THREE.Vector3(0, 0.8, (11 - 1) * depthStep),
        initialLayer: 11,
        baseScale: baseScale,
        scaleFactor: 0.93,
        removed: false // Add removed flag
    });
    loadTexture(URL_NOSE, (texture) => {
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const scaleFactor = 0.93;
        const planeWidth = texture.image.width * baseScale * scaleFactor;
        const planeHeight = texture.image.height * baseScale * scaleFactor;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const nose = new THREE.Mesh(geometry, material);
        nose.position.set(0, 0.8, (11 - 1) * depthStep);
        nose.userData.currentLayer = 11;
        nose.userData.initialPosition = nose.position.clone();
        nose.userData.initialLayer = 11;
        nose.userData.id = 'nose'; // Added ID
        nose.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(nose);
        draggableObjects.push(nose);
        cameraAnimationTargets.push(nose);
    });

    // Load and add the hair image
    initialAssetConfigs.push({
        id: 'hair',
        type: 'image',
        url: URL_HAIR,
        initialPosition: new THREE.Vector3(0, 3.5 * 1.10, (4 - 1) * depthStep),
        initialLayer: 4,
        baseScale: baseScale,
        scaleFactor: 1.15,
        removed: false // Add removed flag
    });
    loadTexture(URL_HAIR, (texture) => {
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const scaleFactor = 1.15;
        const planeWidth = texture.image.width * baseScale * scaleFactor;
        const planeHeight = texture.image.height * baseScale * scaleFactor;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const hair = new THREE.Mesh(geometry, material);
        hair.position.set(0, 3.5 * 1.10, (4 - 1) * depthStep);
        hair.userData.currentLayer = 4;
        hair.userData.initialPosition = hair.position.clone();
        hair.userData.initialLayer = 4;
        hair.userData.id = 'hair'; // Added ID
        hair.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(hair);
        draggableObjects.push(hair);
        cameraAnimationTargets.push(hair);
    });

    // Load and add the blue bill image
    initialAssetConfigs.push({
        id: 'blueBill',
        type: 'image',
        url: URL_BLUE_BILL,
        initialPosition: new THREE.Vector3(2, -2, (3 - 1) * depthStep),
        initialLayer: 10,
        baseScale: baseScale,
        scaleFactor: 1,
        removed: false // Add removed flag
    });
    loadTexture(URL_BLUE_BILL, (texture) => {
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const planeWidth = texture.image.width * baseScale;
        const planeHeight = texture.image.height * baseScale;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const blueBill = new THREE.Mesh(geometry, material);
        blueBill.position.set(2, -2, (3 - 1) * depthStep);
        blueBill.userData.currentLayer = 10;
        blueBill.userData.initialPosition = blueBill.position.clone();
        blueBill.userData.initialLayer = 10;
        blueBill.userData.id = 'blueBill'; // Added ID
        blueBill.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(blueBill);
        draggableObjects.push(blueBill);
        cameraAnimationTargets.push(blueBill);
    });

    // Load and add the rocket image
    const rocketLayer = 1;
    const rocketZ = (rocketLayer - 1) * depthStep;
    const rocketInitialY = -.32; // Keep the existing Y position for the rocket
    initialAssetConfigs.push({
        id: 'rocket',
        type: 'image',
        url: URL_ROCKET,
        initialPosition: new THREE.Vector3(ROCKET_INITIAL_X, rocketInitialY, rocketZ),
        initialLayer: rocketLayer,
        baseScale: baseScale,
        scaleFactor: 1.04,
        removed: false // Add removed flag
    });
    let rocketRef = null; // Local reference to the rocket mesh
    loadTexture(URL_ROCKET, (texture) => {
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
        const rocketScaleFactor = 1.04;
        const planeWidth = texture.image.width * baseScale * rocketScaleFactor;
        const planeHeight = texture.image.height * baseScale * rocketScaleFactor;
        const geometry = new THREE.PlaneGeometry(planeWidth, planeHeight);
        const rocket = new THREE.Mesh(geometry, material);

        rocket.position.set(ROCKET_INITIAL_X, rocketInitialY, rocketZ);

        rocket.userData.currentLayer = rocketLayer;
        rocket.userData.initialPosition = rocket.position.clone();
        rocket.userData.initialLayer = rocketLayer;
        rocket.userData.id = 'rocket'; // Added ID
        rocket.userData.initialScale = { width: planeWidth, height: planeHeight }; // Store initial scale
        scene.add(rocket);
        draggableObjects.push(rocket);
        cameraAnimationTargets.push(rocket);
        rocketRef = rocket; // Store the reference
        
        // After rocket is loaded, load dogecoin/tesla and calculate its position relative to the rocket/background
        loadDogecoinAndFiat();
    });

    // Function to handle the interdependent loading and positioning of Dogecoin, Fiat, and Signature
    function loadDogecoinAndFiat() {
        const dogecoinLayer = 3;
        const dogecoinZ = (dogecoinLayer - 1) * depthStep;
        
        // Initial position placeholder for config (will be updated by the calculation below)
        let dogecoinInitialPos = new THREE.Vector3(0, 0, dogecoinZ);
        let fiatWorthlessInitialPos = new THREE.Vector3();
        let signatureInitialPos = new THREE.Vector3();
        
        // Define fiatWorthlessNewLayer here for scope consistency
        const fiatWorthlessNewLayer = dogecoinLayer + 2; 

        // Load necessary textures first
        loadTexture(URL_DOGECOIN_ORIGINAL, (dogeTex) => {
            dogecoinOriginalTexture = dogeTex;

            loadTexture(URL_TESLA_SWAP, (teslaTex) => {
                teslaTexture = teslaTex;
                
                // Load Fiat Worthless texture to determine its size for config
                loadTexture(URL_FIAT_WORTHLESS, (fiatTex) => {
                    const fiatWorthlessHeight = 0.3;
                    const fiatWorthlessAspectRatio = fiatTex.image.width / fiatTex.image.height;
                    const fiatWorthlessWidth = fiatWorthlessHeight * fiatWorthlessAspectRatio;

                    // --- CALCULATE FIXED POSITIONS NOW (moved from onWindowResize) ---
                    
                    // 1. Calculate Dogecoin/Tesla Position
                    // We must ensure backgroundMesh is ready before calculating positions relative to it
                    if (!backgroundMesh) {
                        console.error("Background mesh not loaded yet, deferring position calculation.");
                        // Fallback position if background isn't ready
                        dogecoinInitialPos.set(ROCKET_INITIAL_X, -3, dogecoinZ);
                        fiatWorthlessInitialPos.set(ROCKET_INITIAL_X + 2, -3.5, dogecoinZ + depthStep * 2);
                    } else {
                        const bgBounds = getBackgroundBounds(backgroundMesh.position.z);
                        const dogecoinScaleFactor = 0.7;
                        const tempDogeWidth = teslaTexture.image.width * baseScale * dogecoinScaleFactor; 
                        const tempDogeHeight = teslaTexture.image.height * baseScale * dogecoinScaleFactor;
                        const targetX = ROCKET_INITIAL_X; // Same as ROCKET_INITIAL_X
                        const paddingY = 0.5;
                        const targetY = bgBounds.minY + tempDogeHeight / 2 + paddingY;
                        dogecoinInitialPos.set(targetX, targetY, dogecoinZ);

                        // 2. Calculate Fiat Worthless Position
                        const fiatWorthlessNewZ = (fiatWorthlessNewLayer - 1) * depthStep;
                        const fiatWorthlessInitialWorldX = dogecoinInitialPos.x + tempDogeWidth * 1.1 + .25; 
                        const fiatWorthlessInitialWorldY = dogecoinInitialPos.y - tempDogeHeight * .11 - 0;
                        fiatWorthlessInitialPos.set(fiatWorthlessInitialWorldX, fiatWorthlessInitialWorldY, fiatWorthlessNewZ);
                    }

                    // 3. Calculate Signature Position
                    loadTexture(URL_SIGNATURE, (signatureTex) => {
                        const signatureHeight = 1.0;
                        const signatureAspectRatio = signatureTex.image.width / signatureTex.image.height;
                        const signatureWidth = signatureHeight * signatureAspectRatio;
                        const signatureNewLayer = 0; // (2 - 2)
                        const signatureNewZ = (signatureNewLayer - 1) * depthStep;
                        const signatureNewX = -2.0;
                        const signatureNewY = -4.7;
                        signatureInitialPos.set(signatureNewX, signatureNewY, signatureNewZ);

                        // --- Store CONFIGS (if not already present) ---
                        if (!initialAssetConfigs.find(c => c.id === 'dogecoin')) {
                            initialAssetConfigs.push({
                                id: 'dogecoin',
                                type: 'image',
                                url: URL_TESLA_SWAP,
                                originalTextureUrl: URL_DOGECOIN_ORIGINAL,
                                swapTextureUrl: URL_TESLA_SWAP,
                                initialPosition: dogecoinInitialPos.clone(),
                                initialLayer: dogecoinLayer,
                                baseScale: baseScale,
                                scaleFactor: 0.7,
                                removed: false
                            });
                        } else {
                             // Update existing config with the calculated fixed position
                            initialAssetConfigs.find(c => c.id === 'dogecoin').initialPosition.copy(dogecoinInitialPos);
                        }
                        
                        if (!initialAssetConfigs.find(c => c.id === 'fiatWorthless')) {
                            initialAssetConfigs.push({
                                id: 'fiatWorthless',
                                type: 'image',
                                url: URL_FIAT_WORTHLESS,
                                initialPosition: fiatWorthlessInitialPos.clone(),
                                initialLayer: fiatWorthlessNewLayer,
                                baseScale: baseScale,
                                scaleFactor: 0.3, // Used to derive the fixed height/width above
                                removed: false
                            });
                        } else {
                            // Update existing config with the calculated fixed position
                            initialAssetConfigs.find(c => c.id === 'fiatWorthless').initialPosition.copy(fiatWorthlessInitialPos);
                        }
                        
                        if (!initialAssetConfigs.find(c => c.id === 'signature')) {
                            initialAssetConfigs.push({
                                id: 'signature',
                                type: 'image',
                                url: URL_SIGNATURE,
                                initialPosition: signatureInitialPos.clone(),
                                initialLayer: signatureNewLayer,
                                baseScale: baseScale,
                                scaleFactor: 1.0,
                                removed: false
                            });
                        } else {
                            // Update existing config with the calculated fixed position
                            initialAssetConfigs.find(c => c.id === 'signature').initialPosition.copy(signatureInitialPos);
                        }

                        // --- CREATE MESHES ---
                        
                        // 1. Dogecoin/Tesla
                        teslaGreyscaleContrastMaterial = new THREE.ShaderMaterial({
                            uniforms: {
                                tDiffuse: { value: teslaTexture },
                                contrast: { value: GreyscaleContrastShader.uniforms.contrast.value }
                            },
                            vertexShader: GreyscaleContrastShader.vertexShader,
                            fragmentShader: GreyscaleContrastShader.fragmentShader,
                            transparent: true,
                            alphaTest: 0.5
                        });
                        const dogecoinScaleFactor = 0.7;
                        const dogePlaneWidth = teslaTexture.image.width * baseScale * dogecoinScaleFactor;
                        const dogePlaneHeight = teslaTexture.image.height * baseScale * dogecoinScaleFactor;
                        const dogecoin = new THREE.Mesh(new THREE.PlaneGeometry(dogePlaneWidth, dogePlaneHeight), teslaGreyscaleContrastMaterial);
                        dogecoin.userData.currentLayer = dogecoinLayer;
                        dogecoin.userData.initialPosition = dogecoinInitialPos.clone();
                        dogecoin.userData.initialLayer = dogecoinLayer;
                        dogecoin.userData.originalTexture = dogecoinOriginalTexture;
                        dogecoin.userData.teslaTexture = teslaTexture;
                        dogecoin.userData.id = 'dogecoin';
                        dogecoin.userData.initialScale = { width: dogePlaneWidth, height: dogePlaneHeight };
                        dogecoinRef = dogecoin;
                        scene.add(dogecoin);
                        draggableObjects.push(dogecoin);
                        cameraAnimationTargets.push(dogecoin);
                        
                        // Set position immediately after creation using the calculated fixed position
                        dogecoin.position.copy(dogecoinInitialPos);

                        // 2. Fiat Worthless
                        const fiatWorthlessMaterial = new THREE.MeshBasicMaterial({ map: fiatTex, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                        const fiatWorthless = new THREE.Mesh(new THREE.PlaneGeometry(fiatWorthlessWidth, fiatWorthlessHeight), fiatWorthlessMaterial);
                        fiatWorthless.position.copy(fiatWorthlessInitialPos);
                        fiatWorthless.userData.currentLayer = fiatWorthlessNewLayer;
                        fiatWorthless.userData.initialPosition = fiatWorthlessInitialPos.clone();
                        fiatWorthless.userData.initialLayer = fiatWorthlessNewLayer;
                        fiatWorthless.userData.id = 'fiatWorthless';
                        fiatWorthless.userData.initialScale = { width: fiatWorthlessWidth, height: fiatWorthlessHeight };
                        scene.add(fiatWorthless);
                        draggableObjects.push(fiatWorthless);
                        cameraAnimationTargets.push(fiatWorthless);

                        // 3. Signature
                        const signatureMaterial = new THREE.MeshBasicMaterial({ map: signatureTex, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                        const signature = new THREE.Mesh(new THREE.PlaneGeometry(signatureWidth, signatureHeight), signatureMaterial);
                        signature.position.copy(signatureInitialPos);
                        signature.userData.currentLayer = signatureNewLayer;
                        signature.userData.id = 'signature';
                        signature.userData.initialScale = { width: signatureWidth, height: signatureHeight };
                        signature.userData.initialPosition = signatureInitialPos.clone();
                        signature.userData.initialLayer = signatureNewLayer;
                        scene.add(signature);
                        
                        // Call onWindowResize only to handle ear and text positions, not dogecoin/fiat/signature
                        onWindowResize();
                    });
                });
            });
        });
    }

    // Initialize the Marquee Text (for XRAY effect)
    marqueeTexture = createMarqueeTexture();
    const marqueeMaterial = new THREE.MeshBasicMaterial({ map: marqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    // The plane size should be relative to the background or screen to fill it
    const marqueePlaneWidth = 20;
    const marqueePlaneHeight = marqueePlaneWidth / (marqueeTexture.image.width / marqueeTexture.image.height);
    const marqueeGeometry = new THREE.PlaneGeometry(marqueePlaneWidth, marqueePlaneHeight);
    initialAssetConfigs.push({
        id: 'marqueeTextMesh',
        type: 'textMesh',
        initialPosition: new THREE.Vector3(0, 0, -3 * depthStep),
        initialLayer: -3,
        geometry: marqueeGeometry.clone(),
        material: marqueeMaterial.clone(),
        removed: false // Add removed flag
    });
    marqueeTextMesh = new THREE.Mesh(marqueeGeometry, marqueeMaterial);
    // Position far back in the background, but in front of the actual background image
    marqueeTextMesh.position.z = -3 * depthStep;
    marqueeTextMesh.visible = false;
    marqueeTextMesh.userData.initialPosition = marqueeTextMesh.position.clone();
    marqueeTextMesh.userData.initialLayer = -3;
    marqueeTextMesh.userData.id = 'marqueeTextMesh'; // Added ID
    scene.add(marqueeTextMesh);

    // Initialize the new Biometric Marquee Text
    biometricMarqueeTexture = createBiometricMarqueeTexture();
    const biometricMarqueeMaterial = new THREE.MeshBasicMaterial({ map: biometricMarqueeTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    const biometricMarqueePlaneWidth = 20; // Same width as main marquee for consistency
    const biometricMarqueePlaneHeight = biometricMarqueePlaneWidth / (biometricMarqueeTexture.image.width / biometricMarqueeTexture.image.height);
    const biometricMarqueeGeometry = new THREE.PlaneGeometry(biometricMarqueePlaneWidth, biometricMarqueePlaneHeight);
    const biometricMarqueeZ = (5 - 1) * depthStep;
    const distance_from_camera_biometric = camera.position.z - biometricMarqueeZ;
    const world_height_biometric = 2 * distance_from_camera_biometric * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
    const pixelToUnitFactorX_biometric = (world_height_biometric * camera.aspect) / window.innerWidth;
    const moveRightUnits_biometric = 30 * pixelToUnitFactorX_biometric;
    initialAssetConfigs.push({
        id: 'biometricMarqueeTextMesh',
        type: 'textMesh',
        initialPosition: new THREE.Vector3(moveRightUnits_biometric, 0, biometricMarqueeZ),
        initialLayer: 5,
        geometry: biometricMarqueeGeometry.clone(),
        material: biometricMarqueeMaterial.clone(),
        removed: false // Add removed flag
    });
    biometricMarqueeTextMesh = new THREE.Mesh(biometricMarqueeGeometry, biometricMarqueeMaterial);
    biometricMarqueeTextMesh.position.set(moveRightUnits_biometric, 0, biometricMarqueeZ);
    biometricMarqueeTextMesh.visible = false; // Initially hidden
    biometricMarqueeTextMesh.userData.initialPosition = biometricMarqueeTextMesh.position.clone();
    biometricMarqueeTextMesh.userData.initialLayer = 5;
    biometricMarqueeTextMesh.userData.id = 'biometricMarqueeTextMesh'; // Added ID
    scene.add(biometricMarqueeTextMesh);

    // Initialize the new Blood Text
    bloodTexture = createBloodTextTexture();
    const bloodTextMaterial = new THREE.MeshBasicMaterial({ map: bloodTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    const bloodTextPlaneWidth = 20; // Similar width to other marquees
    const bloodTextPlaneHeight = bloodTextPlaneWidth / (bloodTexture.image.width / bloodTexture.image.height);
    const bloodTextGeometry = new THREE.PlaneGeometry(bloodTextPlaneWidth, bloodTextPlaneHeight);
    const bloodTextZ = (8 - 1) * depthStep; // Calculate Z once
    initialAssetConfigs.push({
        id: 'bloodTextMesh',
        type: 'textMesh',
        // Set placeholder Y=0. Position will be calculated and set in onWindowResize
        initialPosition: new THREE.Vector3(0, 0, bloodTextZ),
        initialLayer: 8,
        geometry: bloodTextGeometry.clone(),
        material: bloodTextMaterial.clone(),
        removed: false // Add removed flag
    });
    bloodTextMesh = new THREE.Mesh(bloodTextGeometry, bloodTextMaterial);
    // Position on Level 8 (using placeholder Y=0, will be corrected by onWindowResize)
    bloodTextMesh.position.set(0, 0, bloodTextZ);
    bloodTextMesh.visible = false; // Initially hidden
    bloodTextMesh.userData.initialPosition = bloodTextMesh.position.clone();
    bloodTextMesh.userData.initialLayer = 8;
    bloodTextMesh.userData.id = 'bloodTextMesh'; // Added ID
    scene.add(bloodTextMesh);

    // Initialize the new Redacted Glitch Text
    redactedGlitchTexture = createRedactedGlitchTexture();
    const redactedGlitchMaterial = new THREE.MeshBasicMaterial({ map: redactedGlitchTexture, transparent: true, side: THREE.DoubleSide, depthWrite: false });
    const redactedGlitchPlaneWidth = 15; // Width for the text block
    const redactedGlitchPlaneHeight = redactedGlitchPlaneWidth / (redactedGlitchTexture.image.width / redactedGlitchTexture.image.height);
    const redactedGlitchGeometry = new THREE.PlaneGeometry(redactedGlitchPlaneWidth, redactedGlitchPlaneHeight);
    const redactedGlitchTextZ = (1 - 1) * depthStep;
    const distance_from_camera_redacted = camera.position.z - redactedGlitchTextZ;
    const world_height_redacted = 2 * distance_from_camera_redacted * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
    const pixelToUnitFactorX_redacted = (world_height_redacted * camera.aspect) / window.innerWidth;
    const moveRightUnits_redacted = 40 * pixelToUnitFactorX_redacted;
    initialAssetConfigs.push({
        id: 'redactedGlitchTextMesh',
        type: 'textMesh',
        initialPosition: new THREE.Vector3(-5 + moveRightUnits_redacted, 0, redactedGlitchTextZ),
        initialLayer: 1,
        geometry: redactedGlitchGeometry.clone(),
        material: redactedGlitchMaterial.clone(),
        removed: false // Add removed flag
    });
    redactedGlitchTextMesh = new THREE.Mesh(redactedGlitchGeometry, redactedGlitchMaterial);
    redactedGlitchTextMesh.position.set(-5 + moveRightUnits_redacted, 0, redactedGlitchTextZ); // Level 1
    redactedGlitchTextMesh.visible = false; // Initially hidden
    redactedGlitchTextMesh.userData.initialPosition = redactedGlitchTextMesh.position.clone();
    redactedGlitchTextMesh.userData.initialLayer = 1;
    redactedGlitchTextMesh.userData.id = 'redactedGlitchTextMesh'; // Added ID
    scene.add(redactedGlitchTextMesh);

    initializeRedactedGlitchPhraseData(); // Initialize the redaction patterns

    window.addEventListener('resize', onWindowResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
    renderer.domElement.addEventListener('click', onClick);

    // Helper function to add a toggle button for an effect
    const addButtonToggle = (parentContainer, label, property, pass) => {
        const button = document.createElement('button');
        button.textContent = label.toUpperCase();
        button.style.cssText = `
            background-color: black;
            color: white;
            padding: 4px;
            margin: 0;
            border: 0.5px solid ${effectControls[property] ? '#4CAF50' : 'white'};
            border-radius: 0;
            cursor: pointer;
            font-family: monospace;
            font-size: 7px;
            outline: none;
            box-sizing: border-box;
        `;
        button.onmouseover = () => {
            if (effectControls[property]) {
                button.style.borderColor = '#66CC66'; // Brighter green for active hover
            } else {
                button.style.borderColor = '#777';
            }
        };
        button.onmouseout = () => {
            if (effectControls[property]) {
                button.style.borderColor = '#4CAF50'; // Green for active
            } else {
                button.style.borderColor = 'white'; // White for inactive
            }
        };

        button.onclick = (event) => {
            // Prevent event from bubbling up to document and triggering other handlers
            event.stopPropagation();
            
            let targetProperty = property; // Default to the button's own property

            // If HACKER is clicked, toggle the 'og' effect and keep hacker state in sync for UI update
            if (property === 'hacker') {
                effectControls.og = !effectControls.og;
                effectControls.hacker = effectControls.og;
                targetProperty = 'og'; // Process as if 'og' was clicked
            }

            // If this effect is being turned on, turn off conflicting effects
            if (!effectControls[targetProperty]) { // If turning the effect ON (or the underlying 'og' effect for 'hacker')

                // Turn off 'Anon' if any other effect is explicitly turned on
                if (effectControls.anon && targetProperty !== 'anon') {
                    effectControls.anon = false;
                    thresholdPass.enabled = false;
                    bloodPass.enabled = false;
                    glitchPass.enabled = false;
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false;
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false;
                    updateUIButtonState('anon', false);
                }

                // Turn off conflicting visual effects
                if (targetProperty === 'cctvFeed') {
                    if (effectControls.heatmap) { effectControls.heatmap = false; heatmapPass.enabled = false; updateUIButtonState('heatmap', false); }
                    if (effectControls.blood) { effectControls.blood = false; bloodPass.enabled = false; updateUIButtonState('blood', false); } // Turn off blood when CCTV is on
                    if (effectControls.bloodText) { effectControls.bloodText = false; bloodTextMesh.visible = false; updateUIButtonState('bloodText', false); } // Turn off blood text
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                } else if (targetProperty === 'heatmap') {
                    if (effectControls.cctvFeed) { effectControls.cctvFeed = false; cctvFeedPass.enabled = false; updateUIButtonState('cctvFeed', false); }
                    if (effectControls.blood) { effectControls.blood = false; bloodPass.enabled = false; updateUIButtonState('blood', false); } // Turn off blood when Heatmap is on
                    if (effectControls.bloodText) { effectControls.bloodText = false; bloodTextMesh.visible = false; updateUIButtonState('bloodText', false); } // Turn off blood text
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                } else if (targetProperty === 'blood' || targetProperty === 'bloodText') { // If Blood or Blood Text is turned on
                    if (effectControls.heatmap) { effectControls.heatmap = false; heatmapPass.enabled = false; updateUIButtonState('heatmap', false); }
                    if (effectControls.cctvFeed) { effectControls.cctvFeed = false; cctvFeedPass.enabled = false; updateUIButtonState('cctvFeed', false); }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                } else if (targetProperty === 'redactedGlitch') {
                    if (effectControls.redacted) { effectControls.redacted = false; updateUIButtonState('redacted', false); } // Turn off simple redacted
                    if (effectControls.glitch) { effectControls.glitch = false; glitchPass.enabled = false; updateUIButtonState('glitch', false); } // Turn off general glitch
                    if (effectControls.xray) { effectControls.xray = false; xrayPass.enabled = false; updateUIButtonState('xray', false); } // Turn off xray
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                    if (effectControls.cctvFeed) { effectControls.cctvFeed = false; cctvFeedPass.enabled = false; updateUIButtonState('cctvFeed', false); } // Turn off CCTV
                    if (effectControls.heatmap) { effectControls.heatmap = false; heatmapPass.enabled = false; updateUIButtonState('heatmap', false); } // Turn off Heatmap
                    if (effectControls.blood) { effectControls.blood = false; bloodPass.enabled = false; updateUIButtonState('blood', false); } // Turn off Blood
                    if (effectControls.bloodText) { effectControls.bloodText = false; bloodTextMesh.visible = false; updateUIButtonState('bloodText', false); } // Turn off Blood Text
                    if (effectControls.biometricMarquee) { effectControls.biometricMarquee = false; biometricMarqueeTextMesh.visible = false; updateUIButtonState('biometricMarquee', false); } // Turn off Biometric
                    if (effectControls.marqueeText) { effectControls.marqueeText = false; marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false); } // Turn off Marquee
                    if (effectControls.matrix) { effectControls.matrix = false; matrixPass.enabled = false; updateUIButtonState('matrix', false); } // Turn off Matrix
                    if (effectControls.pixelation) { effectControls.pixelation = false; pixelationPass.enabled = false; updateUIButtonState('pixelation', false); } // Turn off Pixelation
                    if (effectControls.ascii) { effectControls.ascii = false; asciiPass.enabled = false; updateUIButtonState('ascii', false); } // Turn off ASCII
                    if (effectControls.greyscale) { effectControls.greyscale = false; greyscalePass.enabled = false; updateUIButtonState('greyscale', false); } // Turn off Greyscale
                } else if (targetProperty === 'redacted') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'glitch') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'xray') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                    // If XRAY is turned on, ensure biometric marquee is turned off
                    if (effectControls.biometricMarquee) {
                        effectControls.biometricMarquee = false;
                        biometricMarqueeTextMesh.visible = false;
                        updateUIButtonState('biometricMarquee', false);
                    }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'biometricMarquee') {
                    if (effectControls.redactedGlitch) { effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false); } // Turn off redacted glitch
                    // If biometric marquee is turned on, ensure XRAY is turned off
                    if (effectControls.xray) {
                        effectControls.xray = false;
                        xrayPass.enabled = false;
                        marqueeTextMesh.visible = false; // Also hide main marquee if XRAY is off
                        updateUIButtonState('xray', false);
                    }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'threshold') {
                    if (effectControls.shadow) { effectControls.shadow = false; darkPass.enabled = false; updateUIButtonState('shadow', false); } // Updated to effectControls.shadow
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                } else if (targetProperty === 'shadow') {
                    if (effectControls.threshold) { effectControls.threshold = false; thresholdPass.enabled = false; updateUIButtonState('threshold', false); }
                    if (effectControls.surveillance) { effectControls.surveillance = false; updateUIButtonState('surveillance', false); } // Turn off surveillance
                    if (effectControls.greed) { effectControls.greed = false; updateUIButtonState('greed', false); } // Turn off greed
                }

                // Turn off all other non-combined visual effects if 'Anon' is being turned ON
                if (targetProperty === 'anon') {
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) && key !== 'anon' && key !== 'redacted' && key !== 'redactedGlitch' && key !== 'threshold' && key !== 'blood' && key !== 'glitch' && key !== 'marqueeText' && key !== 'biometricMarquee' && key !== 'yRotation' && key !== 'cameraAnimation' && key !== 'og' && key !== 'bloodText' && key !== 'hacker' && key !== 'surveillance' && key !== 'greed' && key !== 'shadowBrightness') { // Added greed and shadowBrightness
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Ensure redacted and redactedGlitch are off
                    effectControls.redacted = false; updateUIButtonState('redacted', false);
                    effectControls.redactedGlitch = false; redactedGlitchTextMesh.visible = false; updateUIButtonState('redactedGlitch', false);

                    // Turn off both marquees and blood text
                    effectControls.marqueeText = false; marqueeTextMesh.visible = false;
                    effectControls.biometricMarquee = false; biometricMarqueeTextMesh.visible = false;
                    effectControls.bloodText = false; bloodTextMesh.visible = false;
                    updateUIButtonState('marqueeText', false);
                    updateUIButtonState('biometricMarquee', false);
                    updateUIButtonState('bloodText', false);

                    // Turn off OG and Hacker and Surveillance and Greed if they're on
                    if (effectControls.og) {
                        effectControls.og = false;
                        asciiPass.enabled = false;
                        heatmapPass.enabled = false;
                        biometricMarqueeTextMesh.visible = false;
                        updateUIButtonState('og', false);
                    }
                    if (effectControls.hacker) {
                        effectControls.hacker = false;
                        updateUIButtonState('hacker', false);
                    }
                    if (effectControls.surveillance) {
                        effectControls.surveillance = false;
                        updateUIButtonState('surveillance', false);
                    }
                    if (effectControls.greed) {
                        effectControls.greed = false;
                        updateUIButtonState('greed', false);
                    }
                }

                // Handle turning on 'OG' effect (now also triggered by 'HACKER')
                if (targetProperty === 'og') {
                    // Turn off all other visual effects, excluding camera/y-rotation/feargreedindex
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) && key !== 'og' && key !== 'hacker' && key !== 'yRotation' && key !== 'cameraAnimation' && key !== 'bloodText' && key !== 'surveillance' && key !== 'greed' && key !== 'shadowBrightness') { // Added greed and shadowBrightness
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Specific cleanups for effects that don't have a pass or have special visibility
                    if (marqueeTextMesh) marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false);
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false; updateUIButtonState('redacted', false);
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false; updateUIButtonState('redactedGlitch', false);
                    if (bloodTextMesh) bloodTextMesh.visible = false; updateUIButtonState('bloodText', false);
                    if (biometricMarqueeTextMesh) biometricMarqueeTextMesh.visible = false; updateUIButtonState('biometricMarquee', false); // Ensure biometric is off if OG is turning on
                    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false; // Ensure redacted glitch text is off

                    // Turn off surveillance if OG is turned on
                    if (effectControls.surveillance) {
                        effectControls.surveillance = false;
                        updateUIButtonState('surveillance', false);
                    }
                    // Turn off greed if OG is turned on
                    if (effectControls.greed) {
                        effectControls.greed = false;
                        updateUIButtonState('greed', false);
                    }
                }

                // Handle turning on 'SURVEILLANCE' effect
                if (targetProperty === 'surveillance') {
                    // Turn off all other visual effects, excluding camera/y-rotation/feargreedindex
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) &&
                            key !== 'surveillance' &&
                            key !== 'heatmap' &&
                            key !== 'biometricMarquee' &&
                            key !== 'glitch' && // Added glitch to exclusion list for turning off
                            key !== 'yRotation' &&
                            key !== 'cameraAnimation' &&
                            key !== 'greed' && // Exclude greed from being turned off by surveillance
                            key !== 'shadowBrightness'
                        ) {
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Specific cleanups for effects that don't have a pass or have special visibility
                    if (marqueeTextMesh) marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false);
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false; updateUIButtonState('redacted', false);
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false; updateUIButtonState('redactedGlitch', false);
                    if (bloodTextMesh) bloodTextMesh.visible = false; updateUIButtonState('bloodText', false);
                    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false; // Ensure redacted glitch text is off

                    // Ensure Anon, OG, Hacker are off
                    if (effectControls.anon) {
                        effectControls.anon = false;
                        updateUIButtonState('anon', false);
                    }
                    if (effectControls.og) {
                        effectControls.og = false;
                        updateUIButtonState('og', false);
                    }
                    if (effectControls.hacker) {
                        effectControls.hacker = false;
                        updateUIButtonState('hacker', false);
                    }
                }

                // Handle turning on 'GREED' effect
                if (targetProperty === 'greed') {
                    // Turn off all other visual effects, excluding camera/y-rotation/feargreedindex
                    for (const key in effectControls) {
                        if (effectControls.hasOwnProperty(key) &&
                            key !== 'greed' &&
                            key !== 'blood' &&
                            key !== 'bloodText' &&
                            key !== 'yRotation' &&
                            key !== 'cameraAnimation' &&
                            key !== 'shadowBrightness'
                        ) {
                            if (effectControls[key]) {
                                effectControls[key] = false;
                                const p = getPassByName(key);
                                if (p) p.enabled = false;
                                updateUIButtonState(key, false);
                            }
                        }
                    }
                    // Specific cleanups for effects that don't have a pass or have special visibility
                    if (marqueeTextMesh) marqueeTextMesh.visible = false; updateUIButtonState('marqueeText', false);
                    if (rightEyeRedactionRect) rightEyeRedactionRect.visible = false; updateUIButtonState('redacted', false);
                    if (leftEyeRedactionRect) leftEyeRedactionRect.visible = false; updateUIButtonState('redactedGlitch', false);
                    if (biometricMarqueeTextMesh) biometricMarqueeTextMesh.visible = false; updateUIButtonState('biometricMarquee', false);
                    if (redactedGlitchTextMesh) redactedGlitchTextMesh.visible = false; // Ensure redacted glitch text is off

                    // Ensure Anon, OG, Hacker, Surveillance, CCTV, Heatmap are off
                    if (effectControls.anon) {
                        effectControls.anon = false;
                        updateUIButtonState('anon', false);
                    }
                    if (effectControls.og) {
                        effectControls.og = false;
                        updateUIButtonState('og', false);
                    }
                    if (effectControls.hacker) {
                        effectControls.hacker = false;
                        updateUIButtonState('hacker', false);
                    }
                    if (effectControls.surveillance) {
                        effectControls.surveillance = false;
                        updateUIButtonState('surveillance', false);
                    }
                    if (effectControls.cctvFeed) {
                        effectControls.cctvFeed = false;
                        updateUIButtonState('cctvFeed', false);
                    }
                    if (effectControls.heatmap) {
                        effectControls.heatmap = false;
                        updateUIButtonState('heatmap', false);
                    }
                }

            } else if (targetProperty === 'shadow') { // If turning SHADOW OFF, also turn off Glitch if it was enabled by SHADOW
                if (effectControls.glitch) { // Check if glitch is currently active
                    // Only turn off glitch if it's not being used by another effect like 'Anon' or 'Redacted Glitch' or 'OG' or 'HACKER' or 'Surveillance' or 'Greed'
                    if (!effectControls.anon && !effectControls.redactedGlitch && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.glitch = false;
                        glitchPass.enabled = false;
                        updateUIButtonState('glitch', false);
                    }
                }
            }

            // Toggle the effect control state if it wasn't already toggled by 'hacker' logic
            if (property !== 'hacker') {
                effectControls[property] = !effectControls[property];
            }

            // --- Begin Background Color Management ---
            // Set the clear color to black if any effect that relies on a black background is active
            const needsBlackBackground = effectControls.shadow || effectControls.threshold || effectControls.anon || effectControls.matrix || effectControls.ascii || effectControls.og;
            
            // If REDACTED GLITCH is active, use the orange background
            if (effectControls.redactedGlitch) {
                renderer.setClearColor(0xFFAC1C); // Orange
            } else if (needsBlackBackground) {
                renderer.setClearColor(0x000000); // Black
            } else {
                renderer.setClearColor(0x1e1e1e); // Default dark gray
            }
            // --- End Background Color Management ---

            if (targetProperty === 'shadow') {
                darkPass.enabled = effectControls.shadow;
                // If SHADOW is active, also activate Glitch
                if (effectControls.shadow) {
                    effectControls.glitch = true;
                    glitchPass.enabled = true;
                } else { // If SHADOW is being turned off
                    // Only turn off glitch if it's not being used by another effect like 'Anon' or 'Redacted Glitch' or 'OG' or 'HACKER' or 'Surveillance' or 'Greed'
                    if (!effectControls.anon && !effectControls.redactedGlitch && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.glitch = false;
                        glitchPass.enabled = false;
                    }
                }
                updateUIButtonState('shadow', effectControls.shadow);
                updateUIButtonState('glitch', effectControls.glitch);
            } else if (targetProperty === 'og') {
                asciiPass.enabled = effectControls.og;
                heatmapPass.enabled = effectControls.og;
                biometricMarqueeTextMesh.visible = effectControls.og;
                updateUIButtonState('ascii', effectControls.og);
                updateUIButtonState('heatmap', effectControls.og);
                updateUIButtonState('biometricMarquee', effectControls.og);
                updateUIButtonState('og', effectControls.og);
                updateUIButtonState('hacker', effectControls.og); // Update HACKER button state
            } else if (targetProperty === 'bloodText') {
                // When bloodText is turned on, also ensure blood effect is on
                if (effectControls.bloodText) {
                    effectControls.blood = true;
                    bloodPass.enabled = true;
                    updateUIButtonState('blood', true);
                    // On initial enable, set bloodScrollOffset to ensure the text starts higher
                    if (bloodTextMesh && bloodTextMesh.material.map) {
                        // bloodScrollOffset = bloodTextMesh.material.map.image.height; // Use the height of the texture canvas
                        bloodScrollOffset = 0; // The text mesh is already aligned to the bottom of the screen, so start scroll offset at 0.
                        shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]);
                    }
                }
                bloodTextMesh.visible = effectControls.bloodText;
                updateUIButtonState('bloodText', effectControls.bloodText);
            } else if (targetProperty === 'surveillance') {
                // When SURVEILLANCE is turned on/off, toggle heatmap, biometric marquee, AND glitch
                effectControls.heatmap = effectControls.surveillance;
                heatmapPass.enabled = effectControls.surveillance;
                updateUIButtonState('heatmap', effectControls.surveillance);

                effectControls.biometricMarquee = effectControls.surveillance;
                biometricMarqueeTextMesh.visible = effectControls.surveillance;
                updateUIButtonState('biometricMarquee', effectControls.surveillance);

                effectControls.glitch = effectControls.surveillance; // Add glitch control
                glitchPass.enabled = effectControls.surveillance; // Enable/disable glitch pass
                updateUIButtonState('glitch', effectControls.surveillance); // Update glitch button state

                // Update the button for surveillance itself
                updateUIButtonState('surveillance', effectControls.surveillance);

            } else if (targetProperty === 'greed') {
                // When GREED is turned on/off, toggle blood and bloodText
                effectControls.blood = effectControls.greed;
                bloodPass.enabled = effectControls.greed;
                updateUIButtonState('blood', effectControls.greed);

                effectControls.bloodText = effectControls.greed;
                bloodTextMesh.visible = effectControls.greed;
                updateUIButtonState('bloodText', effectControls.greed);

                // If turning on, ensure text starts from bottom and reshuffle
                if (effectControls.greed) {
                    if (bloodTextMesh && bloodTextMesh.material.map) {
                        bloodScrollOffset = 0; // The text mesh is already aligned to the bottom of the screen, so start scroll offset at 0.
                        shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]);
                    }
                }

                // Update the button for greed itself
                updateUIButtonState('greed', effectControls.greed);

            } else if (targetProperty === 'redactedGlitch') { // Handle Redacted Glitch effect toggle
                if (rightEyeRedactionRect) rightEyeRedactionRect.visible = effectControls.redactedGlitch;
                if (leftEyeRedactionRect) leftEyeRedactionRect.visible = effectControls.redactedGlitch;
                // Removed glitchPass.enabled = effectControls.redactedGlitch;
                redactedGlitchTextMesh.visible = effectControls.redactedGlitch;

                // When redactedGlitch is active, force threshold effect on
                if (effectControls.redactedGlitch) {
                    effectControls.threshold = true;
                    thresholdPass.enabled = true;
                    updateUIButtonState('threshold', true);
                    // Ensure shadow is off if threshold is forced on
                    if (effectControls.shadow) {
                        effectControls.shadow = false;
                        darkPass.enabled = false;
                        updateUIButtonState('shadow', false);
                        // Glitch is already being turned on by Anon, so no need to turn off if it was from shadow
                    }
                }
                else { // If turning off redactedGlitch
                    if (!effectControls.redacted && !effectControls.anon && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.threshold = false;
                        thresholdPass.enabled = false;
                        updateUIButtonState('threshold', false);
                    }
                }
                updateUIButtonState('redactedGlitch', effectControls.redactedGlitch);
                // Removed updateUIButtonState('glitch', effectControls.redactedGlitch); // Sync glitch button

            } else if (pass) {
                pass.enabled = effectControls[targetProperty];
                updateUIButtonState(targetProperty, effectControls[targetProperty]);
            }

            // Update marquee text visibility based on XRAY only
            const shouldMarqueeBeVisible = effectControls.xray;
            if (effectControls.marqueeText !== shouldMarqueeBeVisible) {
                effectControls.marqueeText = shouldMarqueeBeVisible;
                marqueeTextMesh.visible = shouldMarqueeBeVisible;
            }

            // Toggle biometric marquee visibility (if not controlled by surveillance/OG/HACKER/GREED)
            if (targetProperty === 'biometricMarquee' && !effectControls.surveillance && !effectControls.og && !effectControls.hacker && !effectControls.greed) {
                biometricMarqueeTextMesh.visible = effectControls.biometricMarquee;
            }

            // Handle redacted effect toggle
            if (targetProperty === 'redacted') {
                if (rightEyeRedactionRect) rightEyeRedactionRect.visible = effectControls.redacted;
                if (leftEyeRedactionRect) leftEyeRedactionRect.visible = effectControls.redacted;
                // When redacted is active, force threshold effect on
                if (effectControls.redacted) {
                    effectControls.threshold = true;
                    thresholdPass.enabled = true;
                    updateUIButtonState('threshold', true);
                    // Ensure shadow is off if threshold is forced on
                    if (effectControls.shadow) {
                        effectControls.shadow = false;
                        darkPass.enabled = false;
                        updateUIButtonState('shadow', false);
                        // Also turn off glitch if it was enabled by shadow and not by other effects
                        if (!effectControls.anon && !effectControls.redactedGlitch && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                            effectControls.glitch = false;
                            glitchPass.enabled = false;
                            updateUIButtonState('glitch', false);
                        }
                    }
                } else {
                    if (!effectControls.redactedGlitch && !effectControls.anon && !effectControls.og && !effectControls.hacker && !effectControls.surveillance && !effectControls.greed) {
                        effectControls.threshold = false;
                        thresholdPass.enabled = false;
                        updateUIButtonState('threshold', false);
                    }
                }
            }

            // Handle Anon effect toggle
            if (targetProperty === 'anon') {
                if (effectControls.anon) {
                    thresholdPass.enabled = true;
                    bloodPass.enabled = true;
                    glitchPass.enabled = true;
                    if (rightEyeRedactionRect) {
                        rightEyeRedactionRect.visible = true;
                        // Set Anon/Redacted eyes to white (0xffffff)
                        if (rightEyeRedactionRect.material.color.getHex() !== 0xffffff) {
                            rightEyeRedactionRect.material.color.setHex(0xffffff);
                        }
                    }
                    if (leftEyeRedactionRect) {
                        leftEyeRedactionRect.visible = true;
                        // Set Anon/Redacted eyes to white (0xffffff)
                        if (leftEyeRedactionRect.material.color.getHex() !== 0xffffff) {
                            leftEyeRedactionRect.material.color.setHex(0xffffff);
                        }
                    }

                    // Ensure shadow is off if threshold is forced on by Anon
                    if (effectControls.shadow) {
                        effectControls.shadow = false;
                        darkPass.enabled = false;
                        updateUIButtonState('shadow', false);
                        // Glitch is already being turned on by Anon, so no need to turn off if it was from shadow
                    }
                }
                else {
                    thresholdPass.enabled = false;
                    bloodPass.enabled = false;
                    glitchPass.enabled = false;
                    if (rightEyeRedactionRect) {
                        rightEyeRedactionRect.visible = false;
                        // Reset Anon/Redacted eyes to black (0x000000) when turning off
                        if (rightEyeRedactionRect.material.color.getHex() !== 0x000000) {
                            rightEyeRedactionRect.material.color.setHex(0x000000);
                        }
                    }
                    if (leftEyeRedactionRect) {
                        leftEyeRedactionRect.visible = false;
                        // Reset Anon/Redacted eyes to black (0x000000) when turning off
                        if (leftEyeRedactionRect.material.color.getHex() !== 0x000000) {
                            leftEyeRedactionRect.material.color.setHex(0x000000);
                        }
                    }
                }
                // Update threshold, blood, glitch buttons to reflect Anon's state
                updateUIButtonState('threshold', effectControls.anon);
                updateUIButtonState('blood', effectControls.anon);
                updateUIButtonState('glitch', effectControls.anon);
            }

            // Handle camera animation toggle
            if (property === 'cameraAnimation') {
                cameraAnimationActive = effectControls.cameraAnimation;
                controls.enabled = !cameraAnimationActive;
                if (cameraAnimationActive) {
                    // Ensure Y-rotation is off if camera animation is activated
                    if (effectControls.yRotation) {
                        effectControls.yRotation = false;
                        updateUIButtonState('yRotation', false);
                    }
                    // Capture current camera state as the *initial* global start point for the loop
                    initialGlobalCameraPos.copy(camera.position);
                    initialGlobalCameraLookAt.copy(controls.target);
                    // Set loop start to global start for the first exploration
                    cameraPreviousPos.copy(initialGlobalCameraPos);
                    cameraPreviousLookAt.copy(initialGlobalCameraLookAt);
                    assetsVisitedCount = 0;
                    startCameraAnimation(performance.now());
                } else {
                    // Reset camera to default or current OrbitControls view when animation stops
                    // No need to reset position here, the camera stays where it is.
                    cameraAnimationState = 'idle';
                    assetsVisitedCount = 0;
                    // Re-enable controls if Y-rotation is not active
                    if (!effectControls.yRotation) {
                        controls.enabled = true;
                    }
                }
                yRotationStartTime = 0; // Reset Y-rotation auto-start timer if camera anim is manually toggled
            }

            // Handle Y-axis rotation toggle
            if (property === 'yRotation') {
                if (effectControls.yRotation) {
                    // When Y-rotation starts, disable OrbitControls and camera animation
                    controls.enabled = false;
                    cameraAnimationActive = false;
                    updateUIButtonState('cameraAnimation', false);
                    // Store initial camera position for the bounce animation
                    yBounceInitialCameraX = camera.position.x;
                    yBounceInitialCameraY = camera.position.y;
                    yBounceInitialCameraZ = camera.position.z;
                    yRotationStartTime = performance.now(); // Record start time for Y-rotation
                } else {
                    // When Y-rotation stops, re-enable OrbitControls if no other camera animation is active
                    if (!cameraAnimationActive) {
                        controls.enabled = true;
                    }
                    // Optionally reset camera to its original position before bounce
                    camera.position.set(yBounceInitialCameraX, yBounceInitialCameraY, yBounceInitialCameraZ);
                    controls.target.set(0, 0, (1 - 1) * depthStep);
                    camera.lookAt(controls.target);
                    yRotationStartTime = 0; // Reset Y-rotation auto-start timer if Y-rotation is manually toggled off
                }
            }
        };
        button.setAttribute('data-effect', property);
        parentContainer.appendChild(button);
    };

    // Helper to get pass by name
    const getPassByName = (name) => {
        switch (name) {
            case 'greyscale': return greyscalePass;
            case 'threshold': return thresholdPass;
            case 'shadow': return darkPass;
            case 'pixelation': return pixelationPass;
            case 'glitch': return glitchPass;
            case 'matrix': return matrixPass;
            case 'ascii': return asciiPass;
            case 'xray': return xrayPass;
            case 'heatmap': return heatmapPass;
            case 'blood': return bloodPass;
            case 'cctvFeed': return cctvFeedPass;
            default: return null;
        }
    };

    // Define buttons to be added to both UIs
    const buttonsConfig = [
        { label: '3D', property: 'yRotation', pass: null },
        { label: 'FLY', property: 'cameraAnimation', pass: null },
        { label: 'SHADOW', property: 'shadow', pass: darkPass },
        { label: 'ASCII', property: 'ascii', pass: asciiPass },
        { label: 'HEATMAP', property: 'heatmap', pass: heatmapPass },
        { label: 'BLOOD', property: 'blood', pass: bloodPass },
        { label: 'REDACTED', property: 'redactedGlitch', pass: null },
        { label: 'ANON', property: 'anon', pass: null },
        { label: 'BIOMETRIC', property: 'biometricMarquee', pass: null },
        { label: 'OG', property: 'og', pass: null },
        { label: 'BLOOD TEXT', property: 'bloodText', pass: null },
        { label: 'DATA SCRAPER', property: 'hacker', pass: null },
        { label: 'BIO-CODER', property: 'surveillance', pass: null },
        { label: 'HIDDEN HAND', property: 'greed', pass: null },
        { label: 'Threshold', property: 'threshold', pass: thresholdPass },
        { label: 'Pixelation', property: 'pixelation', pass: pixelationPass },
        { label: 'Glitch', property: 'glitch', pass: glitchPass },
        { label: 'Matrix', property: 'matrix', pass: matrixPass },
        { label: 'XRAY', property: 'xray', pass: xrayPass },
        { label: 'CCTV FEED', property: 'cctvFeed', pass: cctvFeedPass },
        { label: 'GREYSCALE', property: 'greyscale', pass: greyscalePass }
    ];

    // Create and append the left UI container
    leftUiContainer = document.createElement('div'); // Assign to global variable
    leftUiContainer.id = 'left-ui-container';
    leftUiContainer.style.position = 'absolute';
    leftUiContainer.style.top = '-190px'; // Start mostly hidden, revealing only the arrow
    leftUiContainer.style.left = '10px';
    leftUiContainer.style.backgroundColor = 'rgba(0, 0, 0, 0)';
    leftUiContainer.style.color = 'white';
    leftUiContainer.style.padding = '10px'; /* Reduced padding for more compact layout */
    leftUiContainer.style.borderRadius = '5px';
    leftUiContainer.style.fontFamily = 'monospace';
    leftUiContainer.style.zIndex = '100';
    leftUiContainer.style.display = 'flex';
    leftUiContainer.style.flexDirection = 'column'; /* Changed to column for vertical layout */
    leftUiContainer.style.flexWrap = 'nowrap'; /* Not needed for single column */
    leftUiContainer.style.gap = '5px'; /* Adjusted gap for vertical layout */
    leftUiContainer.style.transition = 'top 0.5s ease-in-out'; // Smooth transition for top property
    document.body.appendChild(leftUiContainer);

    // Create and append the right UI container
    const rightUiContainer = document.createElement('div');
    rightUiContainer.id = 'right-ui-container';
    rightUiContainer.style.position = 'absolute';
    rightUiContainer.style.top = '10px';
    rightUiContainer.style.right = '10px';
    rightUiContainer.style.backgroundColor = 'rgba(0, 0, 0, 0)';
    rightUiContainer.style.color = 'white';
    rightUiContainer.style.padding = '10px';
    rightUiContainer.style.borderRadius = '5px';
    rightUiContainer.style.fontFamily = 'monospace';
    rightUiContainer.style.zIndex = '100';
    rightUiContainer.style.display = 'none'; // Hide the right UI container
    rightUiContainer.style.flexDirection = 'column';
    rightUiContainer.style.gap = '5px';
    document.body.appendChild(rightUiContainer);

    // Define the desired order of buttons for the left UI
    const leftUiOrder = [
        'yRotation', // 3D
        'cameraAnimation', // FLY
        'surveillance', // BIO-CODER
        'greed', // HIDDEN HAND
        'hacker', // DATA SCRAPER
        'shadow', // SHADOW
        'redactedGlitch' // REDACTED
    ];

    // Map property names to their full config objects for easy lookup
    const buttonConfigMap = new Map(buttonsConfig.map(config => [config.property, config]));

    // Add buttons to the left UI container in the specified order
    leftUiOrder.forEach(propertyName => {
        const config = buttonConfigMap.get(propertyName);
        if (config) {
            addButtonToggle(leftUiContainer, config.label, config.property, config.pass);
        }
    });

    // Add all buttons to the right UI container
    buttonsConfig.forEach(config => {
        if (!leftUiOrder.includes(config.property)) { // Only add if not already in left UI
            addButtonToggle(rightUiContainer, config.label, config.property, config.pass);
        }
    });

    // Add the RESET button to both UI containers
    const createResetButton = () => {
        const button = document.createElement('button');
        button.textContent = 'RESET';
        button.style.cssText = `
            background-color: black;
            color: white;
            padding: 4px;
            margin-top: 10px;
            border: 0.5px solid rgba(0, 0, 0, 0.8);
            border-radius: 0;
            cursor: pointer;
            font-family: monospace;
            font-size: 7px;
            outline: none;
            white-space: nowrap;
            box-sizing: border-box;
        `;
        button.onmouseover = () => { button.style.borderColor = 'rgba(0, 0, 0, 1.0)'; };
        button.onmouseout = () => { button.style.borderColor = 'rgba(0, 0, 0, 0.8)'; };
        button.onclick = (event) => { event.stopPropagation(); resetPiecesToOriginalPositions(); };
        return button;
    };
    leftUiContainer.appendChild(createResetButton());
    rightUiContainer.appendChild(createResetButton());

    // Create and append the TRASH button to the left UI container
    const createTrashButton = () => {
        const button = document.createElement('button');
        button.id = 'trash-button'; // Unique ID for easy targeting
        button.innerHTML = 'TRASH'; // Text with trashcan icon
        button.style.cssText = `
            background-color: black; /* Changed from #CC0000 to black */
            color: white;
            padding: 4px;
            margin-top: 10px;
            border: none;
            border-radius: 0;
            cursor: pointer;
            font-family: monospace;
            font-size: 7px;
            outline: none;
            white-space: nowrap;
            box-sizing: border-box;
        `;
        button.onmouseover = () => { }; /* Removed border change on hover */
        button.onmouseout = () => { }; /* Removed border change on mouseout */
        // The actual removal logic will be in onPointerUp, triggered by dropping onto this button
        return button;
    };
    trashButtonElement = createTrashButton(); // Store reference to the button element
    leftUiContainer.appendChild(trashButtonElement);

    // Create and append the EXPORT button below TRASH
    const createExportButton = () => {
        const button = document.createElement('button');
        button.id = 'export-toggle';
        button.innerHTML = 'RCS';
        button.style.cssText = `
            background-color: white;
            color: black;
            padding: 4px;
            margin-top: 2px;
            border: 0.5px solid white;
            border-radius: 0;
            cursor: pointer;
            font-family: monospace;
            font-size: 7px;
            outline: none;
            white-space: nowrap;
            box-sizing: border-box;
        `;
        return button;
    };
    exportButtonElement = createExportButton();
    leftUiContainer.appendChild(exportButtonElement);

    // Add the thin black rectangle with a down-facing arrow below the TRASH button
    arrowContainer = document.createElement('div'); // Assign to global variable
    arrowContainer.id = 'arrow-container'; // Add ID for better targeting
    arrowContainer.style.cssText = `
        position: absolute; /* Position relative to the viewport */
        top: 0px; /* Initially at the top, peeking out */
        left: 20px;
        background-color: black;
        width: 60px; /* Fixed width for the arrow tab */
        height: 15px; /* Height of the arrow tab */
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
        z-index: 101; /* Higher z-index than leftUiContainer to be clickable */
        border-bottom-left-radius: 5px; /* Rounded corners for the tab */
        border-bottom-right-radius: 5px;
        transition: top 0.5s ease-in-out; /* Smooth transition for top property */
        box-sizing: border-box; /* Include padding and border in the element's total width and height */
    `;
    const arrowSpan = document.createElement('span');
    arrowSpan.style.cssText = `
        color: white;
        font-size: 10px; /* Larger arrow */
    `;
    arrowSpan.innerHTML = '&#x25BC;'; // Down-facing triangle
    arrowContainer.appendChild(arrowSpan);
    document.body.appendChild(arrowContainer); // Append to body, not leftUiContainer

    // Add click listener for the arrow container to toggle left UI visibility
    arrowContainer.onclick = (event) => {
        event.stopPropagation(); // Prevent clicks from interacting with 3D scene
        if (leftUiContainer.style.top === '10px') {
            leftUiContainer.style.top = '-190px'; // Hide it, revealing only the arrow
            trashButtonElement.style.display = 'none'; // Hide TRASH button
            exportButtonElement.style.display = 'none'; // Hide EXPORT button
            const panel = document.getElementById('export-panel');
            if (panel) panel.classList.remove('open'); // Close export panel
            arrowContainer.style.top = '0px'; // Keep arrow at the top
            arrowSpan.innerHTML = '&#x25BC;'; // Change to down arrow
        } else {
            leftUiContainer.style.top = '10px'; // Show it
            trashButtonElement.style.display = 'block'; // Show TRASH button
            exportButtonElement.style.display = 'block'; // Show EXPORT button
            arrowContainer.style.top = `${leftUiContainer.offsetHeight + 10}px`; // Move arrow below the UI
            arrowSpan.innerHTML = '&#x25B2'; // Change to up arrow
        }
    };

    // Initial state setup for TRASH/EXPORT buttons and arrowContainer
    // When the page loads, the left UI is hidden, so these buttons should be hidden.
    trashButtonElement.style.display = 'none';
    exportButtonElement.style.display = 'none';

    window.addEventListener('resize', onWindowResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
    renderer.domElement.addEventListener('click', onClick);
    
    // Call onWindowResize once after init to ensure initial positions are calculated correctly
    // NOTE: This is called after the main assets are loaded in loadDogecoinAndFiat to ensure
    // responsive elements are placed correctly *after* the initial fixed elements are positioned.
    // However, calling it here ensures the camera/composer/UI are sized correctly from the start.
    onWindowResize();
}

/**
 * Calculates the responsive position for the ear mesh and updates both the mesh position
 * and the initialPosition in its config.
 * @param {THREE.Mesh} earMesh 
 * @param {object} earConfig 
 */
function updateEarPosition(earMesh, earConfig) {
    // Check if the necessary objects and properties exist
    if (!earMesh || !earConfig || !earConfig.initialPosition) return;
    
    const earNewZ = earConfig.initialPosition.z; // Use Z from config
    const distance_from_camera_ear = camera.position.z - earNewZ;
    const world_height_at_ear_z = 2 * distance_from_camera_ear * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
    const world_width_at_ear_z = world_height_at_ear_z * camera.aspect;
    const pixelToUnitFactorX_ear = world_width_at_ear_z / window.innerWidth;
    const moveLeftUnits = 2 * pixelToUnitFactorX_ear;
    
    // The fixed initial X position is the base - the responsive offset
    // We use the hardcoded starting X (-2.5) as the base for the responsive offset
    const baseInitialX = -2.5; 
    const calculatedInitialX = baseInitialX - moveLeftUnits; 
    
    // Check if the mesh has been dragged away from its *last stored* position
    // We use a small tolerance to check if it's close to the stored config position (which is the last calculated responsive position)
    const currentInitialX = earConfig.initialPosition.x;
    
    let targetX;
    
    // If the mesh's current position is close to the stored initial position (meaning it hasn't been dragged far)
    if (Math.abs(earMesh.position.x - currentInitialX) < 0.01) {
        // It hasn't been dragged, so update its position to the new responsive X.
        targetX = calculatedInitialX;
    } else {
        // It has been dragged, maintain its current position.
        targetX = earMesh.position.x;
    }

    // Apply the position and ensure the Y and Z are maintained from the config
    earMesh.position.set(targetX, earConfig.initialPosition.y, earConfig.initialPosition.z);

    // If we updated the position, update the config and user data for future checks/resets
    if (targetX === calculatedInitialX) {
        earConfig.initialPosition.copy(earMesh.position);
        earMesh.userData.initialPosition = earMesh.position.clone(); 
    }
}


function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    if (composer) {
        composer.setSize(window.innerWidth, window.innerHeight);
    }

    if (pixelationPass) {
        pixelationPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    }
    if (asciiPass) {
        asciiPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    }
    if (cctvFeedPass) {
        cctvFeedPass.uniforms['resolution'].value.set(window.innerWidth, window.innerHeight);
    }

    // Adjust arrow container position on resize if UI is open
    if (leftUiContainer.style.top === '10px') {
        arrowContainer.style.top = `${leftUiContainer.offsetHeight + 10}px`;
    }

    // --- Dynamic Repositioning of Ear and Marquee Text ---
    const earConfig = initialAssetConfigs.find(c => c.id === 'ear');
    const earMesh = scene.children.find(c => c.userData.id === 'ear');
    
    // Use the dedicated helper function to handle ear position update
    if (earMesh && earConfig) {
        updateEarPosition(earMesh, earConfig);
    }
    
    // The biometric marquee position relies on pixelToUnitFactorX_biometric
    const biometricMarqueeConfig = initialAssetConfigs.find(c => c.id === 'biometricMarqueeTextMesh');
    if (biometricMarqueeTextMesh && biometricMarqueeConfig) {
        const biometricMarqueeZ = biometricMarqueeConfig.initialPosition.z;
        const distance_from_camera_biometric = camera.position.z - biometricMarqueeZ;
        const world_height_biometric = 2 * distance_from_camera_biometric * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
        const pixelToUnitFactorX_biometric = (world_height_biometric * camera.aspect) / window.innerWidth;
        const moveRightUnits_biometric = 30 * pixelToUnitFactorX_biometric;
        
        // Only update position if the mesh is at its initial position
        if (biometricMarqueeTextMesh.position.distanceTo(biometricMarqueeConfig.initialPosition) < 0.01) {
            biometricMarqueeTextMesh.position.x = moveRightUnits_biometric;
            biometricMarqueeConfig.initialPosition.copy(biometricMarqueeTextMesh.position); // Update config with new responsive position
        }
    }
    
    // The redacted glitch text position relies on pixelToUnitFactorX_redacted
    const redactedGlitchConfig = initialAssetConfigs.find(c => c.id === 'redactedGlitchTextMesh');
    if (redactedGlitchTextMesh && redactedGlitchConfig) {
        const redactedGlitchTextZ = redactedGlitchConfig.initialPosition.z;
        const distance_from_camera_redacted = camera.position.z - redactedGlitchTextZ;
        const world_height_redacted = 2 * distance_from_camera_redacted * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
        const pixelToUnitFactorX_redacted = (world_height_redacted * camera.aspect) / window.innerWidth;
        const moveRightUnits_redacted = 40 * pixelToUnitFactorX_redacted;
        
        // Only update position if the mesh is at its initial position
        if (redactedGlitchTextMesh.position.distanceTo(redactedGlitchConfig.initialPosition) < 0.01) {
            redactedGlitchTextMesh.position.x = -5 + moveRightUnits_redacted;
            redactedGlitchConfig.initialPosition.copy(redactedGlitchTextMesh.position); // Update config with new responsive position
        }
    }
    
    // --- Dynamic Repositioning of Blood Text (to bottom of screen) ---
    const bloodTextConfig = initialAssetConfigs.find(c => c.id === 'bloodTextMesh');
    if (bloodTextMesh && bloodTextConfig) {
        const bloodTextZ = bloodTextConfig.initialPosition.z;
        const bloodTextPlaneHeight = bloodTextMesh.geometry.parameters.height;
        
        // Calculate the world height of the camera frustum at the text's Z depth
        const distance_from_camera_blood = camera.position.z - bloodTextZ;
        const world_height_blood = 2 * distance_from_camera_blood * Math.tan(THREE.MathUtils.degToRad(camera.fov / 2));
        
        // Y_center = -WorldHeight/2 + Height/2
        // This positions the bottom edge of the plane at the bottom of the visible screen (-WorldHeight/2)
        const yStart = -world_height_blood / 2 + bloodTextPlaneHeight / 2;
        
        // Only update position if the mesh is at its initial position (or close to the initial placeholder (0,0,Z))
        if (bloodTextMesh.position.distanceTo(bloodTextConfig.initialPosition) < 0.01) {
            bloodTextMesh.position.y = yStart;
            // Update config with new responsive position
            bloodTextConfig.initialPosition.copy(bloodTextMesh.position); 
            bloodTextMesh.userData.initialPosition.copy(bloodTextMesh.position);
        }
    }
    // --- End Dynamic Repositioning ---

    stopCameraAnimationAndReset();
}

function onPointerDown(event) {
    
    isDragging = false;
    pointerDownPosition.set(event.clientX, event.clientY);

    // Check if the click is on a UI element
    if (event.target.closest('#left-ui-container') || event.target.closest('#right-ui-container') || event.target.closest('#arrow-container')) {
        selectedObject = null;
        controls.enabled = true;
        return;
    }

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(draggableObjects, true); // Intersect with all descendants

    // Filter intersects to only consider those with alpha > 0.1
    for (const intersect of intersects) {
        const object = intersect.object;
        const material = object.material;

        // Ensure the material has a map property before trying to access its alpha
        if (material && material.map && material.transparent) {
            const uv = intersect.uv;
            const alpha = getAlphaAtUV(material.map, uv);

            if (alpha > 0.1) { // Alpha threshold for drag detection
                selectedObject = object;
                controls.enabled = false;
                initialObjectZ = selectedObject.position.z;
                offset.copy(intersect.point).sub(selectedObject.position);
                break; // Found a draggable opaque part, stop searching
            }
        } else if (material && material.alphaTest !== undefined && material.alphaTest > 0) {
            // For ShaderMaterial with alphaTest, treat as always opaque if intersect occurs
            selectedObject = object;
            controls.enabled = false;
            initialObjectZ = selectedObject.position.z;
            offset.copy(intersect.point).sub(selectedObject.position);
            break; // Found a draggable opaque part, stop searching
        } else if (material && !material.transparent) {
            // For opaque materials, any intersect means it's draggable
            selectedObject = object;
            controls.enabled = false;
            initialObjectZ = selectedObject.position.z;
            offset.copy(intersect.point).sub(selectedObject.position);
            break; // Found a draggable opaque part, stop searching
        }
    }
}

function onPointerMove(event) {
    
    if (selectedObject) {
        // Check if the pointer has moved beyond the drag threshold
        const currentPointerPosition = new THREE.Vector2(event.clientX, event.clientY);
        if (currentPointerPosition.distanceTo(pointerDownPosition) > DRAG_THRESHOLD) {
            isDragging = true;
        }

        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        raycaster.setFromCamera(mouse, camera);

        // Create a plane that is parallel to the camera's view plane
        // and passes through the object's initial Z-position.
        const plane = new THREE.Plane();
        plane.setFromNormalAndCoplanarPoint(camera.getWorldDirection(new THREE.Vector3()), new THREE.Vector3(0, 0, initialObjectZ));

        const intersection = new THREE.Vector3();
        if (raycaster.ray.intersectPlane(plane, intersection)) {
            // Update X and Y, but keep the original Z-position
            selectedObject.position.x = intersection.x - offset.x;
            selectedObject.position.y = intersection.y - offset.y;
            selectedObject.position.z = initialObjectZ;
            
            // If the object is the ear, update its initialPosition in userData so it doesn't snap back on resize until reset
            if (selectedObject.userData.id === 'ear') {
                 selectedObject.userData.initialPosition.copy(selectedObject.position);
                 // Also update the config for reset consistency
                 const earConfig = initialAssetConfigs.find(c => c.id === 'ear');
                 if (earConfig) earConfig.initialPosition.copy(selectedObject.position);
            }

            // Update redaction rectangle positions if the selected object is an eye
            if (selectedObject === rightEyeMesh) {
                if (rightEyeRedactionRect) {
                    rightEyeRedactionRect.position.x = selectedObject.position.x;
                    rightEyeRedactionRect.position.y = selectedObject.position.y;
                }
            } else if (selectedObject === leftEyeMesh) {
                if (leftEyeRedactionRect) {
                    leftEyeRedactionRect.position.x = selectedObject.position.x;
                    leftEyeRedactionRect.position.y = selectedObject.position.y;
                }
            }
        }
    }
}

function onPointerUp(event) {
    
    if (isDragging || event.target.closest('#trash-button')) { // Check if dragging or if pointer released directly over trash button
        // Check if the pointer was released over the TRASH button
        if (trashButtonElement) {
            const rect = trashButtonElement.getBoundingClientRect();

            // Define a larger target area for the trash button
            const expandedRect = {
                left: rect.left - 20, // 20 pixels extra padding on left
                right: rect.right + 20, // 20 pixels extra padding on right
                top: rect.top - 20, // 20 pixels extra padding on top
                bottom: rect.bottom + 20 // 20 pixels extra padding on bottom
            };

            if (event.clientX >= expandedRect.left && event.clientX <= expandedRect.right &&
                event.clientY >= expandedRect.top && event.clientY <= expandedRect.bottom) {

                if (selectedObject) {
                    // Mark the object as removed in the initialAssetConfigs for later reloading
                    const configIndex = initialAssetConfigs.findIndex(config => config.id === selectedObject.userData.id);
                    if (configIndex !== -1) {
                        initialAssetConfigs[configIndex].removed = true;
                    }

                    // Object was dropped onto the trash button, remove it
                    scene.remove(selectedObject);
                    // Remove from draggableObjects array
                    draggableObjects = draggableObjects.filter(obj => obj !== selectedObject);
                    // Remove from cameraAnimationTargets array
                    cameraAnimationTargets = cameraAnimationTargets.filter(obj => obj !== selectedObject);

                    // Dispose of geometry and material to free up memory
                    if (selectedObject.geometry) selectedObject.geometry.dispose();
                    if (selectedObject.material) {
                        if (Array.isArray(selectedObject.material)) {
                            selectedObject.material.forEach(m => m.dispose());
                        } else {
                            selectedObject.material.dispose();
                        }
                    }

                    // Special handling for specific removed objects (set global refs to null)
                    if (selectedObject.userData.id === 'dogecoin') {
                        dogecoinRef = null;
                    }
                    if (selectedObject.userData.id === 'spacex') {
                        spacexRef = null;
                    }
                    if (selectedObject.userData.id === 'rightEye') {
                        if (rightEyeRedactionRect) { scene.remove(rightEyeRedactionRect); rightEyeRedactionRect.geometry.dispose(); rightEyeRedactionRect.material.dispose(); }
                        rightEyeMesh = null;
                        rightEyeRedactionRect = null;
                    }
                    if (selectedObject.userData.id === 'leftEye') {
                        if (leftEyeRedactionRect) { scene.remove(leftEyeRedactionRect); leftEyeRedactionRect.geometry.dispose(); leftEyeRedactionRect.material.dispose(); }
                        leftEyeMesh = null;
                        leftEyeRedactionRect = null;
                    }
                    console.log("Object removed:", selectedObject.name || selectedObject.uuid);
                }
            }
        }
    }

    selectedObject = null;
    // Re-enable controls only if camera animation AND yRotation are not active
    if (!cameraAnimationActive && !effectControls.yRotation) {
        controls.enabled = true;
    }
    // isDragging is reset by onPointerDown for the next interaction
}

function onClick(event) {
    
    // Only process click if no dragging occurred and not clicking on UI
    if (isDragging || event.target.closest('#left-ui-container') || event.target.closest('#right-ui-container') || event.target.closest('#arrow-container')) {
        return;
    }

    stopCameraAnimationAndReset(); // Only stop FLY camera on explicit click if not dragging and not on UI

    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(draggableObjects, true); // Intersect with all descendants

    // Filter intersects to only consider those with alpha > 0.1
    let clickedObject = null;
    for (const intersect of intersects) {
        const object = intersect.object;
        const material = object.material;

        // Special handling for ShaderMaterial with alphaTest, as getAlphaAtUV is for MeshBasicMaterial
        if (material instanceof THREE.ShaderMaterial && material.alphaTest !== undefined && material.alphaTest > 0) {
            clickedObject = object;
            break;
        } else if (material && material.map && material.transparent) {
            const uv = intersect.uv;
            const alpha = getAlphaAtUV(material.map, uv);

            if (alpha > 0.1) { // Alpha threshold for click detection
                clickedObject = object;
                break; // Found a clickable opaque part, stop searching
            }
        }
        else if (material && !material.transparent) {
            // For opaque materials, any intersect means it's clickable
            clickedObject = object;
            break; // Found a clickable opaque part, stop searching
        }
    }

    if (clickedObject) {
        // Handle Dogecoin/Tesla logo swap
        if (clickedObject === dogecoinRef) {
            if (dogecoinRef.material.map === dogecoinRef.userData.originalTexture) {
                // Swap to Tesla texture with greyscale and high contrast effect
                dogecoinRef.material = teslaGreyscaleContrastMaterial;
                dogecoinRef.material.uniforms.tDiffuse.value = dogecoinRef.userData.teslaTexture;
            } else {
                // Swap back to original Dogecoin texture with basic material
                dogecoinRef.material = new THREE.MeshBasicMaterial({ map: dogecoinRef.userData.originalTexture, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
            }
            dogecoinRef.material.needsUpdate = true;
        }

        // Handle SpaceX/X logo swap
        if (clickedObject === spacexRef) {
            let newTexture;
            let targetWidth;
            let targetHeight;

            if (spacexRef.material.map === spacexRef.userData.originalTexture) {
                newTexture = spacexRef.userData.xLogoTexture;
                // For X logo, ensure 1:1 ratio if the source image is 1:1, otherwise use its own ratio
                // We'll base the new size on the original object's height to keep vertical scale consistent
                targetHeight = spacexRef.userData.originalHeight; // Use the original object's height as a reference
                targetWidth = targetHeight * (newTexture.image.width / newTexture.image.height);

            } else {
                newTexture = spacexRef.userData.originalTexture;
                targetWidth = spacexRef.userData.originalWidth;
                targetHeight = spacexRef.userData.originalHeight;
            }

            // Dispose of old geometry to prevent memory leaks
            spacexRef.geometry.dispose();
            // Create new geometry with updated dimensions
            spacexRef.geometry = new THREE.PlaneGeometry(targetWidth, targetHeight);

            spacexRef.material.map = newTexture;
            spacexRef.material.needsUpdate = true;
        }

        // Skip depth cycling for non-draggable elements or those with special handling
        if (clickedObject === backgroundMesh || clickedObject === rightEyeRedactionRect || clickedObject === leftEyeRedactionRect || clickedObject === marqueeTextMesh || clickedObject === biometricMarqueeTextMesh || clickedObject === bloodTextMesh || clickedObject === redactedGlitchTextMesh) { // Added redactedGlitchTextMesh
            return;
        }

        // Cycle through depth levels
        let currentLayer = clickedObject.userData.currentLayer || 1;
        currentLayer--; // Move backward one level
        if (currentLayer < 1) { // If it goes below 1
            currentLayer = totalDepthLayers; // Wrap around to the highest layer
        }
        clickedObject.userData.currentLayer = currentLayer;
        clickedObject.position.z = (currentLayer - 1) * depthStep;

        // Update redaction rectangle Z position if the clicked object is an eye
        if (clickedObject === rightEyeMesh) {
            if (rightEyeRedactionRect) {
                rightEyeRedactionRect.position.z = clickedObject.position.z + (1.5 * depthStep);
            }
        }
        else if (clickedObject === leftEyeMesh) {
            if (leftEyeRedactionRect) {
                leftEyeRedactionRect.position.z = clickedObject.position.z + (1.5 * depthStep);
            }
        }

        console.log(`Object moved to layer: ${currentLayer}, Z-position: ${clickedObject.position.z}`);
    }
}

// Ease-in-out function
function easeInOutCubic(t) {
    return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
}

function startCameraAnimation(currentTime) {
    if (!cameraAnimationActive || cameraAnimationTargets.length === 0) return;

    // Store current camera state as the start for the next animation segment
    cameraPreviousPos.copy(camera.position);
    cameraPreviousLookAt.copy(controls.target);
    cameraAnimationStartTime = currentTime;

    let duration = 0;
    if (cameraAnimationState === 'exploring') {
        duration = cameraExplorationDuration;
    }
    else if (cameraAnimationState === 'returningToGlobalStart') {
        duration = cameraReturnDuration;
    }

    if (cameraAnimationState === 'returningToGlobalStart' || assetsVisitedCount >= ASSETS_PER_GLOBAL_RETURN) {
        cameraAnimationState = 'exploring';
        assetsVisitedCount = 0;

        // Pick a random target for the next exploration
        let newTarget;
        do {
            newTarget = cameraAnimationTargets[Math.floor(Math.random() * cameraAnimationTargets.length)];
        } while (newTarget === cameraTargetObject && cameraAnimationTargets.length > 1);
        cameraTargetObject = newTarget;

        // Calculate end position and lookAt based on the target object
        const targetPos = cameraTargetObject.position;
        const targetBounds = new THREE.Box3().setFromObject(cameraTargetObject);
        const center = targetBounds.getCenter(new THREE.Vector3());
        const size = targetBounds.getSize(new THREE.Vector3());

        const fovRad = THREE.MathUtils.degToRad(camera.fov);
        const baseDistance = Math.max(size.x, size.y) / (2 * Math.tan(fovRad / 2));

        const minZOffset = baseDistance * 0.8;
        const maxZOffset = baseDistance * 1.5;
        const randomZOffset = minZOffset + (Math.random() * (maxZOffset - minZOffset));

        const lateralOffsetRange = baseDistance * 0.5;
        const randomOffsetX = (Math.random() - 0.5) * lateralOffsetRange;
        const randomOffsetY = (Math.random() - 0.5) * lateralOffsetRange;

        cameraCurrentTargetPos.set(
            center.x + randomOffsetX,
            center.y + randomOffsetY,
            targetPos.z + randomZOffset
        );

        cameraCurrentTargetLookAt.copy(center);

        cameraCurrentTargetPos.z = THREE.MathUtils.clamp(cameraCurrentTargetPos.z, -5, 15);

    } else { // Continue exploring
        cameraAnimationState = 'exploring';
        assetsVisitedCount++;

        // Pick a random target, ensuring it's not the same as the previous one if possible
        let newTarget;
        do {
            newTarget = cameraAnimationTargets[Math.floor(Math.random() * cameraAnimationTargets.length)];
        } while (newTarget === cameraTargetObject && cameraAnimationTargets.length > 1);
        cameraTargetObject = newTarget;

        // Calculate end position and lookAt based on the target object
        const targetPos = cameraTargetObject.position;
        const targetBounds = new THREE.Box3().setFromObject(cameraTargetObject);
        const center = targetBounds.getCenter(new THREE.Vector3());
        const size = targetBounds.getSize(new THREE.Vector3());

        // Determine a suitable base distance to frame the object based on its size and camera FOV
        const fovRad = THREE.MathUtils.degToRad(camera.fov);
        const baseDistance = Math.max(size.x, size.y) / (2 * Math.tan(fovRad / 2));

        // Introduce randomness to the Z-distance from the target object
        const minZOffset = baseDistance * 0.8;
        const maxZOffset = baseDistance * 1.5;
        const randomZOffset = minZOffset + (Math.random() * (maxZOffset - minZOffset));

        // Set a random offset around the target object for camera position in X and Y
        const lateralOffsetRange = baseDistance * 0.5;
        const randomOffsetX = (Math.random() - 0.5) * lateralOffsetRange;
        const randomOffsetY = (Math.random() - 0.5) * lateralOffsetRange;

        cameraCurrentTargetPos.set(
            center.x + randomOffsetX,
            center.y + randomOffsetY,
            targetPos.z + randomZOffset
        );

        cameraCurrentTargetLookAt.copy(center);

        // Clamp cameraCurrentTargetPos.z to be within reasonable bounds for the scene
        cameraCurrentTargetPos.z = THREE.MathUtils.clamp(cameraCurrentTargetPos.z, -5, 15);
    }
}

function updateCameraAnimation(currentTime) {
    if (cameraAnimationState === 'idle' || !cameraAnimationActive) return;

    const elapsed = currentTime - cameraAnimationStartTime;

    let duration = 0;
    if (cameraAnimationState === 'exploring') {
        duration = cameraExplorationDuration;
    }
    else if (cameraAnimationState === 'returningToGlobalStart') {
        duration = cameraReturnDuration;
    }

    let t = Math.min(1, elapsed / duration);
    t = easeInOutCubic(t);

    camera.position.lerpVectors(cameraPreviousPos, cameraCurrentTargetPos, t);
    controls.target.lerpVectors(cameraPreviousLookAt, cameraCurrentTargetLookAt, t);

    if (elapsed >= duration) {
        // If returning to global start, then after completion, start a new exploration cycle
        if (cameraAnimationState === 'returningToGlobalStart') {
            cameraAnimationState = 'exploring';
            assetsVisitedCount = 0;
        }
        startCameraAnimation(currentTime);
    }
    camera.lookAt(controls.target);
}

function animate(currentTime) {
    requestAnimationFrame(animate);

    // Apply Y-rotation if explicitly enabled
    if (effectControls.yRotation) {
        // Ensure camera animation is turned off if Y-rotation is active
        if (cameraAnimationActive) {
            cameraAnimationActive = false;
            updateUIButtonState('cameraAnimation', false);
        }
        controls.enabled = false;
        const convergencePoint = new THREE.Vector3(0, 0, (1 - 1) * depthStep);
        camera.position.x = yBounceInitialCameraX + yBounceRangeX * Math.sin(currentTime * yBounceSpeed);
        camera.position.y = yBounceInitialCameraY;
        camera.position.z = yBounceInitialCameraZ;
        camera.lookAt(convergencePoint);
    }

    // Apply Camera Animation if explicitly enabled
    if (cameraAnimationActive) {
        // Ensure Y-rotation is turned off if camera animation is active
        if (effectControls.yRotation) {
            effectControls.yRotation = false;
            updateUIButtonState('yRotation', false);
        }
        controls.enabled = false;
        updateCameraAnimation(currentTime);
    } else if (!effectControls.yRotation) {
        controls.update();
    }
    
    // --- Background Color Management (repeated in animate loop for persistent check) ---
    const needsBlackBackground = effectControls.shadow || effectControls.threshold || effectControls.anon || effectControls.matrix || effectControls.ascii || effectControls.og;
    
    // If REDACTED GLITCH is active, use the orange background
    if (effectControls.redactedGlitch) {
        renderer.setClearColor(0xFFAC1C); // Orange
    } else if (needsBlackBackground) {
        renderer.setClearColor(0x000000); // Black
    } else {
        renderer.setClearColor(0x1e1e1e); // Default dark gray
    }
    // --- End Background Color Management ---

    // Update the time uniform for the CCTVFeedShader
    if (cctvFeedPass.enabled) {
        cctvFeedPass.uniforms['time'].value = currentTime * 0.001;
    }

    // Update marquee text scrolling
    if (effectControls.xray) { // Marquee text is now only tied to XRAY effect
        marqueeScrollOffset -= MARQUEE_SCROLL_SPEED;
        // Reset offset when one full set of lines has scrolled off
        if (marqueeScrollOffset <= -MARQUEE_LINE_HEIGHT * MARQUEE_TOTAL_LINES) {
            marqueeScrollOffset = 0;
        }
        updateMarqueeTexture();
    }

    // Update biometric marquee text scrolling
    if (effectControls.biometricMarquee || effectControls.og || effectControls.hacker || effectControls.surveillance || effectControls.greed) { // Update if either biometric or OG or HACKER or SURVEILLANCE or GREED is active
        biometricMarqueeScrollOffset -= BIOMETRIC_MARQUEE_SCROLL_SPEED;
        if (biometricMarqueeScrollOffset <= -BIOMETRIC_MARQUEE_LINE_HEIGHT * BIOMETRIC_MARQUEE_TOTAL_LINES) {
            biometricMarqueeScrollOffset = 0;
        }
        updateBiometricMarqueeTexture(currentTime);
    }

    // Update blood text scrolling
    if (effectControls.bloodText) {
        bloodScrollOffset -= BLOOD_TEXT_SCROLL_SPEED;
        const singleSetHeight = BLOOD_TEXT_LINE_HEIGHT * BLOOD_TEXT_TOTAL_LINES;

        // When the first set of phrases has scrolled completely off the top of the canvas,
        // wrap it around to the bottom, effectively creating a continuous loop.
        if (bloodScrollOffset <= -singleSetHeight) {
            bloodScrollOffset += singleSetHeight * 3; // Move it to the bottom of the second set
            shuffledBloodPhrases = shuffleArray([...BLOOD_TEXT_PHRASES]); // Reshuffle phrases on loop
        }

        updateBloodTextTexture();
    }

    // Update redacted glitch text scrolling
    if (effectControls.redactedGlitch) {
        redactedGlitchScrollOffset -= REDACTED_GLITCH_SCROLL_SPEED;
        const singleSetHeight = REDACTED_GLITCH_LINE_HEIGHT * REDACTED_GLITCH_TOTAL_LINES;
        if (redactedGlitchScrollOffset <= -singleSetHeight) {
            redactedGlitchScrollOffset = 0;
            // Re-initialize redaction patterns when the text loops
            initializeRedactedGlitchPhraseData();
        }
        updateRedactedGlitchTexture();
    }

    composer.render();
}

init();
animate();

// Expose for dae hooks
setTimeout(function () {
    window.animate = typeof animate == "function" ? animate : () => { };
    window.camera = typeof camera != "undefined" ? camera : undefined;
    window.renderer = typeof renderer != "undefined" ? renderer : undefined;
    window.scene = typeof scene != "undefined" ? scene : undefined;
}, 1000)
    
    // Expose for dae hooks
    setTimeout(function() {
      window.animate = typeof animate == "function" ? animate : () => {}; 
      window.camera = typeof camera != "undefined" ? camera : undefined; 
      window.renderer = typeof renderer != "undefined" ? renderer : undefined; 
      window.scene = typeof scene != "undefined" ? scene : undefined; 
    }, 1000)
  </script>

  <!-- ─── EXPORT PANEL HTML ─── -->
  <div id="export-panel">
    <div class="panel-title">EXPORT</div>

    <div class="export-row">
      <label>Format</label>
      <select id="export-format">
        <option value="mp4">MP4</option>
        <option value="png">PNG</option>
      </select>
    </div>

    <!-- Video duration row (hidden for PNG) -->
    <div class="export-row" id="duration-row">
      <label>Duration (sec)</label>
      <input type="number" id="export-duration" value="5" min="1" max="60" step="1">
    </div>

    <button class="export-btn" id="export-start-btn">EXPORT</button>
    <div class="status-line" id="export-status"></div>
  </div>

  <!-- ─── POST TO X MODAL ─── -->
  <div id="post-modal">
    <div id="post-modal-content">
      <h2>Share your overlord</h2>
      <p style="margin: 0 0 20px 0; font-size: 12px; color: #aaa;">Attach your downloaded file before posting</p>
      <button id="post-modal-btn">POST TO X</button>
      
      <div style="margin: 20px 0; color: #666; font-size: 11px; text-align: center;">
        ── OR ──
      </div>
      
      <button id="judgment-btn" style="
        background: #000;
        color: #fff;
        border: 2px solid #fff;
        padding: 12px 30px;
        font-family: monospace;
        font-size: 14px;
        font-weight: bold;
        cursor: pointer;
        letter-spacing: 1px;
        transition: background 0.2s;
        width: 100%;
      ">SUBMIT TO JUDGMENT PROTOCOL</button>
      
      <p style="margin: 15px 0 0 0; font-size: 10px; color: #888; line-height: 1.4;">
        Submit your capture for collector review.<br>
        Top submissions will be minted as official subseries.
      </p>
    </div>
  </div>

  <!-- ─── EXPORT ENGINE ─── -->
  <script>
  (function(){
    function setupExport() {
    // ── Detect if embedded in iframe ──
    const isEmbedded = (window.self !== window.top);
    
    // ── DOM refs ──
    const toggle    = document.getElementById('export-toggle');
    if (!toggle) { setTimeout(setupExport, 50); return; } // wait for init() to create it
    
    // If embedded, hide RCS button and exit
    if (isEmbedded) {
      toggle.style.display = 'none';
      const modal = document.getElementById('post-modal');
      if (modal) modal.style.display = 'none';
      return;
    }
    
    const panel     = document.getElementById('export-panel');
    const fmtSel    = document.getElementById('export-format');
    const durInput  = document.getElementById('export-duration');
    const startBtn  = document.getElementById('export-start-btn');
    const status    = document.getElementById('export-status');
    const durRow    = document.getElementById('duration-row');
    const modal     = document.getElementById('post-modal');
    const modalBtn  = document.getElementById('post-modal-btn');

    // ── Show POST TO X modal ──
    function showPostModal() {
      modal.classList.add('open');
      // Close export panel
      panel.classList.remove('open');
    }

    // Wire modal button to open Twitter compose page with pre-filled text
    modalBtn.onclick = () => {
      const text = encodeURIComponent('Know your overlord. #KnowYourOverlord\nTech Epochalypse by @Coldie');
      window.open(`https://x.com/intent/post?text=${text}`, '_blank');
      // Close modal
      modal.classList.remove('open');
    };

    // Wire judgment protocol button to open Airtable form
    const judgmentBtn = document.getElementById('judgment-btn');
    judgmentBtn.onclick = () => {
      window.open('https://airtable.com/app28BSDaZwDpDw4m/pagUJlx4mF1vkSgO4/form', '_blank');
      // Close modal
      modal.classList.remove('open');
    };

    // Close modal on background click
    modal.onclick = (e) => {
      if (e.target === modal) modal.classList.remove('open');
    };

    // ── Toggle panel ──
    toggle.onclick = (e) => {
      e.stopPropagation();
      if (panel.classList.contains('open')) {
        panel.classList.remove('open');
      } else {
        // Position panel directly below the EXPORT button
        const rect = toggle.getBoundingClientRect();
        panel.style.top = (rect.bottom + 4) + 'px';
        panel.style.left = rect.left + 'px';
        panel.classList.add('open');
      }
    };
    document.addEventListener('click', (e) => {
      if (!panel.contains(e.target) && e.target !== toggle) panel.classList.remove('open');
    });

    // ── Show/hide rows based on format ──
    fmtSel.onchange = () => {
      durRow.style.display = (fmtSel.value === 'png') ? 'none' : 'flex';
    };

    // ── Helpers ──
    function setStatus(msg, cls) {
      status.textContent = msg;
      status.className = 'status-line' + (cls ? ' ' + cls : '');
    }
    function lockUI(on) {
      startBtn.disabled = on;
      fmtSel.disabled   = on;
      durInput.disabled  = on;
    }
    function triggerDownload(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a   = document.createElement('a');
      a.href    = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      setTimeout(() => URL.revokeObjectURL(url), 1000);
    }
    // Wait for window.renderer to be available (exposed after 1 s by the app)
    function getRenderer() {
      return new Promise((resolve) => {
        const check = () => {
          if (window.renderer && window.renderer.domElement) resolve(window.renderer);
          else setTimeout(check, 100);
        };
        check();
      });
    }

    // ── PNG export ──
    async function exportPNG() {
      setStatus('Capturing…', 'active');
      lockUI(true);
      const r = await getRenderer();
      // One extra render tick so the composer has drawn the current frame
      await new Promise(res => requestAnimationFrame(res));
      r.domElement.toBlob((blob) => {
        if (blob) {
          triggerDownload(blob, 'elon-musk-coldie.png');
          setStatus('PNG saved ✓', 'active');
          showPostModal();
        } else {
          setStatus('Capture failed', 'error');
        }
        lockUI(false);
      }, 'image/png');
    }
    // ── Video (MP4) export ──────────────────────────────────────────
    // Strategy: try native H.264 MP4 first (Safari, newer Chrome).
    // If unavailable, record VP9/VP8 WebM and re-mux into an MP4 container
    // so the .mp4 extension and container are always correct for Twitter/X.
    async function exportVideo() {
      const duration = parseInt(durInput.value) * 1000; // ms

      const r = await getRenderer();
      const canvas = r.domElement;
      const stream = canvas.captureStream(30);

      // Codec priority: H.264 MP4 first, then WebM fallbacks
      const candidates = [
        'video/mp4;codecs=avc1.42E01E',
        'video/mp4;codecs=avc1.640028',
        'video/mp4',
        'video/webm;codecs=vp9',
        'video/webm;codecs=vp8',
        'video/webm'
      ];
      let usedMime = '';
      for (const m of candidates) {
        if (MediaRecorder.isTypeSupported(m)) { usedMime = m; break; }
      }
      if (!usedMime) { setStatus('No supported codec found', 'error'); return; }

      const nativeMp4 = usedMime.startsWith('video/mp4');

      const chunks = [];
      const mr = new MediaRecorder(stream, { mimeType: usedMime, videoBitsPerSecond: 2500000 });

      lockUI(true);
      startBtn.classList.add('recording');
      setStatus(`Recording… ${duration/1000}s`, 'active');

      mr.ondataavailable = (e) => { if (e.data.size > 0) chunks.push(e.data); };

      mr.onstop = async () => {
        try {
          if (nativeMp4) {
            // Browser produced a native MP4 – download directly
            const blob = new Blob(chunks, { type: 'video/mp4' });
            triggerDownload(blob, 'elon-musk-coldie.mp4');
            setStatus(`MP4 saved ✓  (${(blob.size/1024/1024).toFixed(2)} MB)`, 'active');
            showPostModal();
          } else {
            // Recorded WebM – wrap it inside an MP4 container
            setStatus('Muxing to MP4…', 'active');
            // Merge all chunks into one Uint8Array
            const arrays = [];
            for (const c of chunks) {
              const buf = await c.arrayBuffer();
              arrays.push(new Uint8Array(buf));
            }
            let totalLen = 0;
            for (const a of arrays) totalLen += a.length;
            const payload = new Uint8Array(totalLen);
            let off = 0;
            for (const a of arrays) { payload.set(a, off); off += a.length; }

            // Build a minimal but valid fragmented MP4 shell
            const mp4 = buildMP4(payload, duration, canvas.width, canvas.height);
            const blob = new Blob([mp4], { type: 'video/mp4' });
            triggerDownload(blob, 'elon-musk-coldie.mp4');
            setStatus(`MP4 saved ✓  (${(blob.size/1024/1024).toFixed(2)} MB)`, 'active');
            showPostModal();
          }
        } catch (err) {
          // Ultimate fallback: save raw recording as-is
          console.error('MP4 mux error', err);
          const ext  = nativeMp4 ? 'mp4' : 'webm';
          const blob = new Blob(chunks, { type: usedMime });
          triggerDownload(blob, `elon-musk-coldie.${ext}`);
          setStatus(`Saved as .${ext} (mux failed)`, 'active');
        }
        lockUI(false);
        startBtn.classList.remove('recording');
      };

      mr.onerror = () => {
        setStatus('Recording failed', 'error');
        lockUI(false);
        startBtn.classList.remove('recording');
      };

      mr.start(100); // flush data every 100 ms
      setTimeout(() => {
        mr.stop();
        stream.getTracks().forEach(t => t.stop());
      }, duration);
    }

    // ── Minimal fragmented-MP4 builder ──────────────────────────────
    // Produces ftyp + moov + mdat.  The mdat is the raw recorded bitstream;
    // the moov declares a single video track with no sample table entries
    // (valid for fragmented MP4).  Twitter's transcoder probes the actual
    // codec inside mdat, so this works whether the inner data is H.264 or VP9.
    function buildMP4(payload, durationMs, width, height) {
      // Helpers
      function u32(v) { return [(v>>>24)&0xFF,(v>>>16)&0xFF,(v>>>8)&0xFF,v&0xFF]; }
      function u16(v) { return [(v>>>8)&0xFF, v&0xFF]; }
      function tag(s) { return s.split('').map(c => c.charCodeAt(0)); }

      function box(type, body) {
        const size = 8 + body.length;
        return new Uint8Array([...u32(size), ...tag(type), ...body]);
      }
      function fullBox(type, version, flags, body) {
        const vf = u32((version << 24) | flags);
        return box(type, new Uint8Array([...vf, ...body]));
      }
      function concat(...parts) {
        let len = 0; for (const p of parts) len += p.length;
        const out = new Uint8Array(len);
        let o = 0; for (const p of parts) { out.set(p, o); o += p.length; }
        return out;
      }

      const ts = 1000; // timescale
      const dur = durationMs;

      // ── ftyp ──
      const ftyp = box('ftyp', new Uint8Array([
        ...tag('isom'), ...u32(512),           // major brand + minor version
        ...tag('isom'), ...tag('iso2'), ...tag('mp41') // compatible brands
      ]));

      // ── moov ──
      const mvhd = fullBox('mvhd', 0, 0, new Uint8Array([
        ...u32(0), ...u32(0),        // created / modified
        ...u32(ts), ...u32(dur),     // timescale / duration
        ...u32(0x00010000),          // rate = 1.0
        ...u16(0x0100),              // volume = 1.0
        ...new Uint8Array(10),       // reserved
        // identity matrix
        ...u32(0x00010000),...u32(0),...u32(0),
        ...u32(0),...u32(0x00010000),...u32(0),
        ...u32(0),...u32(0),...u32(0x40000000),
        ...new Uint8Array(24),       // pre_defined
        ...u32(2)                    // next_track_ID
      ]));

      const tkhd = fullBox('tkhd', 0, 3, new Uint8Array([
        ...u32(0), ...u32(0),        // created / modified
        ...u32(1),                   // track_ID
        ...u32(0),                   // reserved
        ...u32(dur),                 // duration
        ...new Uint8Array(8),        // reserved
        ...u16(0), ...u16(0),        // layer / alternate_group
        ...u16(0), ...u16(0),        // volume / reserved
        // identity matrix
        ...u32(0x00010000),...u32(0),...u32(0),
        ...u32(0),...u32(0x00010000),...u32(0),
        ...u32(0),...u32(0),...u32(0x40000000),
        ...u32(width << 16),         // width  16.16
        ...u32(height << 16)         // height 16.16
      ]));

      const mdhd = fullBox('mdhd', 0, 0, new Uint8Array([
        ...u32(0), ...u32(0),
        ...u32(ts), ...u32(dur),
        ...u16(0x55C4),              // language 'und'
        ...u16(0)
      ]));

      const hdlr = fullBox('hdlr', 0, 0, new Uint8Array([
        ...u32(0),                   // pre_defined
        ...tag('vide'),              // handler_type
        ...new Uint8Array(12),       // reserved
        0                            // name (null terminator)
      ]));

      // stsd – one generic visual sample entry
      const sampleEntry = (() => {
        const inner = new Uint8Array([
          0,0, 0,0,0,1,             // reserved(6) + data_ref_index = 1
          ...new Uint8Array(16),     // pre_defined + reserved
          ...u16(width), ...u16(height),
          0x00,0x48,0x00,0x00,      // horiz res 72 dpi
          0x00,0x48,0x00,0x00,      // vert  res 72 dpi
          0,0,0,0,                  // reserved
          0,0,0,1,                  // frame_count
          ...new Uint8Array(32),     // compressor_name
          0,0,0x01,0x18,            // depth
          0xFF,0xFF                 // pre_defined
        ]);
        return box('mp41', inner);   // 'mp41' = generic visual
      })();

      const stsd = fullBox('stsd', 0, 0, new Uint8Array([...u32(1), ...sampleEntry]));
      const stts = fullBox('stts', 0, 0, new Uint8Array([...u32(0)]));
      const stsc = fullBox('stsc', 0, 0, new Uint8Array([...u32(0)]));
      const stsz = fullBox('stsz', 0, 0, new Uint8Array([...u32(0), ...u32(0)]));
      const stco = fullBox('stco', 0, 0, new Uint8Array([...u32(0)]));
      const stbl = box('stbl', concat(stsd, stts, stsc, stsz, stco));

      const vmhd = fullBox('vmhd', 0, 1, new Uint8Array([
        ...u16(0), ...u16(0), ...u16(0), ...u16(0) // graphicsmode + opcolor
      ]));
      const dref  = fullBox('dref', 0, 0, new Uint8Array([...u32(1), ...fullBox('url ', 0, 1, new Uint8Array(0))]));
      const dinf  = box('dinf', dref);
      const minf  = box('minf', concat(vmhd, dinf, stbl));
      const mdia  = box('mdia', concat(mdhd, hdlr, minf));
      const trak  = box('trak', concat(tkhd, mdia));

      // mvex (mandatory for fragmented MP4)
      const trex = fullBox('trex', 0, 0, new Uint8Array([
        ...u32(1), ...u32(1), ...u32(0), ...u32(0), ...u32(0)
      ]));
      const mvex = box('mvex', trex);
      const moov = box('moov', concat(mvhd, trak, mvex));

      // ── mdat ──
      const mdatSize = 8 + payload.length;
      const mdat = new Uint8Array([...u32(mdatSize), ...tag('mdat'), ...payload]);

      return concat(ftyp, moov, mdat);
    }

    // ── Main dispatcher ──
    startBtn.onclick = () => {
      const f = fmtSel.value;
      if      (f === 'png') exportPNG();
      else if (f === 'mp4') exportVideo();
    };
    } // end setupExport
    setupExport();
  })();
  </script>

</body></html>